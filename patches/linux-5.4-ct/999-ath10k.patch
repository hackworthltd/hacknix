diff -Nur linux-5.4.39/drivers/net/wireless/ath/ath10k/ahb.c linux-5.4.39-ct/drivers/net/wireless/ath/ath10k/ahb.c
--- linux-5.4.39/drivers/net/wireless/ath/ath10k/ahb.c	2020-05-06 07:15:17.000000000 +0100
+++ linux-5.4.39-ct/drivers/net/wireless/ath/ath10k/ahb.c	2020-05-12 23:23:34.000000000 +0100
@@ -627,6 +627,8 @@
 	ath10k_dbg(ar, ATH10K_DBG_BOOT, "boot ahb hif start\n");
 
 	napi_enable(&ar->napi);
+	ar->napi_enabled = true;
+
 	ath10k_ce_enable_interrupts(ar);
 	ath10k_pci_enable_legacy_irq(ar);
 
@@ -644,8 +646,11 @@
 	ath10k_ahb_irq_disable(ar);
 	synchronize_irq(ar_ahb->irq);
 
-	napi_synchronize(&ar->napi);
-	napi_disable(&ar->napi);
+	if (ar->napi_enabled) {
+		napi_synchronize(&ar->napi);
+		napi_disable(&ar->napi);
+		ar->napi_enabled = false;
+	}
 
 	ath10k_pci_flush(ar);
 }
diff -Nur linux-5.4.39/drivers/net/wireless/ath/ath10k/core.c linux-5.4.39-ct/drivers/net/wireless/ath/ath10k/core.c
--- linux-5.4.39/drivers/net/wireless/ath/ath10k/core.c	2020-05-06 07:15:17.000000000 +0100
+++ linux-5.4.39-ct/drivers/net/wireless/ath/ath10k/core.c	2020-05-12 23:23:34.000000000 +0100
@@ -12,6 +12,7 @@
 #include <linux/dmi.h>
 #include <linux/ctype.h>
 #include <asm/byteorder.h>
+#include <linux/ctype.h>
 
 #include "core.h"
 #include "mac.h"
@@ -25,7 +26,8 @@
 #include "wmi-ops.h"
 #include "coredump.h"
 
-unsigned int ath10k_debug_mask;
+/* Disable ath10k-ct DBGLOG output by default */
+unsigned int ath10k_debug_mask = ATH10K_DBG_NO_DBGLOG;
 EXPORT_SYMBOL(ath10k_debug_mask);
 
 static unsigned int ath10k_cryptmode_param;
@@ -38,6 +40,11 @@
 				     BIT(ATH10K_FW_CRASH_DUMP_CE_DATA);
 
 /* FIXME: most of these should be readonly */
+static int _modparam_override_eeprom_regdomain = -1;
+module_param_named(override_eeprom_regdomain,
+		   _modparam_override_eeprom_regdomain, int, 0444);
+MODULE_PARM_DESC(override_eeprom_regdomain, "Override regdomain hardcoded in EEPROM with this value (DANGEROUS).");
+
 module_param_named(debug_mask, ath10k_debug_mask, uint, 0644);
 module_param_named(cryptmode, ath10k_cryptmode_param, uint, 0644);
 module_param(uart_print, bool, 0644);
@@ -633,6 +640,29 @@
 	[ATH10K_FW_FEATURE_NON_BMI] = "non-bmi",
 	[ATH10K_FW_FEATURE_SINGLE_CHAN_INFO_PER_CHANNEL] = "single-chan-info-per-channel",
 	[ATH10K_FW_FEATURE_PEER_FIXED_RATE] = "peer-fixed-rate",
+	[ATH10K_FW_FEATURE_WMI_10X_CT] = "wmi-10.x-CT",
+	[ATH10K_FW_FEATURE_CT_RXSWCRYPT] = "rxswcrypt-CT",
+	[ATH10K_FW_FEATURE_HAS_TXSTATUS_NOACK] = "txstatus-noack",
+	[ATH10K_FW_FEATURE_CT_RATEMASK] = "ratemask-CT",
+	[ATH10K_FW_FEATURE_HAS_SAFE_BURST] = "safe-burst",
+	[ATH10K_FW_FEATURE_REGDUMP_CT] = "regdump-CT",
+	[ATH10K_FW_FEATURE_TXRATE_CT] = "txrate-CT",
+	[ATH10K_FW_FEATURE_FLUSH_ALL_CT] = "flush-all-CT",
+	[ATH10K_FW_FEATURE_PINGPONG_READ_CT] = "pingpong-CT",
+	[ATH10K_FW_FEATURE_SKIP_CH_RES_CT] = "ch-regs-CT",
+	[ATH10K_FW_FEATURE_NOP_CT] = "nop-CT",
+	[ATH10K_FW_FEATURE_HTT_MGT_CT] = "htt-mgt-CT",
+	[ATH10K_FW_FEATURE_SET_SPECIAL_CT] = "set-special-CT",
+	[ATH10K_FW_FEATURE_NO_BMISS_CT] = "no-bmiss-CT",
+	[ATH10K_FW_FEATURE_HAS_GET_TEMP_CT] = "get-temp-CT",
+	[ATH10K_FW_FEATURE_HAS_TX_RC_CT] = "tx-rc-CT",
+	[ATH10K_FW_FEATURE_CUST_STATS_CT] = "cust-stats-CT",
+	[ATH10K_FW_FEATURE_RETRY_GT2_CT] = "retry-gt2-CT",
+	[ATH10K_FW_FEATURE_CT_STA] = "CT-STA",
+	[ATH10K_FW_FEATURE_TXRATE2_CT] = "txrate2-CT",
+	[ATH10K_FW_FEATURE_BEACON_TX_CB_CT] = "beacon-cb-CT",
+	[ATH10K_FW_FEATURE_CONSUME_BLOCK_ACK_CT] = "wmi-block-ack-CT",
+	[ATH10K_FW_FEATURE_HAS_BCN_RC_CT] = "wmi-bcn-rc-CT",
 };
 
 static unsigned int ath10k_core_get_fw_feature_str(char *buf,
@@ -714,6 +744,12 @@
 {
 	u32 param_host;
 	int ret;
+	u32 tx_credits = TARGET_HTC_MAX_TX_CREDITS_CT;
+
+	/* at 64 vdevs, the NIC is tight on memory, so only allow 2
+	 * tx-credits in that case. */
+	if (ar->max_num_vdevs > 60)
+		tx_credits = min(tx_credits, (u32)2);
 
 	/* tell target which HTC version it is used*/
 	ret = ath10k_bmi_write32(ar, hi_app_host_interest,
@@ -723,6 +759,22 @@
 		return ret;
 	}
 
+	/* Configure HTC credits logic. */
+	param_host = (TARGET_HTC_MAX_CONTROL_BUFFERS << 16);
+	param_host |= (TARGET_HTC_MAX_PENDING_TXCREDITS_RPTS << 20);
+
+	/* Max tx buffers (tx-credits), CT firmware only.
+	 * but normal .487 firmware will just ignore it fine.
+	 */
+	param_host |= (tx_credits << 24);
+
+	ret = ath10k_bmi_write32(ar, hi_mbox_io_block_sz,
+				 param_host);
+	if (ret) {
+		ath10k_err(ar, "failed setting HTC mbox-io-block-sz\n");
+		return ret;
+	}
+
 	/* set the firmware mode to STA/IBSS/AP */
 	ret = ath10k_bmi_read32(ar, hi_option_flag, &param_host);
 	if (ret) {
@@ -1076,6 +1128,10 @@
 
 	ath10k_swap_code_seg_release(ar, &ar->normal_mode_fw.fw_file);
 
+	if (!IS_ERR(ar->fwcfg_file))
+		release_firmware(ar->fwcfg_file);
+	ar->fwcfg_file = NULL;
+
 	ar->normal_mode_fw.fw_file.otp_data = NULL;
 	ar->normal_mode_fw.fw_file.otp_len = 0;
 
@@ -1099,9 +1155,15 @@
 	if (!IS_ERR(ar->pre_cal_file))
 		goto success;
 
-	/* cal-<bus>-<id>.bin */
-	scnprintf(filename, sizeof(filename), "cal-%s-%s.bin",
-		  ath10k_bus_str(ar->hif.bus), dev_name(ar->dev));
+	if (ar->fwcfg.calname[0]) {
+		/* Use user-specified file name. */
+		strncpy(filename, ar->fwcfg.calname, sizeof(filename));
+		filename[sizeof(filename) - 1] = 0;
+	} else {
+		/* cal-<bus>-<id>.bin */
+		scnprintf(filename, sizeof(filename), "cal-%s-%s.bin",
+			  ath10k_bus_str(ar->hif.bus), dev_name(ar->dev));
+	}
 
 	ar->cal_file = ath10k_fetch_fw_file(ar, ATH10K_FW_DIR, filename);
 	if (IS_ERR(ar->cal_file))
@@ -1114,6 +1176,258 @@
 	return 0;
 }
 
+static int ath10k_fetch_fwcfg_file(struct ath10k *ar)
+{
+	char filename[100];
+	const char* buf;
+	size_t i = 0;
+	char val[100];
+	size_t key_idx;
+	size_t val_idx;
+	char c;
+	size_t sz;
+	long t;
+
+	ar->fwcfg.flags = 0;
+
+	/* fwcfg-<bus>-<id>.txt */
+	/* If this changes, change ath10k_read_fwinfo as well. */
+	scnprintf(filename, sizeof(filename), "fwcfg-%s-%s.txt",
+		  ath10k_bus_str(ar->hif.bus), dev_name(ar->dev));
+
+	ar->fwcfg_file = ath10k_fetch_fw_file(ar, ATH10K_FW_DIR, filename);
+	if (IS_ERR(ar->fwcfg_file)) {
+		/* FW config file is optional, don't be scary. */
+		ath10k_dbg(ar, ATH10K_DBG_BOOT,
+			   "Could not find firmware config file %s/%s, continuing with defaults.\n",
+			   ATH10K_FW_DIR, filename);
+		return PTR_ERR(ar->fwcfg_file);
+	}
+
+	ath10k_dbg(ar, ATH10K_DBG_BOOT, "found firmware config file %s/%s\n",
+		   ATH10K_FW_DIR, filename);
+
+	/* Now, attempt to parse results.
+	 * Format is key=value
+	 */
+	buf = (const char*)(ar->fwcfg_file->data);
+	while (i < ar->fwcfg_file->size) {
+start_again:
+		/* First, eat space, or entire line if we have # as first char */
+		c = buf[i];
+		while (isspace(c)) {
+			i++;
+			if (i >= ar->fwcfg_file->size)
+				goto done;
+			c = buf[i];
+		}
+		/* Eat comment ? */
+		if (c == '#') {
+			i++;
+			while (i < ar->fwcfg_file->size) {
+				c = buf[i];
+				i++;
+				if (c == '\n')
+					goto start_again;
+			}
+			/* Found no newline, must be done. */
+			goto done;
+		}
+
+		/* If here, we have start of token, store it in 'filename' to save space */
+		key_idx = 0;
+		while (i < ar->fwcfg_file->size) {
+			c = buf[i];
+			if (c == '=') {
+				i++;
+				c = buf[i];
+				/* Eat any space after the '=' sign. */
+				while (i < ar->fwcfg_file->size) {
+					if (!isspace(c)) {
+						break;
+					}
+					i++;
+					c = buf[i];
+				}
+				break;
+			}
+			if (isspace(c)) {
+				i++;
+				continue;
+			}
+			filename[key_idx] = c;
+			key_idx++;
+			if (key_idx >= sizeof(filename)) {
+				/* Too long, bail out. */
+				goto done;
+			}
+			i++;
+		}
+		filename[key_idx] = 0; /* null terminate */
+
+		/* We have found the key, now find the value */
+		val_idx = 0;
+		while (i < ar->fwcfg_file->size) {
+			c = buf[i];
+			if (isspace(c))
+				break;
+			val[val_idx] = c;
+			val_idx++;
+			if (val_idx >= sizeof(val)) {
+				/* Too long, bail out. */
+				goto done;
+			}
+			i++;
+		}
+		val[val_idx] = 0; /* null terminate value */
+
+		/* We have key and value now. */
+		ath10k_warn(ar, "fwcfg key: %s  val: %s\n",
+			    filename, val);
+
+		/* Assign key and values as appropriate */
+		if (strcasecmp(filename, "calname") == 0) {
+			sz = sizeof(ar->fwcfg.calname);
+			strncpy(ar->fwcfg.calname, val, sz);
+			ar->fwcfg.calname[sz - 1] = 0; /* ensure null term */
+		}
+		else if (strcasecmp(filename, "bname") == 0) {
+			sz = sizeof(ar->fwcfg.bname);
+			strncpy(ar->fwcfg.bname, val, sz);
+			ar->fwcfg.bname[sz - 1] = 0; /* ensure null term */
+		}
+		else if (strcasecmp(filename, "bname_ext") == 0) {
+			sz = sizeof(ar->fwcfg.bname_ext);
+			strncpy(ar->fwcfg.bname_ext, val, sz);
+			ar->fwcfg.bname_ext[sz - 1] = 0; /* ensure null term */
+		}
+		else if (strcasecmp(filename, "fwname") == 0) {
+			sz = sizeof(ar->fwcfg.fwname);
+			strncpy(ar->fwcfg.fwname, val, sz);
+			ar->fwcfg.fwname[sz - 1] = 0; /* ensure null term */
+		}
+		else if (strcasecmp(filename, "fwver") == 0) {
+			if (kstrtol(val, 0, &t) == 0) {
+				ar->fwcfg.fwver = t;
+				ar->fwcfg.flags |= ATH10K_FWCFG_FWVER;
+			}
+		}
+		else if (strcasecmp(filename, "vdevs") == 0) {
+			if (kstrtol(val, 0, &t) == 0) {
+				ar->fwcfg.vdevs = t;
+				ar->fwcfg.flags |= ATH10K_FWCFG_VDEVS;
+			}
+		}
+		else if (strcasecmp(filename, "stations") == 0) {
+			if (kstrtol(val, 0, &t) == 0) {
+				ar->fwcfg.stations = t;
+				ar->fwcfg.flags |= ATH10K_FWCFG_STATIONS;
+			}
+		}
+		else if (strcasecmp(filename, "peers") == 0) {
+			if (kstrtol(val, 0, &t) == 0) {
+				ar->fwcfg.peers = t;
+				ar->fwcfg.flags |= ATH10K_FWCFG_PEERS;
+			}
+		}
+		else if (strcasecmp(filename, "nohwcrypt") == 0) {
+			if (kstrtol(val, 0, &t) == 0) {
+				ar->fwcfg.nohwcrypt = t;
+				ar->fwcfg.flags |= ATH10K_FWCFG_NOHWCRYPT;
+			}
+		}
+		else if (strcasecmp(filename, "allow_all_mcs") == 0) {
+			if (kstrtol(val, 0, &t) == 0) {
+				ar->fwcfg.allow_all_mcs = t;
+				ar->fwcfg.flags |= ATH10K_FWCFG_ALLOW_ALL_MCS;
+			}
+		}
+		else if (strcasecmp(filename, "ct_sta_mode") == 0) {
+			if (kstrtol(val, 0, &t) == 0) {
+				ar->fwcfg.ct_sta_mode = t;
+				ar->fwcfg.flags |= ATH10K_FWCFG_CT_STA;
+			}
+		}
+		else if (strcasecmp(filename, "nobeamform_mu") == 0) {
+			if (kstrtol(val, 0, &t) == 0) {
+				ar->fwcfg.nobeamform_mu = t;
+				ar->fwcfg.flags |= ATH10K_FWCFG_NOBEAMFORM_MU;
+			}
+		}
+		else if (strcasecmp(filename, "nobeamform_su") == 0) {
+			if (kstrtol(val, 0, &t) == 0) {
+				ar->fwcfg.nobeamform_su = t;
+				ar->fwcfg.flags |= ATH10K_FWCFG_NOBEAMFORM_SU;
+			}
+		}
+		else if (strcasecmp(filename, "rate_ctrl_objs") == 0) {
+			if (kstrtol(val, 0, &t) == 0) {
+				ar->fwcfg.rate_ctrl_objs = t;
+				ar->fwcfg.flags |= ATH10K_FWCFG_RATE_CTRL_OBJS;
+			}
+		}
+		else if (strcasecmp(filename, "tx_desc") == 0) {
+			if (kstrtol(val, 0, &t) == 0) {
+				ar->fwcfg.tx_desc = t;
+				ar->fwcfg.flags |= ATH10K_FWCFG_TX_DESC;
+			}
+		}
+		else if (strcasecmp(filename, "max_nss") == 0) {
+			if (kstrtol(val, 0, &t) == 0) {
+				ar->fwcfg.max_nss = t;
+				ar->fwcfg.flags |= ATH10K_FWCFG_MAX_NSS;
+			}
+		}
+		else if (strcasecmp(filename, "tids") == 0) {
+			if (kstrtol(val, 0, &t) == 0) {
+				ar->fwcfg.num_tids = t;
+				ar->fwcfg.flags |= ATH10K_FWCFG_NUM_TIDS;
+			}
+		}
+		else if (strcasecmp(filename, "active_peers") == 0) {
+			if (kstrtol(val, 0, &t) == 0) {
+				ar->fwcfg.active_peers = t;
+				ar->fwcfg.flags |= ATH10K_FWCFG_ACTIVE_PEERS;
+			}
+		}
+		else if (strcasecmp(filename, "skid_limit") == 0) {
+			if (kstrtol(val, 0, &t) == 0) {
+				ar->fwcfg.skid_limit = t;
+				ar->fwcfg.flags |= ATH10K_FWCFG_SKID_LIMIT;
+			}
+		}
+		else if (strcasecmp(filename, "regdom") == 0) {
+			if (kstrtol(val, 0, &t) == 0) {
+				ar->fwcfg.regdom = t;
+				ar->fwcfg.flags |= ATH10K_FWCFG_REGDOM;
+			}
+		}
+		else if (strcasecmp(filename, "bmiss_vdevs") == 0) {
+			if (kstrtol(val, 0, &t) == 0) {
+				ar->fwcfg.bmiss_vdevs = t;
+				ar->fwcfg.flags |= ATH10K_FWCFG_BMISS_VDEVS;
+			}
+		}
+		else if (strcasecmp(filename, "max_amsdus") == 0) {
+			if (kstrtol(val, 0, &t) == 0) {
+				ar->fwcfg.max_amsdus = t;
+				ar->fwcfg.flags |= ATH10K_FWCFG_MAX_AMSDUS;
+				if (ar->fwcfg.max_amsdus > 31) {
+					ath10k_warn(ar, "Invalid fwcfg max_amsdus value: %d.  Must not be greater than 31.\n",
+						    ar->fwcfg.max_amsdus);
+					ar->fwcfg.max_amsdus = 31;
+				}
+			}
+		}
+		else {
+			ath10k_warn(ar, "Unknown fwcfg key name -:%s:-, val: %s\n",
+				    filename, val);
+		}
+	}
+done:
+	return 0;
+}
+
 static int ath10k_core_fetch_board_data_api_1(struct ath10k *ar, int bd_ie_type)
 {
 	const struct firmware *fw;
@@ -1124,9 +1438,14 @@
 			return -EINVAL;
 		}
 
-		ar->normal_mode_fw.board = ath10k_fetch_fw_file(ar,
-								ar->hw_params.fw.dir,
-								ar->hw_params.fw.board);
+		if (ar->fwcfg.bname[0])
+			ar->normal_mode_fw.board = ath10k_fetch_fw_file(ar,
+									ar->hw_params.fw.dir,
+									ar->fwcfg.bname);
+		else
+			ar->normal_mode_fw.board = ath10k_fetch_fw_file(ar,
+									ar->hw_params.fw.dir,
+									ar->hw_params.fw.board);
 		if (IS_ERR(ar->normal_mode_fw.board))
 			return PTR_ERR(ar->normal_mode_fw.board);
 
@@ -1138,8 +1457,12 @@
 			return -EINVAL;
 		}
 
-		fw = ath10k_fetch_fw_file(ar, ar->hw_params.fw.dir,
-					  ar->hw_params.fw.eboard);
+		if (ar->fwcfg.bname_ext[0])
+			fw = ath10k_fetch_fw_file(ar, ar->hw_params.fw.dir,
+						  ar->fwcfg.bname_ext);
+		else
+			fw = ath10k_fetch_fw_file(ar, ar->hw_params.fw.dir,
+						  ar->hw_params.fw.eboard);
 		ar->normal_mode_fw.ext_board = fw;
 		if (IS_ERR(ar->normal_mode_fw.ext_board))
 			return PTR_ERR(ar->normal_mode_fw.ext_board);
@@ -1148,6 +1471,14 @@
 		ar->normal_mode_fw.ext_board_len = ar->normal_mode_fw.ext_board->size;
 	}
 
+	/* Save firmware board name so we can display it later. */
+	if (ar->fwcfg.bname[0])
+		strlcpy(ar->normal_mode_fw.fw_file.fw_board_name, ar->fwcfg.bname,
+			sizeof(ar->normal_mode_fw.fw_file.fw_board_name));
+	else
+		strlcpy(ar->normal_mode_fw.fw_file.fw_board_name, ar->hw_params.fw.board,
+			sizeof(ar->normal_mode_fw.fw_file.fw_board_name));
+
 	return 0;
 }
 
@@ -1363,6 +1694,10 @@
 	if (ret)
 		goto err;
 
+	/* Save firmware board name so we can display it later. */
+	strlcpy(ar->normal_mode_fw.fw_file.fw_board_name, filename,
+		sizeof(ar->normal_mode_fw.fw_file.fw_board_name));
+
 	return 0;
 
 err:
@@ -1470,7 +1805,26 @@
 	}
 
 success:
-	ath10k_dbg(ar, ATH10K_DBG_BOOT, "using board api %d\n", ar->bd_api);
+	/* Store configAddr overloads to apply after firmware boots.  OTP will likely
+	 * overwrite them and so they would otherwise be lost.
+	 */
+	if (ar->hw_params.id == QCA988X_HW_2_0_VERSION) {
+		int addrs = 24;
+		int i;
+		u32 *e32 = (u32*)(ar->normal_mode_fw.board_data);
+		int offset = (ar->hw_params.cal_data_len - (addrs * 4)) / 4; /* Start of configAddr */
+		/*ath10k_dbg(ar, ATH10K_DBG_BOOT, "Check saving eeprom configAddr from board-data\n");*/
+		for (i = 0; i<addrs; i++) {
+			ar->eeprom_configAddrs[i] = le32_to_cpu(e32[offset + i]);
+			if (ar->eeprom_configAddrs[i]) {
+				ath10k_dbg(ar, ATH10K_DBG_BOOT, "saving eeprom configAddr[%i]: 0x%08x\n",
+					   i, ar->eeprom_configAddrs[i]);
+			}
+		}
+	}
+
+	ath10k_dbg(ar, ATH10K_DBG_BOOT, "using board api %d, specified-file-name: %s\n",
+		   ar->bd_api, ar->fwcfg.bname[0] ? ar->fwcfg.bname : "NA");
 	return 0;
 }
 EXPORT_SYMBOL(ath10k_core_fetch_board_file);
@@ -1760,6 +2114,13 @@
 	return ret;
 }
 
+struct ath10k_bss_rom_ie {
+	__le32 ram_addr;
+	__le32 ram_len;
+	__le32 rom_addr;
+	__le32 rom_len;
+} __packed;
+
 int ath10k_core_fetch_firmware_api_n(struct ath10k *ar, const char *name,
 				     struct ath10k_fw_file *fw_file)
 {
@@ -1768,6 +2129,7 @@
 	struct ath10k_fw_ie *hdr;
 	const u8 *data;
 	__le32 *timestamp, *version;
+	struct ath10k_bss_rom_ie *bss;
 
 	/* first fetch the firmware file (firmware-*.bin) */
 	fw_file->firmware = ath10k_fetch_fw_file(ar, ar->hw_params.fw.dir,
@@ -1881,6 +2243,12 @@
 
 			break;
 		case ATH10K_FW_IE_WMI_OP_VERSION:
+			/* Upstream stole the ID CT firmware was using, so add
+			 * hack-around to deal with backwards-compat. --Ben
+			 */
+			if (ie_len >= sizeof(*bss))
+				goto fw_ie_bss_info_ct;
+
 			if (ie_len != sizeof(u32))
 				break;
 
@@ -1909,6 +2277,40 @@
 			fw_file->codeswap_data = data;
 			fw_file->codeswap_len = ie_len;
 			break;
+		case ATH10K_FW_IE_BSS_INFO_CT:
+fw_ie_bss_info_ct:
+			if (ie_len < sizeof(*bss)) {
+				ath10k_warn(ar, "invalid ie len for bss-info (%zd)\n",
+					    ie_len);
+				break;
+			}
+			bss = (struct ath10k_bss_rom_ie *)(data);
+
+			fw_file->ram_bss_addr = le32_to_cpu(bss->ram_addr);
+			fw_file->ram_bss_len = le32_to_cpu(bss->ram_len);
+			ath10k_dbg(ar, ATH10K_DBG_BOOT,
+				   "found RAM BSS addr 0x%x length %d\n",
+				   fw_file->ram_bss_addr, fw_file->ram_bss_len);
+
+			if (fw_file->ram_bss_len > ATH10K_RAM_BSS_BUF_LEN) {
+				ath10k_warn(ar, "too long firmware RAM BSS length: %d\n",
+					    fw_file->ram_bss_len);
+				fw_file->ram_bss_len = 0;
+			}
+
+			fw_file->rom_bss_addr = le32_to_cpu(bss->rom_addr);
+			fw_file->rom_bss_len = le32_to_cpu(bss->rom_len);
+			ath10k_dbg(ar, ATH10K_DBG_BOOT,
+				   "found ROM BSS addr 0x%x length %d\n",
+				   fw_file->rom_bss_addr, fw_file->rom_bss_len);
+
+			if (fw_file->rom_bss_len > ATH10K_ROM_BSS_BUF_LEN) {
+				ath10k_warn(ar, "too long firmware ROM BSS length: %d\n",
+					    fw_file->rom_bss_len);
+				fw_file->rom_bss_len = 0;
+			}
+
+			break;
 		default:
 			ath10k_warn(ar, "Unknown FW IE: %u\n",
 				    le32_to_cpu(hdr->id));
@@ -1930,6 +2332,23 @@
 		goto err;
 	}
 
+	/* Only CT firmware has BSS stuff, so we can use this to fix up
+	 * flags for backwards and forwards compat with older/newer CT firmware.
+	 * (upstream stole some bits it was using)
+	 */
+	if (fw_file->rom_bss_addr) {
+		if (test_bit(5, fw_file->fw_features))
+			__set_bit(ATH10K_FW_FEATURE_WMI_10X_CT,
+				  fw_file->fw_features);
+
+		if (test_bit(6, fw_file->fw_features))
+			__set_bit(ATH10K_FW_FEATURE_CT_RXSWCRYPT,
+				  fw_file->fw_features);
+	}
+
+	/* Save firmware name so we can display it later. */
+	strlcpy(fw_file->fw_name, name, sizeof(fw_file->fw_name));
+
 	return 0;
 
 err:
@@ -1961,9 +2380,49 @@
 	int ret, i;
 	char fw_name[100];
 
+	/* First, see if we have a special config file for this firmware. */
+	ath10k_fetch_fwcfg_file(ar);
+
 	/* calibration file is optional, don't check for any errors */
 	ath10k_fetch_cal_file(ar);
 
+	/* Check for user-specified firmware name. */
+	if (ar->fwcfg.fwname[0]) {
+		if (ar->fwcfg.flags & ATH10K_FWCFG_FWVER) {
+			ar->fw_api = ar->fwcfg.fwver;
+			ath10k_dbg(ar, ATH10K_DBG_BOOT,
+				   "trying user-specified fw %s api %d\n",
+				   ar->fwcfg.fwname, ar->fw_api);
+
+			ret = ath10k_core_fetch_firmware_api_n(ar, ar->fwcfg.fwname,
+							       &ar->normal_mode_fw.fw_file);
+			if (ret == 0)
+				goto success;
+		}
+		else {
+			ath10k_warn(ar, "fwcfg fwname specified but no fwver specified, ignoring fwname.\n");
+		}
+	}
+
+	/* Check for CT firmware version 5 API. */
+	ar->fw_api = 5;
+	ath10k_dbg(ar, ATH10K_DBG_BOOT,
+		   "trying CT firmware version 5: ct-firmware-5.bin\n");
+	ret = ath10k_core_fetch_firmware_api_n(ar, "ct-firmware-5.bin",
+					       &ar->normal_mode_fw.fw_file);
+	if (ret == 0)
+		goto success;
+
+	/* Check for CT firmware version 2 API. */
+	ar->fw_api = 2;
+	ath10k_dbg(ar, ATH10K_DBG_BOOT,
+		   "trying CT firmware version 2: ct-firmware-2.bin\n");
+	ret = ath10k_core_fetch_firmware_api_n(ar, "ct-firmware-2.bin",
+					       &ar->normal_mode_fw.fw_file);
+	if (ret == 0)
+		goto success;
+
+
 	for (i = ATH10K_FW_API_MAX; i >= ATH10K_FW_API_MIN; i--) {
 		ar->fw_api = i;
 		ath10k_dbg(ar, ATH10K_DBG_BOOT, "trying fw api %d\n",
@@ -1985,11 +2444,55 @@
 	return ret;
 
 success:
-	ath10k_dbg(ar, ATH10K_DBG_BOOT, "using fw api %d\n", ar->fw_api);
+	ath10k_dbg(ar, ATH10K_DBG_BOOT, "using fw api %d: %s/%s\n",
+		   ar->fw_api, ar->hw_params.fw.dir,
+		   ar->normal_mode_fw.fw_file.fw_name);
 
 	return 0;
 }
 
+int ath10k_sum_sigs_2(int a, int b) {
+	int diff;
+
+	/* 0x80 means value-is-not-set */
+	if (b == 0x80)
+		return a;
+
+	if (a >= b) {
+		/* a is largest value, add to it. */
+		diff = a - b;
+		if (diff == 0)
+			return a + 3;
+		else if (diff == 1)
+			return a + 2;
+		else if (diff == 2)
+			return a + 1;
+		return a;
+	}
+	else {
+		/* b is largest value, add to it. */
+		diff = b - a;
+		if (diff == 0)
+			return b + 3;
+		else if (diff == 1)
+			return b + 2;
+		else if (diff == 2)
+			return b + 1;
+		return b;
+	}
+}
+
+int ath10k_sum_sigs(int p20, int e20, int e40, int e80) {
+	/* Hacky attempt at summing dbm without resorting to log(10) business */
+	/* 0x80 means value-is-not-set */
+	if (e40 != 0x80) {
+		return ath10k_sum_sigs_2(ath10k_sum_sigs_2(p20, e20), ath10k_sum_sigs_2(e40, e80));
+	}
+	else {
+		return ath10k_sum_sigs_2(p20, e20);
+	}
+}
+
 static int ath10k_core_pre_cal_download(struct ath10k *ar)
 {
 	int ret;
@@ -2038,7 +2541,7 @@
 
 	ret = ath10k_download_and_run_otp(ar);
 	if (ret) {
-		ath10k_err(ar, "failed to run otp: %d\n", ret);
+		ath10k_err(ar, "failed to run otp: %d (pre-cal-config)\n", ret);
 		return ret;
 	}
 
@@ -2092,7 +2595,7 @@
 
 	ret = ath10k_download_and_run_otp(ar);
 	if (ret) {
-		ath10k_err(ar, "failed to run otp: %d\n", ret);
+		ath10k_err(ar, "failed to run otp: %d (download-cal-data)\n", ret);
 		return ret;
 	}
 
@@ -2151,7 +2654,8 @@
 		return ret;
 	}
 
-	ath10k_info(ar, "UART prints enabled\n");
+	ath10k_info(ar, "UART prints enabled: 19200, tx-pin: %d\n",
+		    ar->hw_params.uart_pin);
 	return 0;
 }
 
@@ -2216,6 +2720,7 @@
 	 * with conf_mutex it will deadlock.
 	 */
 	cancel_work_sync(&ar->set_coverage_class_work);
+	cancel_work_sync(&ar->stop_scan_work);
 
 	mutex_lock(&ar->conf_mutex);
 
@@ -2346,33 +2851,110 @@
 		}
 	}
 
+	/* Backwards compatibility for firmwares without
+	 * ATH10K_FW_IE_HTT_OP_VERSION.
+	 */
+	if (fw_file->htt_op_version == ATH10K_FW_HTT_OP_VERSION_UNSET) {
+		switch (fw_file->wmi_op_version) {
+		case ATH10K_FW_WMI_OP_VERSION_MAIN:
+			fw_file->htt_op_version = ATH10K_FW_HTT_OP_VERSION_MAIN;
+			break;
+		case ATH10K_FW_WMI_OP_VERSION_10_1:
+		case ATH10K_FW_WMI_OP_VERSION_10_2:
+		case ATH10K_FW_WMI_OP_VERSION_10_2_4:
+			fw_file->htt_op_version = ATH10K_FW_HTT_OP_VERSION_10_1;
+			break;
+		case ATH10K_FW_WMI_OP_VERSION_TLV:
+			fw_file->htt_op_version = ATH10K_FW_HTT_OP_VERSION_TLV;
+			break;
+		case ATH10K_FW_WMI_OP_VERSION_10_4:
+		case ATH10K_FW_WMI_OP_VERSION_UNSET:
+		case ATH10K_FW_WMI_OP_VERSION_MAX:
+			WARN_ON(1);
+			return -EINVAL;
+		}
+	}
+
+	/* CT 10.1 firmware slowly added features, all mostly under one feature
+	 * flag.  But, for 10.2, I need to add features at a time so that we can
+	 * maintain ability to bisect the firmware and to have fine-grained support
+	 * for enabling/disabling firmware features.  For backwards-compt with 10.1
+	 * firmware, set all the flags here.
+	 */
+	if (test_bit(ATH10K_FW_FEATURE_WMI_10X_CT, fw_file->fw_features) &&
+	    (fw_file->wmi_op_version == ATH10K_FW_WMI_OP_VERSION_10_1)) {
+		__set_bit(ATH10K_FW_FEATURE_SET_SPECIAL_CT, fw_file->fw_features);
+		__set_bit(ATH10K_FW_FEATURE_REGDUMP_CT, fw_file->fw_features);
+		__set_bit(ATH10K_FW_FEATURE_TXRATE_CT, fw_file->fw_features);
+		__set_bit(ATH10K_FW_FEATURE_FLUSH_ALL_CT, fw_file->fw_features);
+		__set_bit(ATH10K_FW_FEATURE_PINGPONG_READ_CT, fw_file->fw_features);
+		__set_bit(ATH10K_FW_FEATURE_SKIP_CH_RES_CT, fw_file->fw_features);
+		__set_bit(ATH10K_FW_FEATURE_NOP_CT, fw_file->fw_features);
+	}
+
 	switch (fw_file->wmi_op_version) {
 	case ATH10K_FW_WMI_OP_VERSION_MAIN:
 		max_num_peers = TARGET_NUM_PEERS;
+		ar->bmiss_offload_max_vdev = TARGET_BMISS_OFFLOAD_MAX_VDEV;
+		ar->skid_limit = TARGET_AST_SKID_LIMIT;
 		ar->max_num_stations = TARGET_NUM_STATIONS;
 		ar->max_num_vdevs = TARGET_NUM_VDEVS;
 		ar->htt.max_num_pending_tx = TARGET_NUM_MSDU_DESC;
 		ar->fw_stats_req_mask = WMI_STAT_PDEV | WMI_STAT_VDEV |
 			WMI_STAT_PEER;
 		ar->max_spatial_stream = WMI_MAX_SPATIAL_STREAM;
+		ar->num_tids = TARGET_NUM_TIDS;
 		break;
 	case ATH10K_FW_WMI_OP_VERSION_10_1:
+		ar->bmiss_offload_max_vdev = TARGET_10X_BMISS_OFFLOAD_MAX_VDEV;
+		ar->skid_limit = TARGET_10X_AST_SKID_LIMIT;
+		ar->num_tids = TARGET_10X_NUM_TIDS;
+		if (test_bit(ATH10K_FW_FEATURE_WMI_10X_CT,
+			     fw_file->fw_features)) {
+			ar->skid_limit = TARGET_10X_AST_SKID_LIMIT_CT;
+			max_num_peers = ath10k_modparam_target_num_peers_ct;
+			ar->max_num_peers = ath10k_modparam_target_num_peers_ct;
+			ar->max_num_stations = TARGET_10X_NUM_STATIONS;
+			ar->max_num_vdevs = ath10k_modparam_target_num_vdevs_ct;
+			ar->htt.max_num_pending_tx = ath10k_modparam_target_num_msdu_desc_ct;
+		} else {
+			max_num_peers = TARGET_10X_NUM_PEERS;
+			ar->max_num_peers = TARGET_10X_NUM_PEERS;
+			ar->max_num_stations = TARGET_10X_NUM_STATIONS;
+			ar->max_num_vdevs = TARGET_10X_NUM_VDEVS;
+			ar->htt.max_num_pending_tx = TARGET_10X_NUM_MSDU_DESC;
+		}
+		ar->fw_stats_req_mask = WMI_STAT_PEER;
+		ar->max_spatial_stream = WMI_MAX_SPATIAL_STREAM;
+		break;
 	case ATH10K_FW_WMI_OP_VERSION_10_2:
 	case ATH10K_FW_WMI_OP_VERSION_10_2_4:
 		if (ath10k_peer_stats_enabled(ar)) {
 			max_num_peers = TARGET_10X_TX_STATS_NUM_PEERS;
 			ar->max_num_stations = TARGET_10X_TX_STATS_NUM_STATIONS;
+			ar->num_tids = TARGET_10X_TX_STATS_NUM_TIDS;
 		} else {
 			max_num_peers = TARGET_10X_NUM_PEERS;
 			ar->max_num_stations = TARGET_10X_NUM_STATIONS;
+			ar->num_tids = TARGET_10X_NUM_TIDS;
 		}
+		ar->bmiss_offload_max_vdev = TARGET_10X_BMISS_OFFLOAD_MAX_VDEV;
+		ar->skid_limit = TARGET_10X_AST_SKID_LIMIT;
 		ar->max_num_vdevs = TARGET_10X_NUM_VDEVS;
 		ar->htt.max_num_pending_tx = TARGET_10X_NUM_MSDU_DESC;
+
+		if (test_bit(ATH10K_FW_FEATURE_WMI_10X_CT,
+			     fw_file->fw_features)) {
+			ar->max_num_peers = ath10k_modparam_target_num_peers_ct;
+			ar->max_num_vdevs = ath10k_modparam_target_num_vdevs_ct;
+			ar->htt.max_num_pending_tx = ath10k_modparam_target_num_msdu_desc_ct;
+		}
 		ar->fw_stats_req_mask = WMI_STAT_PEER;
 		ar->max_spatial_stream = WMI_MAX_SPATIAL_STREAM;
 		break;
 	case ATH10K_FW_WMI_OP_VERSION_TLV:
 		max_num_peers = TARGET_TLV_NUM_PEERS;
+		ar->bmiss_offload_max_vdev = TARGET_10X_BMISS_OFFLOAD_MAX_VDEV;
 		ar->max_num_stations = TARGET_TLV_NUM_STATIONS;
 		ar->max_num_vdevs = TARGET_TLV_NUM_VDEVS;
 		ar->max_num_tdls_vdevs = TARGET_TLV_NUM_TDLS_VDEVS;
@@ -2389,6 +2971,8 @@
 		break;
 	case ATH10K_FW_WMI_OP_VERSION_10_4:
 		max_num_peers = TARGET_10_4_NUM_PEERS;
+		ar->bmiss_offload_max_vdev = TARGET_10_4_BMISS_OFFLOAD_MAX_VDEV;
+		ar->skid_limit = TARGET_10_4_AST_SKID_LIMIT;
 		ar->max_num_stations = TARGET_10_4_NUM_STATIONS;
 		ar->num_active_peers = TARGET_10_4_ACTIVE_PEERS;
 		ar->max_num_vdevs = TARGET_10_4_NUM_VDEVS;
@@ -2404,6 +2988,7 @@
 			ar->htt.max_num_pending_tx = TARGET_10_4_NUM_MSDU_DESC_PFC;
 		else
 			ar->htt.max_num_pending_tx = TARGET_10_4_NUM_MSDU_DESC;
+
 		break;
 	case ATH10K_FW_WMI_OP_VERSION_UNSET:
 	case ATH10K_FW_WMI_OP_VERSION_MAX:
@@ -2417,28 +3002,66 @@
 	else
 		ar->max_num_peers = max_num_peers;
 
-	/* Backwards compatibility for firmwares without
-	 * ATH10K_FW_IE_HTT_OP_VERSION.
+	ar->request_ct_sta = ath10k_modparam_ct_sta;
+	ar->request_nohwcrypt = ath10k_modparam_nohwcrypt;
+	ar->request_nobeamform_mu = ath10k_modparam_nobeamform_mu;
+	ar->request_nobeamform_su = ath10k_modparam_nobeamform_su;
+	ar->num_ratectrl_objs = ath10k_modparam_target_num_rate_ctrl_objs_ct;
+	ar->eeprom_regdom = _modparam_override_eeprom_regdomain;
+
+	/* Apply user-specified over-rides, if any. */
+	if (ar->fwcfg.flags & ATH10K_FWCFG_VDEVS)
+		ar->max_num_vdevs = ar->fwcfg.vdevs;
+	if (ar->fwcfg.flags & ATH10K_FWCFG_PEERS)
+		ar->max_num_peers = ar->fwcfg.peers;
+	if (ar->fwcfg.flags & ATH10K_FWCFG_STATIONS)
+		ar->max_num_stations = ar->fwcfg.stations;
+	if (ar->fwcfg.flags & ATH10K_FWCFG_NOHWCRYPT)
+		ar->request_nohwcrypt = ar->fwcfg.nohwcrypt;
+	if (ar->fwcfg.flags & ATH10K_FWCFG_CT_STA)
+		ar->request_ct_sta = ar->fwcfg.ct_sta_mode;
+	if (ar->fwcfg.flags & ATH10K_FWCFG_NOBEAMFORM_MU)
+		ar->request_nobeamform_mu = ar->fwcfg.nobeamform_mu;
+	if (ar->fwcfg.flags & ATH10K_FWCFG_NOBEAMFORM_SU)
+		ar->request_nobeamform_su = ar->fwcfg.nobeamform_su;
+	if (ar->fwcfg.flags & ATH10K_FWCFG_RATE_CTRL_OBJS)
+		ar->num_ratectrl_objs = ar->fwcfg.rate_ctrl_objs;
+	if (ar->fwcfg.flags & ATH10K_FWCFG_TX_DESC)
+		ar->htt.max_num_pending_tx = ar->fwcfg.tx_desc;
+	if (ar->fwcfg.flags & ATH10K_FWCFG_MAX_NSS)
+		ar->max_spatial_stream = ar->fwcfg.max_nss;
+	if (ar->fwcfg.flags & ATH10K_FWCFG_NUM_TIDS)
+		ar->num_tids = ar->fwcfg.num_tids;
+	if (ar->fwcfg.flags & ATH10K_FWCFG_ACTIVE_PEERS)
+		ar->num_active_peers = ar->fwcfg.active_peers;
+	if (ar->fwcfg.flags & ATH10K_FWCFG_SKID_LIMIT)
+		ar->skid_limit = ar->fwcfg.skid_limit;
+	if (ar->fwcfg.flags & ATH10K_FWCFG_REGDOM)
+		ar->eeprom_regdom = ar->fwcfg.regdom;
+	if (ar->fwcfg.flags & ATH10K_FWCFG_BMISS_VDEVS)
+		ar->bmiss_offload_max_vdev = ar->fwcfg.bmiss_vdevs;
+
+	if (!(test_bit(ATH10K_FLAG_RAW_MODE, &ar->dev_flags))) {
+		/* Don't disable raw-mode hack, but otherwise allow override */
+		if (ar->fwcfg.flags & ATH10K_FWCFG_MAX_AMSDUS)
+			ar->htt.max_num_amsdu = ar->fwcfg.max_amsdus;
+	}
+
+	/* Some firmware may compile out beacon-miss logic to save firmware RAM
+	 * and instruction RAM.
 	 */
-	if (fw_file->htt_op_version == ATH10K_FW_HTT_OP_VERSION_UNSET) {
-		switch (fw_file->wmi_op_version) {
-		case ATH10K_FW_WMI_OP_VERSION_MAIN:
-			fw_file->htt_op_version = ATH10K_FW_HTT_OP_VERSION_MAIN;
-			break;
-		case ATH10K_FW_WMI_OP_VERSION_10_1:
-		case ATH10K_FW_WMI_OP_VERSION_10_2:
-		case ATH10K_FW_WMI_OP_VERSION_10_2_4:
-			fw_file->htt_op_version = ATH10K_FW_HTT_OP_VERSION_10_1;
-			break;
-		case ATH10K_FW_WMI_OP_VERSION_TLV:
-			fw_file->htt_op_version = ATH10K_FW_HTT_OP_VERSION_TLV;
-			break;
-		case ATH10K_FW_WMI_OP_VERSION_10_4:
-		case ATH10K_FW_WMI_OP_VERSION_UNSET:
-		case ATH10K_FW_WMI_OP_VERSION_MAX:
-			ath10k_err(ar, "htt op version not found from fw meta data");
-			return -EINVAL;
-		}
+	if (test_bit(ATH10K_FW_FEATURE_NO_BMISS_CT, fw_file->fw_features))
+		ar->bmiss_offload_max_vdev = 0;
+
+	/* CT Firmware for 9984 & 9980 recently gained support for configuring the number
+	 * of rate-ctrl objects.  Unfortunately, the old default we were using (10)
+	 * is too large if we are also maxing out 64-vdevs.  So, in order to make
+	 * this more backwards compat, add a hack here.
+	 */
+	if ((ar->fwcfg.vdevs == 64) && (ar->fwcfg.rate_ctrl_objs == 10)
+	    && ((ar->hw_rev == ATH10K_HW_QCA9984) || (ar->hw_rev == ATH10K_HW_QCA99X0))) {
+		ath10k_err(ar, "Detected fwcfg of 64 vdevs and 10 RC for 9980/84, setting to 7 RC objects so firmware will not OOM.\n");
+		ar->num_ratectrl_objs = 7;
 	}
 
 	return 0;
@@ -2520,11 +3143,13 @@
 {
 	int status;
 	u32 val;
+	u32 i, band;
 
 	lockdep_assert_held(&ar->conf_mutex);
 
 	clear_bit(ATH10K_FLAG_CRASH_FLUSH, &ar->dev_flags);
 
+	ar->ok_tx_rate_status = false;
 	ar->running_fw = fw;
 
 	if (!test_bit(ATH10K_FW_FEATURE_NON_BMI,
@@ -2791,6 +3416,163 @@
 		goto err_hif_stop;
 	}
 
+	if (test_bit(ATH10K_FW_FEATURE_HTT_MGT_CT,
+		     ar->running_fw->fw_file.fw_features)) {
+		ar->ct_all_pkts_htt = true;
+	}
+	else if (ar->running_fw->fw_file.wmi_op_version != ATH10K_FW_WMI_OP_VERSION_10_1) {
+		/* Older 10.1 firmware will not have the flag, and we check the HTT version
+		 * in htt_rx.c for it.  But, 10.4 has conflicting HTT version, so disable
+		 * this feature in newer firmware unless it explicitly has the HTT_MGT_CT feature
+		 * flag.
+		 */
+		ar->ct_all_pkts_htt = false;
+	}
+
+	if (test_bit(ATH10K_FW_FEATURE_SET_SPECIAL_CT,
+		     ar->running_fw->fw_file.fw_features)) {
+		/* Apply user-supplied configuration changes. */
+		/* Don't worry about failures..not much we can do, and not worth failing init even
+		 * if this fails.
+		 */
+
+		for (band = 0; band < 2; band++) {
+			u32 val;
+			for (i = 0; i<MIN_CCA_PWR_COUNT; i++) {
+				val = (band << 24) | (i << 16) | ar->eeprom_overrides.bands[band].minCcaPwrCT[i];
+				ath10k_wmi_pdev_set_special(ar, SET_SPECIAL_ID_NOISE_FLR_THRESH, val);
+			}
+
+			i = 4; /* enable-minccapwr-thresh type */
+			val = (band << 24) | (i << 16) | ar->eeprom_overrides.bands[band].enable_minccapwr_thresh;
+			ath10k_wmi_pdev_set_special(ar, SET_SPECIAL_ID_NOISE_FLR_THRESH, val);
+		}
+
+		if (ar->eeprom_overrides.reg_ack_cts) {
+			ath10k_wmi_pdev_set_special(ar, SET_SPECIAL_ID_ACK_CTS,
+						    ar->eeprom_overrides.reg_ack_cts);
+		}
+
+		if (ar->eeprom_overrides.reg_ifs_slot) {
+			ath10k_wmi_pdev_set_special(ar, SET_SPECIAL_ID_SLOT,
+						    ar->eeprom_overrides.reg_ifs_slot);
+		}
+
+		/* TODO:  Should probably be per-band?? */
+		if (ar->eeprom_overrides.thresh62_ext) {
+			ath10k_wmi_pdev_set_special(ar, SET_SPECIAL_ID_THRESH62_EXT,
+						    ar->eeprom_overrides.thresh62_ext);
+		}
+
+		if (ar->eeprom_overrides.allow_ibss_amsdu) {
+			ath10k_wmi_pdev_set_special(ar, SET_SPECIAL_ID_IBSS_AMSDU_OK,
+						    ar->eeprom_overrides.allow_ibss_amsdu);
+		}
+
+		if (ar->eeprom_overrides.tx_hang_cold_reset_ok) {
+			ath10k_wmi_pdev_set_special(ar, SET_SPECIAL_ID_TX_HANG_COLD_RESET,
+						    ar->eeprom_overrides.tx_hang_cold_reset_ok);
+		}
+
+		if (ar->eeprom_overrides.max_txpower != 0xFFFF)
+			ath10k_wmi_pdev_set_special(ar, SET_SPECIAL_ID_MAX_TXPOWER,
+						    ar->eeprom_overrides.max_txpower);
+
+		if (ar->eeprom_overrides.rc_rate_max_per_thr)
+			ath10k_wmi_pdev_set_special(ar, SET_SPECIAL_ID_RC_MAX_PER_THR,
+						    ar->eeprom_overrides.rc_rate_max_per_thr);
+
+		if (ar->eeprom_overrides.tx_sta_bw_mask)
+			ath10k_wmi_pdev_set_special(ar, SET_SPECIAL_ID_STA_TXBW_MASK,
+						    ar->eeprom_overrides.tx_sta_bw_mask);
+
+		if (ar->eeprom_overrides.pdev_xretry_th)
+			ath10k_wmi_pdev_set_special(ar, SET_SPECIAL_ID_PDEV_XRETRY_TH,
+						    ar->eeprom_overrides.pdev_xretry_th);
+
+		if (ar->eeprom_overrides.rifs_enable_override)
+			ath10k_wmi_pdev_set_special(ar, SET_SPECIAL_ID_RIFS_ENABLE,
+						    ar->eeprom_overrides.rifs_enable_override);
+		if (ar->eeprom_overrides.wmi_wd_keepalive_ms)
+			ath10k_wmi_pdev_set_special(ar, SET_SPECIAL_ID_WMI_WD,
+						    ar->eeprom_overrides.wmi_wd_keepalive_ms);
+		if (ar->eeprom_overrides.ct_pshack)
+			ath10k_wmi_pdev_set_special(ar, SET_SPECIAL_ID_PSHACK,
+						    ar->eeprom_overrides.ct_pshack);
+		if (ar->eeprom_overrides.ct_csi)
+			ath10k_wmi_pdev_set_special(ar, SET_SPECIAL_ID_CSI,
+						    ar->eeprom_overrides.ct_csi);
+		if (ar->eeprom_overrides.rate_bw_disable_mask)
+			ath10k_wmi_pdev_set_special(ar, SET_SPECIAL_ID_BW_DISABLE_MASK,
+						    ar->eeprom_overrides.rate_bw_disable_mask);
+		if (ar->eeprom_overrides.txbf_cv_msg)
+			ath10k_wmi_pdev_set_special(ar, SET_SPECIAL_ID_TXBF_CV_MSG,
+						    ar->eeprom_overrides.txbf_cv_msg);
+		if (ar->eeprom_overrides.rx_all_mgt)
+			ath10k_wmi_pdev_set_special(ar, SET_SPECIAL_ID_RX_ALL_MGT,
+						    ar->eeprom_overrides.rx_all_mgt);
+		if (ar->eeprom_overrides.rc_debug)
+			ath10k_wmi_pdev_set_special(ar, SET_SPECIAL_ID_RC_DBG,
+						    ar->eeprom_overrides.rc_debug);
+		if (ar->eeprom_overrides.tx_debug)
+			ath10k_wmi_pdev_set_special(ar, SET_SPECIAL_ID_TX_DBG,
+						    ar->eeprom_overrides.tx_debug);
+
+		if (ar->eeprom_overrides.disable_ibss_cca)
+			ath10k_wmi_pdev_set_special(ar, SET_SPECIAL_ID_DISABLE_IBSS_CCA,
+						    ar->eeprom_overrides.disable_ibss_cca);
+
+		if (ar->eeprom_overrides.peer_stats_pn)
+			ath10k_wmi_pdev_set_special(ar, SET_SPECIAL_ID_PEER_STATS_PN,
+						    ar->eeprom_overrides.peer_stats_pn);
+
+		if (ar->eeprom_overrides.su_sounding_timer_ms)
+			ath10k_wmi_pdev_set_param(ar, ar->wmi.pdev_param->txbf_sound_period_cmdid,
+						  ar->eeprom_overrides.su_sounding_timer_ms);
+
+		/* See WMI_FWTEST_CMDID in wlan_dev.c in firmware for these hard-coded values. */
+		/* Set default MU sounding period. */
+		if (ar->eeprom_overrides.mu_sounding_timer_ms)
+			ath10k_wmi_pdev_set_fwtest(ar, 81,
+						   ar->eeprom_overrides.mu_sounding_timer_ms);
+
+		if (ar->eeprom_overrides.rc_txbf_probe)
+			ath10k_wmi_pdev_set_fwtest(ar, 20,
+						   ar->eeprom_overrides.rc_txbf_probe);
+
+		for (i = 0; i<ARRAY_SIZE(ar->eeprom_configAddrs); ) {
+			if (ar->eeprom_configAddrs[i]) {
+				#define CONFIG_ADDR_MODE_SHIFT 20
+				int mode = (ar->eeprom_configAddrs[i] >> CONFIG_ADDR_MODE_SHIFT) & 0x3;
+				int count = 1; /* one value applied to both 2G and 5G modes */
+				int q;
+
+				if (mode == 2) /* 2G, 5G value tuple */
+					count = 2;
+				else if (mode == 3) /* 2G_VHT20, 2G_VHT40, 5G_VHT20, 5G_VHT40, 5G_VHT80/160/80+80 */
+					count = 5;
+				ath10k_dbg(ar, ATH10K_DBG_BOOT, "Applying eeprom configAddr[%i]: mode: %d count: %d 0x%08x 0x%08x 0x%08x\n",
+					   i, mode, count, ar->eeprom_configAddrs[i], ar->eeprom_configAddrs[i+1],
+					   (count >= 2) ? ar->eeprom_configAddrs[i+2] : 0);
+
+				ath10k_wmi_pdev_set_special(ar, SET_SPECIAL_ID_EEPROM_CFG_ADDR_A,
+							    ar->eeprom_configAddrs[i]);
+				for (q = 0; q<count; q++) {
+					ath10k_wmi_pdev_set_special(ar, SET_SPECIAL_ID_EEPROM_CFG_ADDR_V,
+								    ar->eeprom_configAddrs[i + q + 1]);
+				}
+
+				i += (count + 1);
+			}
+			else {
+				break;
+			}
+		}
+
+		if (ar->eeprom_overrides.apply_board_power_ctl_table)
+			ath10k_wmi_check_apply_board_power_ctl_table(ar);
+	}
+
 	return 0;
 
 err_hif_stop:
@@ -3074,10 +3856,34 @@
 
 	queue_work(ar->workqueue, &ar->register_work);
 
+#ifdef STANDALONE_CT
+	/* Assume we are compiling for LEDE/OpenWRT if this define is set. --Ben */
+
+	/* OpenWrt requires all PHYs to be initialized to create the
+	 * configuration files during bootup. ath10k violates this
+	 * because it delays the creation of the PHY to a not well defined
+	 * point in the future.
+	 *
+	 * Forcing the work to be done immediately works around this problem
+	 * but may also delay the boot when firmware images cannot be found.
+	 */
+	flush_workqueue(ar->workqueue);
+#endif
+
 	return 0;
 }
 EXPORT_SYMBOL(ath10k_core_register);
 
+void ath10k_core_free_limits(struct ath10k* ar)
+{
+	int i;
+	for (i = 0; i < ARRAY_SIZE(ar->if_comb); i++) {
+		kfree(ar->if_comb[i].limits);
+	}
+	memset(&ar->if_comb, 0, sizeof(ar->if_comb));
+}
+EXPORT_SYMBOL(ath10k_core_free_limits);
+
 void ath10k_core_unregister(struct ath10k *ar)
 {
 	cancel_work_sync(&ar->register_work);
@@ -3103,6 +3909,8 @@
 	ath10k_core_free_firmware_files(ar);
 	ath10k_core_free_board_files(ar);
 
+	ath10k_core_free_limits(ar);
+
 	ath10k_debug_unregister(ar);
 }
 EXPORT_SYMBOL(ath10k_core_unregister);
@@ -3119,6 +3927,9 @@
 	if (!ar)
 		return NULL;
 
+	ar->eeprom_overrides.max_txpower = 0xFFFF;
+	ar->sta_xretry_kickout_thresh = DEFAULT_ATH10K_KICKOUT_THRESHOLD;
+
 	ar->ath_common.priv = ar;
 	ar->ath_common.hw = ar->hw;
 	ar->dev = dev;
@@ -3211,6 +4022,7 @@
 	INIT_WORK(&ar->restart_work, ath10k_core_restart);
 	INIT_WORK(&ar->set_coverage_class_work,
 		  ath10k_core_set_coverage_class_work);
+	INIT_WORK(&ar->stop_scan_work, ath10k_wmi_stop_scan_work);
 
 	init_dummy_netdev(&ar->napi_dev);
 
diff -Nur linux-5.4.39/drivers/net/wireless/ath/ath10k/core.h linux-5.4.39-ct/drivers/net/wireless/ath/ath10k/core.h
--- linux-5.4.39/drivers/net/wireless/ath/ath10k/core.h	2020-05-06 07:15:17.000000000 +0100
+++ linux-5.4.39-ct/drivers/net/wireless/ath/ath10k/core.h	2020-05-12 23:23:34.000000000 +0100
@@ -43,12 +43,18 @@
 /* Antenna noise floor */
 #define ATH10K_DEFAULT_NOISE_FLOOR -95
 
+#define ATH10K_CT_TX_BEACON_INVALID_RATE_CODE 0xff
 #define ATH10K_INVALID_RSSI 128
 
-#define ATH10K_MAX_NUM_MGMT_PENDING 128
+/* This used to be 128, but klukonin reports increasing this helps in at least
+ * some cases.  I think at worst this could increase mem usage and mgt traffic
+ * latency, but maybe that is worth the tradeoff.  Increasing to 512 per his suggestion.
+ * --Ben
+ */
+#define ATH10K_MAX_NUM_MGMT_PENDING 512
 
 /* number of failed packets (20 packets with 16 sw reties each) */
-#define ATH10K_KICKOUT_THRESHOLD (20 * 16)
+#define DEFAULT_ATH10K_KICKOUT_THRESHOLD (20 * 16)
 
 /*
  * Use insanely high numbers to make sure that the firmware implementation
@@ -82,6 +88,9 @@
 /* Default Airtime weight multipler (Tuned for multiclient performance) */
 #define ATH10K_AIRTIME_WEIGHT_MULTIPLIER  4
 
+// TODO-BEN:  Remove this and fix all instances of vif_to_arvif.
+#define ath10k_vif_to_arvif(a) (void*)(a->drv_priv)
+
 struct ath10k;
 
 static inline const char *ath10k_bus_str(enum ath10k_bus bus)
@@ -180,6 +189,10 @@
 	u32 num_mem_chunks;
 	u32 rx_decap_mode;
 	struct ath10k_mem_chunk mem_chunks[WMI_MAX_MEM_REQS];
+
+	int gen_buf_len; /* so far */
+	u8 gen_buffer[2048]; /* Not clear what is true max size */
+	struct wmi_generic_buffer_event last_generic_event;
 };
 
 struct ath10k_fw_stats_peer {
@@ -190,6 +203,7 @@
 	u32 peer_tx_rate;
 	u32 peer_rx_rate; /* 10x only */
 	u64 rx_duration;
+	u64 pn; /* CT Wave-2 FW Only, special restrictions apply */
 };
 
 struct ath10k_fw_extd_stats_peer {
@@ -216,6 +230,8 @@
 	u32 num_tx_not_acked;
 	u32 tx_rate_history[10];
 	u32 beacon_rssi_history[10];
+
+	u64 tsf64; /* ct fw only */
 };
 
 struct ath10k_fw_stats_vdev_extd {
@@ -308,6 +324,12 @@
 	s32 phy_err_drop;
 	s32 mpdu_errs;
 	s32 rx_ovfl_errs;
+	s32 rx_timeout_errs;
+
+	/* Other PDEV stats */
+	s32 dram_free;
+	s32 iram_free;
+	s32 sram_free;
 };
 
 struct ath10k_fw_stats {
@@ -316,6 +338,39 @@
 	struct list_head vdevs;
 	struct list_head peers;
 	struct list_head peers_extd;
+
+	/* Register and related dump, CT firmware only. */
+	int extras_count; /* How many extras do we have assigned? */
+	u32 mac_filter_addr_l32;
+	u32 mac_filter_addr_u16;
+	u32 dcu_slot_time;
+	u32 phy_bb_mode_select;
+	u32 pcu_bssid_l32;
+	u32 pcu_bssid_u16;
+	u32 pcu_bssid2_l32;
+	u32 pcu_bssid2_u16;
+	u32 pcu_sta_addr_l32;
+	u32 pcu_sta_addr_u16;
+	u32 mac_dma_cfg;
+	u32 mac_dma_txcfg;
+	u32 pcu_rxfilter;
+	u32 phy_bb_gen_controls;
+	u32 dma_imr;
+	u32 dma_txrx_imr;
+	u32 sw_powermode;
+	u16 sw_chainmask_tx;
+	u16 sw_chainmask_rx;
+	u32 sw_opmode;
+	u32 sw_rxfilter;
+	u32 short_retries; // RTS packet retries
+	u32 long_retries; // Data packet retries
+	u32 adc_temp; /* ADC Temperature readings, one octet for each chain.
+		       * Value of 0x78 for 2,3 means not-read/not-active,
+		       * and 0x7B for 0,1 mean means the same.
+		       */
+	u32 nfcal; /* per-chain noise-floor calibration, signed 8 bit nums
+		    * packed into u32 */
+	u32 extra_regs[20]; /* for forward-compat */
 };
 
 #define ATH10K_TPC_TABLE_TYPE_FLAG	1
@@ -525,6 +580,7 @@
 
 struct ath10k_vif {
 	struct list_head list;
+	struct completion beacon_tx_done;
 
 	u32 vdev_id;
 	u16 peer_id;
@@ -572,10 +628,32 @@
 	} u;
 
 	bool use_cts_prot;
-	bool nohwcrypt;
+	bool nohwcrypt; /* actual setting, based on firmware abilities, etc. */
 	int num_legacy_stations;
 	int txpower;
 	bool ftm_responder;
+
+	/* TX Rate overrides, CT FW only at this time, and only wave-2 has full support */
+	bool txo_active;
+	u8 txo_tpc;
+	u8 txo_sgi;
+	u8 txo_mcs;
+	u8 txo_nss;
+	u8 txo_pream;
+	u8 txo_retries;
+	u8 txo_dynbw;
+	u8 txo_bw;
+	u8 txo_rix; /* wave-1 only */
+
+	/* Firmware allows configuring rate of each of these traffic types.
+	 * 0xFF will mean value has not been set by user, and in that case,
+	 * we will auto-adjust the rates based on the legacy rate mask.
+	 **/
+	/* TODO-BEN:  This may conflict with upstream code? */
+	u8 mcast_rate[NUM_NL80211_BANDS];
+	u8 bcast_rate[NUM_NL80211_BANDS];
+	u8 mgt_rate[NUM_NL80211_BANDS];
+
 	struct wmi_wmm_params_all_arg wmm_params;
 	struct work_struct ap_csa_work;
 	struct delayed_work connection_loss_work;
@@ -608,6 +686,26 @@
 
 #define MAX_MEM_DUMP_TYPE	5
 
+/* This will store at least the last 128 entries.  Each dbglog message
+ * is a max of 7 32-bit integers in length, but the length can be less
+ * than that as well.
+ */
+#define ATH10K_DBGLOG_DATA_LEN (128 * 7)
+struct ath10k_dbglog_entry_storage {
+	u32 head_idx; /* Where to write next chunk of data */
+	u32 tail_idx; /* Index of first msg */
+	__le32 data[ATH10K_DBGLOG_DATA_LEN];
+};
+
+/* Just enough info to decode firmware debug-log argument length */
+#define DBGLOG_NUM_ARGS_OFFSET           26
+#define DBGLOG_NUM_ARGS_MASK             0xFC000000 /* Bit 26-31 */
+#define DBGLOG_NUM_ARGS_MAX              5 /* firmware tool chain limit */
+
+/* estimated values, hopefully these are enough */
+#define ATH10K_ROM_BSS_BUF_LEN 30000
+#define ATH10K_RAM_BSS_BUF_LEN 55000
+
 /* used for crash-dump storage, protected by data-lock */
 struct ath10k_fw_crash_data {
 	guid_t guid;
@@ -617,11 +715,20 @@
 
 	u8 *ramdump_buf;
 	size_t ramdump_buf_len;
+	__le32 stack_buf[ATH10K_FW_STACK_SIZE / sizeof(__le32)];
+	__le32 exc_stack_buf[ATH10K_FW_STACK_SIZE / sizeof(__le32)];
+	__le32 stack_addr;
+	__le32 exc_stack_addr;
+	__le32 rom_bss_buf[ATH10K_ROM_BSS_BUF_LEN / sizeof(__le32)];
+	__le32 ram_bss_buf[ATH10K_RAM_BSS_BUF_LEN / sizeof(__le32)];
 };
 
 struct ath10k_debug {
 	struct dentry *debugfs_phy;
 
+	struct ath10k_rx_reorder_stats rx_reorder_stats;
+	struct ath10k_pdev_ext_stats_ct pdev_ext_stats;
+	s32 nf_sum[4]; /* sum of all chains, reported by pdev_ext_stats */
 	struct ath10k_fw_stats fw_stats;
 	struct completion fw_stats_complete;
 	bool fw_stats_done;
@@ -629,6 +736,7 @@
 	unsigned long htt_stats_mask;
 	unsigned long reset_htt_stats;
 	struct delayed_work htt_stats_dwork;
+	struct delayed_work nop_dwork;
 	struct ath10k_dfs_stats dfs_stats;
 	struct ath_dfs_pool_stats dfs_pool_stats;
 
@@ -646,6 +754,33 @@
 	void *cal_data;
 	u32 enable_extd_tx_stats;
 	u8 fw_dbglog_mode;
+	u32 nop_id;
+
+	struct ath10k_dbglog_entry_storage dbglog_entry_data;
+
+	/* These counters are kept in software. */
+	u64 rx_bytes; /* counter, total received bytes */
+	u32 rx_drop_unchain_oom; /* AMSDU Dropped due to un-chain OOM case */
+	u32 rx_drop_decap_non_raw_chained;
+	u32 rx_drop_no_freq;
+	u32 rx_drop_cac_running;
+
+	u32 tx_ok; /* counter, OK tx status count. */
+	u32 tx_noack; /* counter, no-ack tx status count. */
+	u32 tx_discard; /* counter, discard tx status count. */
+	u64 tx_ok_bytes;
+	u64 tx_noack_bytes;
+	u64 tx_discard_bytes;
+	u64 tx_bytes; /* counter, total sent to firmware */
+	char dfs_last_msg[120];
+
+	int ratepwr_tbl_len;
+	struct qc988xxEepromRateTbl ratepwr_tbl;
+	struct completion ratepwr_tbl_complete;
+
+	int powerctl_tbl_len;
+	struct qca9880_power_ctrl powerctl_tbl;
+	struct completion powerctl_tbl_complete;
 };
 
 enum ath10k_state {
@@ -779,6 +914,90 @@
 	/* Firmware allows setting peer fixed rate */
 	ATH10K_FW_FEATURE_PEER_FIXED_RATE = 21,
 
+	/* tx-status has the noack bits (CT firmware version 14 and higher ) */
+	ATH10K_FW_FEATURE_HAS_TXSTATUS_NOACK = 30,
+
+	/* Firmware from Candela Technologies, enables more VIFs, etc */
+	ATH10K_FW_FEATURE_WMI_10X_CT = 31,
+
+	/* Firmware from Candela Technologies with rx-software-crypt.
+	 * Required for multiple stations connected to same AP when using
+	 * encryption (ie, commercial version of CT firmware) */
+	ATH10K_FW_FEATURE_CT_RXSWCRYPT = 32,
+
+	/* Firmware supports extended wmi_common_peer_assoc_complete_cmd that contains
+	 * an array of rate-disable masks.  This allows the host to have better control
+	 * over what rates the firmware will use.  CT Firmware only (v15 and higher)
+	 */
+	ATH10K_FW_FEATURE_CT_RATEMASK = 33,
+
+	/* Versions of firmware before approximately 10.2.4.72 would corrupt txop fields
+	 * during burst.  Since this is fixed now, add a flag to denote this.
+	 */
+	ATH10K_FW_FEATURE_HAS_SAFE_BURST = 34,
+
+	/* Register-dump is supported. */
+	ATH10K_FW_FEATURE_REGDUMP_CT = 35,
+
+	/* TX-Rate is reported. */
+	ATH10K_FW_FEATURE_TXRATE_CT = 36,
+
+	/* Firmware can flush all peers. */
+	ATH10K_FW_FEATURE_FLUSH_ALL_CT = 37,
+
+	/* Firmware can read memory with ping-pong protocol. */
+	ATH10K_FW_FEATURE_PINGPONG_READ_CT = 38,
+
+	/* Firmware can skip channel reservation. */
+	ATH10K_FW_FEATURE_SKIP_CH_RES_CT = 39,
+
+	/* Firmware supports NOPcan skip channel reservation. */
+	ATH10K_FW_FEATURE_NOP_CT = 40,
+
+	/* Firmware supports CT HTT MGT feature. */
+	ATH10K_FW_FEATURE_HTT_MGT_CT = 41,
+
+	/* Set-special cmd-id is supported. */
+	ATH10K_FW_FEATURE_SET_SPECIAL_CT = 42,
+
+	/* SW Beacon Miss is disabled in this kernel, so you have to
+	 * let mac80211 manage the connection.
+	 */
+	ATH10K_FW_FEATURE_NO_BMISS_CT = 43,
+
+	/* 10.1 firmware that supports getting temperature.  Stock
+	 * 10.1 cannot.
+	 */
+	ATH10K_FW_FEATURE_HAS_GET_TEMP_CT = 44,
+
+	/* Can peer-id be over-ridden to provide rix + retries for raw pkts?
+	 *  CT only option.
+	 */
+	ATH10K_FW_FEATURE_HAS_TX_RC_CT = 45,
+
+	/* Do we support requesting custom stats */
+	ATH10K_FW_FEATURE_CUST_STATS_CT = 46,
+
+	/* Can the firmware handle a retry limit greater than 2? */
+	ATH10K_FW_FEATURE_RETRY_GT2_CT = 47,
+
+	/* Can the firmware handle CT station feature, sort of like proxy-sta */
+	ATH10K_FW_FEATURE_CT_STA = 48,
+
+	/* TX-Rate v2 is reported. */
+	ATH10K_FW_FEATURE_TXRATE2_CT = 49,
+
+	/* Firmware will send a beacon-tx-callback message so driver knows when
+	 * beacon buffer can be released.
+	 */
+	ATH10K_FW_FEATURE_BEACON_TX_CB_CT = 50,
+
+	ATH10K_FW_FEATURE_RESERVED_CT = 51, /* reserved by out-of-tree feature */
+
+	ATH10K_FW_FEATURE_CONSUME_BLOCK_ACK_CT = 52, /* firmware can accept decrypted rx block-ack over WMI */
+
+	ATH10K_FW_FEATURE_HAS_BCN_RC_CT = 53, /* firmware can accept ppdu (tx-rate) info in beacon-tx-by-ref wmi cmd */
+
 	/* keep last */
 	ATH10K_FW_FEATURE_COUNT,
 };
@@ -875,6 +1094,8 @@
 
 struct ath10k_fw_file {
 	const struct firmware *firmware;
+	char fw_name[100];
+	char fw_board_name[100];
 
 	char fw_version[ETHTOOL_FWVERS_LEN];
 
@@ -892,6 +1113,14 @@
 	const void *codeswap_data;
 	size_t codeswap_len;
 
+	/* These are written to only during first firmware load from user
+	 * space so no need for any locking.
+	 */
+	u32 ram_bss_addr;
+	u32 ram_bss_len;
+	u32 rom_bss_addr;
+	u32 rom_bss_len;
+
 	/* The original idea of struct ath10k_fw_file was that it only
 	 * contains struct firmware and pointers to various parts (actual
 	 * firmware binary, otp, metadata etc) of the file. This seg_info
@@ -947,12 +1176,17 @@
 	struct device *dev;
 	u8 mac_addr[ETH_ALEN];
 
+	struct ieee80211_iface_combination if_comb[8];
+
 	enum ath10k_hw_rev hw_rev;
 	u16 dev_id;
+	bool ok_tx_rate_status; /* Firmware is sending tx-rate status?  (CT only) */
+	bool fw_powerup_failed; /* If true, might take reboot to recover. */
 	u32 chip_id;
 	enum ath10k_dev_type dev_type;
 	u32 target_version;
 	u8 fw_version_major;
+	bool use_swcrypt; /* Firmware (and driver) supports rx-sw-crypt? */
 	u32 fw_version_minor;
 	u16 fw_version_release;
 	u16 fw_version_build;
@@ -974,7 +1208,9 @@
 
 	bool nlo_enabled;
 	bool p2p;
+	bool ct_all_pkts_htt; /* CT firmware only: native-wifi for all pkts */
 
+	bool hif_running; /* Should we be processing IRQs or not? */
 	struct {
 		enum ath10k_bus bus;
 		const struct ath10k_hif_ops *ops;
@@ -1004,6 +1240,52 @@
 	const struct firmware *pre_cal_file;
 	const struct firmware *cal_file;
 
+	const struct firmware *fwcfg_file;
+	struct {
+#define ATH10K_FWCFG_FWVER          (1<<0)
+#define ATH10K_FWCFG_VDEVS          (1<<1)
+#define ATH10K_FWCFG_PEERS          (1<<2)
+#define ATH10K_FWCFG_STATIONS       (1<<3)
+#define ATH10K_FWCFG_NOHWCRYPT      (1<<4)
+#define ATH10K_FWCFG_RATE_CTRL_OBJS (1<<5)
+#define ATH10K_FWCFG_TX_DESC        (1<<6)
+#define ATH10K_FWCFG_MAX_NSS        (1<<7)
+#define ATH10K_FWCFG_NUM_TIDS       (1<<8)
+#define ATH10K_FWCFG_ACTIVE_PEERS   (1<<9)
+#define ATH10K_FWCFG_SKID_LIMIT     (1<<10)
+#define ATH10K_FWCFG_REGDOM         (1<<11)
+#define ATH10K_FWCFG_BMISS_VDEVS    (1<<12)
+#define ATH10K_FWCFG_MAX_AMSDUS     (1<<13)
+#define ATH10K_FWCFG_NOBEAMFORM_MU  (1<<14)
+#define ATH10K_FWCFG_NOBEAMFORM_SU  (1<<15)
+#define ATH10K_FWCFG_CT_STA         (1<<16)
+#define ATH10K_FWCFG_ALLOW_ALL_MCS  (1<<17)
+
+		u32 flags; /* let us know which fields have been set */
+		char calname[100];
+		char fwname[100];
+		char bname[100]; /* board file name */
+		char bname_ext[100]; /* extended board file name */
+		u32 fwver;
+		u32 vdevs;
+		u32 stations;
+		u32 peers;
+		u32 nohwcrypt;
+		u32 ct_sta_mode;
+		u32 nobeamform_mu;
+		u32 nobeamform_su;
+		u32 rate_ctrl_objs;
+		u32 tx_desc; /* max_num_pending_tx descriptors */
+		u32 max_nss; /* max_spatial_stream */
+		u32 num_tids;
+		u32 active_peers;
+		u32 skid_limit;
+		int regdom;
+		u32 bmiss_vdevs; /* To disable, set to 0 */
+		u32 max_amsdus;
+		u32 allow_all_mcs;
+	} fwcfg;
+
 	struct {
 		u32 vendor;
 		u32 device;
@@ -1061,10 +1343,12 @@
 	unsigned int filter_flags;
 	unsigned long dev_flags;
 	bool dfs_block_radar_events;
+	int install_key_rv; /* Store error code from key-install */
 
 	/* protected by conf_mutex */
 	bool radar_enabled;
 	int num_started_vdevs;
+	u32 sta_xretry_kickout_thresh;
 
 	/* Protected by conf-mutex */
 	u8 cfg_tx_chainmask;
@@ -1104,6 +1388,15 @@
 	int max_num_tdls_vdevs;
 	int num_active_peers;
 	int num_tids;
+	bool request_ct_sta;    /* desired setting */
+	bool request_nohwcrypt; /* desired setting */
+	bool request_nobeamform_mu;
+	bool request_nobeamform_su;
+	u32 num_ratectrl_objs;
+	u32 skid_limit;
+	u32 bmiss_offload_max_vdev;
+	int eeprom_regdom;
+	bool eeprom_regdom_warned;
 
 	struct work_struct svc_rdy_work;
 	struct sk_buff *svc_rdy_skb;
@@ -1141,6 +1434,10 @@
 
 	unsigned long tx_paused; /* see ATH10K_TX_PAUSE_ */
 
+	u32 last_wmi_cmds[4];
+	u32 last_wmi_jiffies[4];
+	u32 last_wmi_cmd_idx;
+
 #ifdef CONFIG_ATH10K_DEBUGFS
 	struct ath10k_debug debug;
 	struct {
@@ -1152,6 +1449,9 @@
 		struct ath10k_spec_scan config;
 	} spectral;
 #endif
+	u32 wmi_get_temp_count;
+
+	u32 eeprom_configAddrs[24]; /* Store sticky eeprom register settings to re-apply after OTP */
 
 	u32 pktlog_filter;
 
@@ -1183,6 +1483,9 @@
 	/* NAPI */
 	struct net_device napi_dev;
 	struct napi_struct napi;
+	bool napi_enabled;
+
+	struct work_struct stop_scan_work;
 
 	struct work_struct set_coverage_class_work;
 	/* protected by conf_mutex */
@@ -1211,6 +1514,58 @@
 	struct ath10k_bus_params bus_param;
 	struct completion peer_delete_done;
 
+	/* Index 0 is for 5Ghz, index 1 is for 2.4Ghz, CT firmware only. */
+	/* be sure to flush this to firmware after resets */
+	/* Includes various other backdoor hacks as well. */
+	struct {
+		struct {
+#define MIN_CCA_PWR_COUNT 3
+			u16 minCcaPwrCT[MIN_CCA_PWR_COUNT]; /* 0 means don't-set */
+			u8 noiseFloorThresh; /* 0 means don't-set */
+			/* Have to set this to 2 before minCcaPwr settings will be active.
+			 * Values:  0  don't-set, 1 disable, 2 enable
+			 */
+			u8 enable_minccapwr_thresh;
+		} bands[2];
+		u8 thresh62_ext;
+		u8 rc_rate_max_per_thr; /* Firmware rate-ctrl alg. tuning. */
+		u8 tx_sta_bw_mask; /* 0:  all, 0x1: 20Mhz, 0x2 40Mhz, 0x4 80Mhz */
+		bool tx_hang_cold_reset_ok;
+		bool allow_ibss_amsdu;
+		bool rifs_enable_override;
+		bool coverage_already_set;
+		bool txbf_cv_msg;
+		bool rx_all_mgt;
+		bool apply_board_power_ctl_table;
+		u8 disable_ibss_cca;
+		u8 peer_stats_pn;
+		u8 rc_txbf_probe;
+#define CT_DISABLE_20MHZ  0x1
+#define CT_DISABLE_40MHZ  0x2
+#define CT_DISABLE_80MHZ  0x4
+#define CT_DISABLE_160MHZ 0x8
+		u16 rate_bw_disable_mask;
+		u16 max_txpower;
+		u16 pdev_xretry_th; /* Max failed retries before wifi chip is reset, 10.1 firmware default is 0x40 */
+		u16 tx_debug;
+		u16 rc_debug;
+		u32 wmi_wd_keepalive_ms; /* 0xFFFFFFFF means disable, otherwise, FW will assert after X ms of not receiving
+					  * a NOP keepalive from the driver.  Suggested value is 0xFFFFFFFF, or 8000+.
+					  * 0 means use whatever firmware defaults to (probably 8000).
+					  * Units are actually 1/1024 of a second, but pretty close to ms, at least.
+					  */
+		u32 ct_pshack;
+		u32 ct_csi;
+		u32 reg_ack_cts;
+		u32 reg_ifs_slot;
+		u32 mu_sounding_timer_ms;
+		u32 su_sounding_timer_ms;
+	} eeprom_overrides;
+
+	/* CSI report accumulator. */
+	u8 csi_data[4096];
+	u16 csi_data_len;
+
 	/* must be last */
 	u8 drv_priv[0] __aligned(sizeof(void *));
 };
@@ -1246,5 +1601,9 @@
 void ath10k_core_unregister(struct ath10k *ar);
 int ath10k_core_fetch_board_file(struct ath10k *ar, int bd_ie_type);
 void ath10k_core_free_board_files(struct ath10k *ar);
+void ath10k_core_free_limits(struct ath10k* ar);
+
+int ath10k_sum_sigs_2(int a, int b);
+int ath10k_sum_sigs(int p20, int e20, int e40, int e80);
 
 #endif /* _CORE_H_ */
diff -Nur linux-5.4.39/drivers/net/wireless/ath/ath10k/coredump.c linux-5.4.39-ct/drivers/net/wireless/ath/ath10k/coredump.c
--- linux-5.4.39/drivers/net/wireless/ath/ath10k/coredump.c	2020-05-06 07:15:17.000000000 +0100
+++ linux-5.4.39-ct/drivers/net/wireless/ath/ath10k/coredump.c	2020-05-12 23:23:34.000000000 +0100
@@ -1121,9 +1121,16 @@
 	struct ath10k_ce_crash_hdr *ce_hdr;
 	struct ath10k_dump_file_data *dump_data;
 	struct ath10k_tlv_dump_data *dump_tlv;
+#ifdef CONFIG_ATH10K_DEBUGFS
+	struct ath10k_dbglog_entry_storage_user *dbglog_storage;
+#endif
 	size_t hdr_len = sizeof(*dump_data);
 	size_t len, sofar = 0;
 	unsigned char *buf;
+	int tmp;
+
+	BUILD_BUG_ON(sizeof(struct ath10k_dbglog_entry_storage) !=
+		     sizeof(struct ath10k_dbglog_entry_storage_user));
 
 	len = hdr_len;
 
@@ -1137,6 +1144,20 @@
 	if (test_bit(ATH10K_FW_CRASH_DUMP_RAM_DATA, &ath10k_coredump_mask))
 		len += sizeof(*dump_tlv) + crash_data->ramdump_buf_len;
 
+#ifdef CONFIG_ATH10K_DEBUGFS
+	len += sizeof(*dump_tlv) + sizeof(ar->debug.dbglog_entry_data);
+#endif
+	len += sizeof(*dump_tlv) + sizeof(crash_data->stack_buf);
+	len += sizeof(*dump_tlv) + sizeof(crash_data->exc_stack_buf);
+
+	if (ar->running_fw->fw_file.ram_bss_addr &&
+	    ar->running_fw->fw_file.ram_bss_len)
+		len += sizeof(*dump_tlv) + ar->running_fw->fw_file.ram_bss_len;
+
+	if (ar->running_fw->fw_file.rom_bss_addr &&
+	    ar->running_fw->fw_file.rom_bss_len)
+		len += sizeof(*dump_tlv) + ar->running_fw->fw_file.rom_bss_len;
+
 	sofar += hdr_len;
 
 	/* This is going to get big when we start dumping FW RAM and such,
@@ -1169,6 +1190,12 @@
 	dump_data->ht_cap_info = cpu_to_le32(ar->ht_cap_info);
 	dump_data->vht_cap_info = cpu_to_le32(ar->vht_cap_info);
 	dump_data->num_rf_chains = cpu_to_le32(ar->num_rf_chains);
+	dump_data->stack_addr = cpu_to_le32(crash_data->stack_addr);
+	dump_data->exc_stack_addr = cpu_to_le32(crash_data->exc_stack_addr);
+	dump_data->rom_bss_addr =
+		cpu_to_le32(ar->running_fw->fw_file.rom_bss_addr);
+	dump_data->ram_bss_addr =
+		cpu_to_le32(ar->running_fw->fw_file.ram_bss_addr);
 
 	strlcpy(dump_data->fw_ver, ar->hw->wiphy->fw_version,
 		sizeof(dump_data->fw_ver));
@@ -1215,6 +1242,63 @@
 		}
 	}
 
+#ifdef CONFIG_ATH10K_DEBUGFS
+	/* Gather dbg-log */
+	tmp = sizeof(ar->debug.dbglog_entry_data);
+	dump_tlv = (struct ath10k_tlv_dump_data *)(buf + sofar);
+	dump_tlv->type = cpu_to_le32(ATH10K_FW_CRASH_DUMP_DBGLOG);
+	dump_tlv->tlv_len = cpu_to_le32(tmp);
+	dbglog_storage =
+		(struct ath10k_dbglog_entry_storage_user *)(dump_tlv->tlv_data);
+	memcpy(dbglog_storage->data, ar->debug.dbglog_entry_data.data,
+	       sizeof(dbglog_storage->data));
+	dbglog_storage->head_idx =
+		cpu_to_le32(ar->debug.dbglog_entry_data.head_idx);
+	dbglog_storage->tail_idx =
+		cpu_to_le32(ar->debug.dbglog_entry_data.tail_idx);
+	sofar += sizeof(*dump_tlv) + tmp;
+#endif
+
+	/* Gather firmware stack dump */
+	tmp = sizeof(crash_data->stack_buf);
+	dump_tlv = (struct ath10k_tlv_dump_data *)(buf + sofar);
+	dump_tlv->type = cpu_to_le32(ATH10K_FW_CRASH_DUMP_STACK);
+	dump_tlv->tlv_len = cpu_to_le32(tmp);
+	memcpy(dump_tlv->tlv_data, crash_data->stack_buf, tmp);
+	sofar += sizeof(*dump_tlv) + tmp;
+
+	/* Gather firmware exception stack dump */
+	tmp = sizeof(crash_data->exc_stack_buf);
+	dump_tlv = (struct ath10k_tlv_dump_data *)(buf + sofar);
+	dump_tlv->type = cpu_to_le32(ATH10K_FW_CRASH_DUMP_EXC_STACK);
+	dump_tlv->tlv_len = cpu_to_le32(tmp);
+	memcpy(dump_tlv->tlv_data, crash_data->exc_stack_buf, tmp);
+
+	sofar += sizeof(*dump_tlv) + tmp;
+
+	if (ar->running_fw->fw_file.ram_bss_addr &&
+	    ar->running_fw->fw_file.ram_bss_len) {
+		tmp = ar->running_fw->fw_file.ram_bss_len;
+		dump_tlv = (struct ath10k_tlv_dump_data *)(buf + sofar);
+		dump_tlv->type = cpu_to_le32(ATH10K_FW_CRASH_DUMP_RAM_BSS);
+		dump_tlv->tlv_len = cpu_to_le32(tmp);
+		memcpy(dump_tlv->tlv_data, crash_data->ram_bss_buf, tmp);
+		sofar += sizeof(*dump_tlv) + tmp;
+	}
+
+	if (ar->running_fw->fw_file.rom_bss_addr &&
+	    ar->running_fw->fw_file.rom_bss_len) {
+		tmp = ar->running_fw->fw_file.rom_bss_len;
+		dump_tlv = (struct ath10k_tlv_dump_data *)(buf + sofar);
+		dump_tlv->type = cpu_to_le32(ATH10K_FW_CRASH_DUMP_ROM_BSS);
+		dump_tlv->tlv_len = cpu_to_le32(tmp);
+		memcpy(dump_tlv->tlv_data, crash_data->rom_bss_buf, tmp);
+		sofar += sizeof(*dump_tlv) + tmp;
+	}
+
+	WARN_ON(sofar != len);
+
+
 	mutex_unlock(&ar->dump_mutex);
 
 	return dump_data;
diff -Nur linux-5.4.39/drivers/net/wireless/ath/ath10k/coredump.h linux-5.4.39-ct/drivers/net/wireless/ath/ath10k/coredump.h
--- linux-5.4.39/drivers/net/wireless/ath/ath10k/coredump.h	2020-05-06 07:15:17.000000000 +0100
+++ linux-5.4.39-ct/drivers/net/wireless/ath/ath10k/coredump.h	2020-05-12 23:23:34.000000000 +0100
@@ -8,11 +8,16 @@
 
 #include "core.h"
 
-#define ATH10K_FW_CRASH_DUMP_VERSION 1
+#define ATH10K_FW_CRASH_DUMP_VERSION 2 /* upstream stole some bits I was using, or will soon. --Ben */
 
 /**
  * enum ath10k_fw_crash_dump_type - types of data in the dump file
  * @ATH10K_FW_CRASH_DUMP_REGDUMP: Register crash dump in binary format
+ * @ATH10K_FW_ERROR_DUMP_DBGLOG:  Recent firmware debug log entries
+ * @ATH10K_FW_CRASH_DUMP_STACK:   Stack memory contents.
+ * @ATH10K_FW_CRASH_DUMP_EXC_STACK:   Exception stack memory contents.
+ * @ATH10K_FW_CRASH_DUMP_RAM_BSS:  BSS area for RAM code
+ * @ATH10K_FW_CRASH_DUMP_ROM_BSS:  BSS area for ROM code
  */
 enum ath10k_fw_crash_dump_type {
 	ATH10K_FW_CRASH_DUMP_REGISTERS = 0,
@@ -20,7 +25,11 @@
 
 	/* contains multiple struct ath10k_dump_ram_data_hdr */
 	ATH10K_FW_CRASH_DUMP_RAM_DATA = 2,
-
+	ATH10K_FW_CRASH_DUMP_DBGLOG = 20,
+	ATH10K_FW_CRASH_DUMP_STACK = 21,
+	ATH10K_FW_CRASH_DUMP_EXC_STACK = 22,
+	ATH10K_FW_CRASH_DUMP_RAM_BSS = 23,
+	ATH10K_FW_CRASH_DUMP_ROM_BSS = 24,
 	ATH10K_FW_CRASH_DUMP_MAX,
 };
 
@@ -84,8 +93,13 @@
 	/* VERMAGIC_STRING */
 	char kernel_ver[64];
 
+	__le32 stack_addr;
+	__le32 exc_stack_addr;
+	__le32 rom_bss_addr;
+	__le32 ram_bss_addr;
+
 	/* room for growth w/out changing binary format */
-	u8 unused[128];
+	u8 unused[112];
 
 	/* struct ath10k_tlv_dump_data + more */
 	u8 data[0];
diff -Nur linux-5.4.39/drivers/net/wireless/ath/ath10k/debug.c linux-5.4.39-ct/drivers/net/wireless/ath/ath10k/debug.c
--- linux-5.4.39/drivers/net/wireless/ath/ath10k/debug.c	2020-05-06 07:15:17.000000000 +0100
+++ linux-5.4.39-ct/drivers/net/wireless/ath/ath10k/debug.c	2020-05-12 23:23:34.000000000 +0100
@@ -15,12 +15,15 @@
 #include "debug.h"
 #include "hif.h"
 #include "wmi-ops.h"
+#include "mac.h"
 
 /* ms */
 #define ATH10K_DEBUG_HTT_STATS_INTERVAL 1000
 
 #define ATH10K_DEBUG_CAL_DATA_LEN 12064
 
+#define ATH10K_DEBUG_NOP_INTERVAL 2000 /* ms */
+
 void ath10k_info(struct ath10k *ar, const char *fmt, ...)
 {
 	struct va_format vaf = {
@@ -30,7 +33,10 @@
 
 	va_start(args, fmt);
 	vaf.va = &args;
-	dev_info(ar->dev, "%pV", &vaf);
+	if (ath10k_debug_mask & ATH10K_DBG_INFO_AS_DBG)
+		dev_printk(KERN_DEBUG, ar->dev, "%pV", &vaf);
+	else
+		dev_info(ar->dev, "%pV", &vaf);
 	trace_ath10k_log_info(ar, &vaf);
 	va_end(args);
 }
@@ -39,7 +45,7 @@
 void ath10k_debug_print_hwfw_info(struct ath10k *ar)
 {
 	const struct firmware *firmware;
-	char fw_features[128] = {};
+	char fw_features[360] = {};
 	u32 crc = 0;
 
 	ath10k_core_get_fw_features_str(ar, fw_features, sizeof(fw_features));
@@ -84,7 +90,7 @@
 	if (!IS_ERR_OR_NULL(board))
 		crc = crc32_le(0, board->data, board->size);
 	else
-		crc = 0;
+		crc = 0xdeadbeef;
 
 	ath10k_info(ar, "board_file api %d bmi_id %s crc32 %08x",
 		    ar->bd_api,
@@ -113,6 +119,11 @@
 }
 EXPORT_SYMBOL(ath10k_print_driver_info);
 
+void ath10k_set_debug_mask(unsigned int v) {
+	ath10k_debug_mask = v;
+}
+EXPORT_SYMBOL(ath10k_set_debug_mask);
+
 void ath10k_err(struct ath10k *ar, const char *fmt, ...)
 {
 	struct va_format vaf = {
@@ -137,7 +148,7 @@
 
 	va_start(args, fmt);
 	vaf.va = &args;
-	dev_warn_ratelimited(ar->dev, "%pV", &vaf);
+	dev_warn(ar->dev, "%pV", &vaf);
 	trace_ath10k_log_warn(ar, &vaf);
 
 	va_end(args);
@@ -199,6 +210,163 @@
 	.llseek = default_llseek,
 };
 
+static ssize_t ath10k_read_misc(struct file *file,
+				char __user *user_buf,
+				size_t count, loff_t *ppos)
+{
+	struct ath10k *ar = file->private_data;
+	char *buf;
+	unsigned int len = 0, buf_len = 1000;
+	ssize_t ret_cnt;
+
+	buf = kzalloc(buf_len, GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+
+	mutex_lock(&ar->conf_mutex);
+
+	if (len > buf_len)
+		len = buf_len;
+
+	/* Probably need some sort of locking on the tx-queue?? */
+	len = snprintf(buf, 1000, "off-channel qlen: %d\n",
+		       skb_queue_len(&ar->offchan_tx_queue));
+
+	ret_cnt = simple_read_from_buffer(user_buf, count, ppos, buf, len);
+
+	mutex_unlock(&ar->conf_mutex);
+
+	kfree(buf);
+	return ret_cnt;
+}
+
+static const struct file_operations fops_misc = {
+	.read = ath10k_read_misc,
+	.open = simple_open,
+	.owner = THIS_MODULE,
+	.llseek = default_llseek,
+};
+
+static ssize_t ath10k_read_fwinfo(struct file *file,
+				  char __user *user_buf,
+				  size_t count, loff_t *ppos)
+{
+	struct ath10k *ar = file->private_data;
+	char *buf;
+	unsigned int len = 0, buf_len = 1000;
+	ssize_t ret_cnt;
+
+	buf = kzalloc(buf_len, GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+
+	mutex_lock(&ar->conf_mutex);
+
+	len = snprintf(buf, buf_len, "directory: %s\nfirmware:  %s\nfwcfg:     fwcfg-%s-%s.txt\nbus:       %s\nfeatures:  ",
+		       ar->hw_params.fw.dir, ar->running_fw->fw_file.fw_name,
+		       ath10k_bus_str(ar->hif.bus), dev_name(ar->dev), dev_name(ar->dev));
+	ath10k_core_get_fw_features_str(ar, buf + len, buf_len - len);
+
+	/* Just to be safe */
+	buf[buf_len - 1] = 0;
+	len = strlen(buf);
+
+	len += snprintf(buf + len, buf_len - len, "\nversion:   %s\nhw_rev:    ",
+			ar->hw->wiphy->fw_version);
+	switch (ar->hw_rev) {
+	case ATH10K_HW_QCA988X:
+		len += snprintf(buf + len, buf_len - len, "988x\n");
+		break;
+	case ATH10K_HW_QCA9887:
+		len += snprintf(buf + len, buf_len - len, "9887\n");
+		break;
+	case ATH10K_HW_QCA9888:
+		len += snprintf(buf + len, buf_len - len, "9888\n");
+		break;
+	case ATH10K_HW_WCN3990:
+		len += snprintf(buf + len, buf_len - len, "3990\n");
+		break;
+	case ATH10K_HW_QCA6174:
+		len += snprintf(buf + len, buf_len - len, "6174\n");
+		break;
+	case ATH10K_HW_QCA99X0:
+		len += snprintf(buf + len, buf_len - len, "99x0\n");
+		break;
+	case ATH10K_HW_QCA9984:
+		len += snprintf(buf + len, buf_len - len, "9984\n");
+		break;
+	case ATH10K_HW_QCA9377:
+		len += snprintf(buf + len, buf_len - len, "9377\n");
+		break;
+	case ATH10K_HW_QCA4019:
+		len += snprintf(buf + len, buf_len - len, "4019\n");
+		break;
+	}
+
+	len += snprintf(buf + len, buf_len - len, "board:     %s\n",
+			ar->normal_mode_fw.fw_file.fw_board_name);
+
+	ret_cnt = simple_read_from_buffer(user_buf, count, ppos, buf, len);
+
+	mutex_unlock(&ar->conf_mutex);
+
+	kfree(buf);
+	return ret_cnt;
+}
+
+static const struct file_operations fops_fwinfo_services = {
+	.read = ath10k_read_fwinfo,
+	.open = simple_open,
+	.owner = THIS_MODULE,
+	.llseek = default_llseek,
+};
+
+static ssize_t ath10k_read_peers(struct file *file,
+				 char __user *user_buf,
+				 size_t count, loff_t *ppos)
+{
+	struct ath10k *ar = file->private_data;
+	char *buf;
+	unsigned int len = 0, buf_len = 10000;
+	ssize_t ret_cnt;
+	struct ath10k_peer *peer;
+	int q;
+
+	buf = kzalloc(buf_len, GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+
+	mutex_lock(&ar->conf_mutex);
+	spin_lock_bh(&ar->data_lock);
+
+	list_for_each_entry(peer, &ar->peers, list) {
+		len += snprintf(buf + len, buf_len - len, "%pM  vdev-id: %d  peer-ids:",
+				peer->addr, peer->vdev_id);
+		for (q = 0; q<ATH10K_MAX_NUM_PEER_IDS; q++) {
+			if (test_bit(q, peer->peer_ids)) {
+				len += snprintf(buf + len, buf_len - len, " %d", q);
+			}
+		}
+		len += snprintf(buf + len, buf_len - len, "\n");
+	}
+
+	spin_unlock_bh(&ar->data_lock);
+
+	ret_cnt = simple_read_from_buffer(user_buf, count, ppos, buf, len);
+
+	mutex_unlock(&ar->conf_mutex);
+
+	kfree(buf);
+	return ret_cnt;
+}
+
+static const struct file_operations fops_peers = {
+	.read = ath10k_read_peers,
+	.open = simple_open,
+	.owner = THIS_MODULE,
+	.llseek = default_llseek,
+};
+
 static void ath10k_fw_stats_pdevs_free(struct list_head *head)
 {
 	struct ath10k_fw_stats_pdev *i, *tmp;
@@ -251,6 +419,30 @@
 	spin_unlock_bh(&ar->data_lock);
 }
 
+void ath10k_debug_fw_ratepwr_table_process(struct ath10k *ar, struct sk_buff *skb)
+{
+	size_t sz = skb->len;
+	if (sz != sizeof(struct qc988xxEepromRateTbl)) {
+		ath10k_info(ar, "Invalid ratepwr table results length, expected: %d  got: %d\n",
+			    (int)(sizeof(struct qc988xxEepromRateTbl)), (int)sz);
+		sz = min(sz, sizeof(struct qc988xxEepromRateTbl));
+	}
+	memcpy(ar->debug.ratepwr_tbl.data, skb->data, sz);
+	complete(&ar->debug.ratepwr_tbl_complete);
+}
+
+void ath10k_debug_fw_powerctl_table_process(struct ath10k *ar, struct sk_buff *skb)
+{
+	size_t sz = skb->len;
+	if (sz != sizeof(struct qca9880_power_ctrl)) {
+		ath10k_info(ar, "Invalid powerctl table results length, expected: %d  got: %d\n",
+			    (int)(sizeof(struct qca9880_power_ctrl)), (int)sz);
+		sz = min(sz, sizeof(struct qca9880_power_ctrl));
+	}
+	memcpy(ar->debug.powerctl_tbl.data, skb->data, sz);
+	complete(&ar->debug.powerctl_tbl_complete);
+}
+
 void ath10k_debug_fw_stats_process(struct ath10k *ar, struct sk_buff *skb)
 {
 	struct ath10k_fw_stats stats = {};
@@ -258,6 +450,7 @@
 	size_t num_peers;
 	size_t num_vdevs;
 	int ret;
+	const struct wmi_stats_event *ev = (void *)skb->data;
 
 	INIT_LIST_HEAD(&stats.pdevs);
 	INIT_LIST_HEAD(&stats.vdevs);
@@ -265,6 +458,202 @@
 	INIT_LIST_HEAD(&stats.peers_extd);
 
 	spin_lock_bh(&ar->data_lock);
+
+	/*ath10k_warn(ar, "fw-stats-process: stats-id: 0x%x(0x%x)\n", ev->stats_id, __le32_to_cpu(ev->stats_id));*/
+	/* CT Firmware only */
+	if (__le32_to_cpu(ev->stats_id) == WMI_REQUEST_STAT_CUSTOM) {
+		__le32* data;
+		u32 stats_len;
+		u32 *my_stats = NULL;
+		u32 my_len = 0;
+
+		if ((ar->running_fw->fw_file.wmi_op_version == ATH10K_FW_WMI_OP_VERSION_10_2) ||
+		    (ar->running_fw->fw_file.wmi_op_version == ATH10K_FW_WMI_OP_VERSION_10_4) ||
+		    (ar->running_fw->fw_file.wmi_op_version == ATH10K_FW_WMI_OP_VERSION_10_2_4)) {
+			const struct wmi_10_2_stats_event *ev2 = (void *)skb->data;
+			data = (__le32*)(ev2->data);
+			stats_len = (skb->len - sizeof(*ev2)) / 4;
+		} else {
+			/* Must be 10.1 */
+			data = (__le32*)(ev->data);
+			stats_len =  (skb->len - sizeof(*ev)) / 4;
+		}
+
+		/*ath10k_err(ar, "id: %d stats_len: %d skb->len: %d\n",
+		             ev->num_pdev_stats, stats_len, skb->len);*/
+
+		if (ev->num_pdev_stats == WMI_STAT_CUSTOM_RX_REORDER_STATS) {
+			my_len = sizeof(ar->debug.rx_reorder_stats) / 4;
+			my_len = min(my_len, stats_len);
+			my_stats = (u32*)(&(ar->debug.rx_reorder_stats));
+		}
+		else if (ev->num_pdev_stats == WMI_STAT_CUSTOM_PDEV_EXT_STATS) {
+			if (stats_len >= 10) {
+				struct ath10k_pdev_ext_stats_ct *pes = (void*)(data);
+				/* A bug in wave-1 (at least) FW caused us to get stats here when
+				 * we should not.  Fortunately, the bad stats are often shorter than 10
+				 * 32-bit values, so we ignore those.
+				 */
+				my_len = __le32_to_cpu(pes->count) + 2;
+				if (my_len == stats_len) { /* make sure it is self-consistent */
+					if (my_len > (sizeof(*pes) / 4)) {
+						my_len = sizeof(*pes) / 4;
+					}
+					my_len = min(my_len, stats_len);
+					my_stats = (u32*)(&(ar->debug.pdev_ext_stats));
+				}
+			}
+		}
+
+		/* If we know about the stats, handle it here. */
+		if (my_stats) {
+			int i;
+			for (i = 0; i<my_len; i++) {
+				my_stats[i] = __le32_to_cpu(data[i]);
+			}
+
+			/* Post-process some stats */
+			if (ev->num_pdev_stats == WMI_STAT_CUSTOM_PDEV_EXT_STATS) {
+				/* These are in 2s compliment form, convert:  f = (0 - ((f ^ 0x1ff) +1)) */
+#define COMP2(a) ar->debug.pdev_ext_stats.a = (0 - ((ar->debug.pdev_ext_stats.a ^ 0x1ff) + 1)); \
+				if (ar->debug.pdev_ext_stats.a == -512) { ar->debug.pdev_ext_stats.a = 0x80; }
+				COMP2(chan_nf_0);
+				COMP2(chan_nf_1);
+				COMP2(chan_nf_2);
+				COMP2(chan_nf_3);
+				COMP2(chan_nf_sec80_1);
+				COMP2(chan_nf_sec80_2);
+				COMP2(chan_nf_sec80_3);
+#undef COMP2
+				/* Calculate avg noise floor so we don't have to calculate it over and over in the rx path */
+				ar->debug.nf_sum[0] = ar->debug.pdev_ext_stats.chan_nf_0;
+				ar->debug.nf_sum[1] = ath10k_sum_sigs_2(ar->debug.pdev_ext_stats.chan_nf_0, ar->debug.pdev_ext_stats.chan_nf_1);
+				ar->debug.nf_sum[2] = ath10k_sum_sigs(ar->debug.pdev_ext_stats.chan_nf_0,
+								      ar->debug.pdev_ext_stats.chan_nf_1,
+								      ar->debug.pdev_ext_stats.chan_nf_2,
+								      0x80);
+				ar->debug.nf_sum[3] = ath10k_sum_sigs(ar->debug.pdev_ext_stats.chan_nf_0,
+								      ar->debug.pdev_ext_stats.chan_nf_1,
+								      ar->debug.pdev_ext_stats.chan_nf_2,
+								      ar->debug.pdev_ext_stats.chan_nf_3);
+			}
+		}
+		ar->debug.fw_stats_done = true;
+		complete(&ar->debug.fw_stats_complete);
+		/*ath10k_warn(ar, "Completed stat-custom, my_len: %u\n", my_len);*/
+		goto free;
+	}
+
+	if (__le32_to_cpu(ev->stats_id) == WMI_REQUEST_REGISTER_DUMP) {
+		struct ath10k_reg_dump* regdump;
+		struct ath10k_fw_stats* sptr = &ar->debug.fw_stats;
+		int i;
+
+		if ((ar->running_fw->fw_file.wmi_op_version == ATH10K_FW_WMI_OP_VERSION_10_2) ||
+		    (ar->running_fw->fw_file.wmi_op_version == ATH10K_FW_WMI_OP_VERSION_10_4) ||
+		    (ar->running_fw->fw_file.wmi_op_version == ATH10K_FW_WMI_OP_VERSION_10_2_4)) {
+			const struct wmi_10_2_stats_event *ev2 = (void *)skb->data;
+			regdump = (struct ath10k_reg_dump*)(ev2->data);
+		} else {
+			/* Must be 10.1 */
+			regdump = (struct ath10k_reg_dump*)(ev->data);
+		}
+
+		for (i = 0; i < __le16_to_cpu(regdump->count); i++) {
+			u32 id = __le32_to_cpu(regdump->regpair[i].reg_id);
+			switch (id) {
+			case REG_DUMP_NONE:
+				break;
+			case MAC_FILTER_ADDR_L32:
+				sptr->mac_filter_addr_l32 = __le32_to_cpu(regdump->regpair[i].reg_val);
+				break;
+			case MAC_FILTER_ADDR_U16:
+				sptr->mac_filter_addr_u16 = __le32_to_cpu(regdump->regpair[i].reg_val);
+				break;
+			case DCU_SLOT_TIME:
+				sptr->dcu_slot_time = __le32_to_cpu(regdump->regpair[i].reg_val);
+				break;
+			case PHY_BB_MODE_SELECT:
+				sptr->phy_bb_mode_select = __le32_to_cpu(regdump->regpair[i].reg_val);
+				break;
+			case PCU_BSSID_L32:
+				sptr->pcu_bssid_l32 = __le32_to_cpu(regdump->regpair[i].reg_val);
+				break;
+			case PCU_BSSID_U16:
+				sptr->pcu_bssid_u16 = __le32_to_cpu(regdump->regpair[i].reg_val);
+				break;
+			case PCU_BSSID2_L32:
+				sptr->pcu_bssid2_l32 = __le32_to_cpu(regdump->regpair[i].reg_val);
+				break;
+			case PCU_BSSID2_U16:
+				sptr->pcu_bssid2_u16 = __le32_to_cpu(regdump->regpair[i].reg_val);
+				break;
+			case PCU_STA_ADDR_U16:
+				sptr->pcu_sta_addr_u16 = __le32_to_cpu(regdump->regpair[i].reg_val);
+				break;
+			case MAC_DMA_CFG:
+				sptr->mac_dma_cfg = __le32_to_cpu(regdump->regpair[i].reg_val);
+				break;
+			case MAC_DMA_TXCFG:
+				sptr->mac_dma_txcfg = __le32_to_cpu(regdump->regpair[i].reg_val);
+				break;
+			case PCU_STA_ADDR_L32:
+				sptr->pcu_sta_addr_l32 = __le32_to_cpu(regdump->regpair[i].reg_val);
+				break;
+			case PCU_RXFILTER:
+				sptr->pcu_rxfilter = __le32_to_cpu(regdump->regpair[i].reg_val);
+				break;
+			case PHY_BB_GEN_CONTROLS:
+				sptr->phy_bb_gen_controls = __le32_to_cpu(regdump->regpair[i].reg_val);
+				break;
+			case DMA_IMR:
+				sptr->dma_imr = __le32_to_cpu(regdump->regpair[i].reg_val);
+				break;
+			case DMA_TXRX_IMR:
+				sptr->dma_txrx_imr = __le32_to_cpu(regdump->regpair[i].reg_val);
+				break;
+			case SW_POWERMODE:
+				sptr->sw_powermode = __le32_to_cpu(regdump->regpair[i].reg_val);
+				break;
+			case SW_CHAINMASK:
+				sptr->sw_chainmask_tx = (__le32_to_cpu(regdump->regpair[i].reg_val) >> 16);
+				sptr->sw_chainmask_rx = __le32_to_cpu(regdump->regpair[i].reg_val);
+				break;
+			case SW_OPMODE:
+				sptr->sw_opmode = __le32_to_cpu(regdump->regpair[i].reg_val);
+				break;
+			case SW_RXFILTER:
+				sptr->sw_rxfilter = __le32_to_cpu(regdump->regpair[i].reg_val);
+				break;
+			case SW_LONG_RETRIES:
+				sptr->long_retries = __le32_to_cpu(regdump->regpair[i].reg_val);
+				break;
+			case SW_SHORT_RETRIES:
+				sptr->short_retries = __le32_to_cpu(regdump->regpair[i].reg_val);
+				break;
+			case ADC_TEMP:
+				sptr->adc_temp = __le32_to_cpu(regdump->regpair[i].reg_val);
+				break;
+			case NF_CHAINS:
+				sptr->nfcal = __le32_to_cpu(regdump->regpair[i].reg_val);
+				break;
+			default: {
+				/* Foward-compat logic */
+				int max_supported = DBG_REG_DUMP_COUNT + ARRAY_SIZE(sptr->extra_regs);
+				if (id >= DBG_REG_DUMP_COUNT && id < max_supported) {
+					sptr->extra_regs[id - DBG_REG_DUMP_COUNT] = regdump->regpair[i].reg_val;
+					sptr->extras_count = max(sptr->extras_count, (int)(id - DBG_REG_DUMP_COUNT) + 1);
+				}
+				//ath10k_warn(ar, "dbg-regs, max-supported: %d  id: %d  extras-count: %d\n",
+				//	    max_supported, id, sptr->extras_count);
+			} /* default case */
+			}/* switch */
+		}
+		ar->debug.fw_stats_done = true;
+		complete(&ar->debug.fw_stats_complete);
+		goto free;
+	}
+
 	ret = ath10k_wmi_pull_fw_stats(ar, skb, &stats);
 	if (ret) {
 		ath10k_warn(ar, "failed to pull fw stats: %d\n", ret);
@@ -311,19 +700,21 @@
 	is_started = !list_empty(&ar->debug.fw_stats.pdevs);
 
 	if (is_started && !is_end) {
-		if (num_peers >= ATH10K_MAX_NUM_PEER_IDS) {
+		if (num_peers > ATH10K_MAX_NUM_PEER_IDS) {
 			/* Although this is unlikely impose a sane limit to
 			 * prevent firmware from DoS-ing the host.
 			 */
 			ath10k_fw_stats_peers_free(&ar->debug.fw_stats.peers);
 			ath10k_fw_extd_stats_peers_free(&ar->debug.fw_stats.peers_extd);
-			ath10k_warn(ar, "dropping fw peer stats\n");
+			ath10k_warn(ar, "dropping fw peer stats, num_peers: %d  max-peer-ids: %d\n",
+				    (int)(num_peers), (int)(ATH10K_MAX_NUM_PEER_IDS));
 			goto free;
 		}
 
-		if (num_vdevs >= BITS_PER_LONG) {
+		if (num_vdevs > BITS_PER_LONG) {
 			ath10k_fw_stats_vdevs_free(&ar->debug.fw_stats.vdevs);
-			ath10k_warn(ar, "dropping fw vdev stats\n");
+			ath10k_warn(ar, "dropping fw vdev stats, num-vdevs: %d, bits-per-long: %d\n",
+				    (int)(num_vdevs), (int)(BITS_PER_LONG));
 			goto free;
 		}
 
@@ -349,9 +740,9 @@
 	spin_unlock_bh(&ar->data_lock);
 }
 
-static int ath10k_debug_fw_stats_request(struct ath10k *ar)
+int ath10k_debug_fw_stats_request(struct ath10k *ar)
 {
-	unsigned long timeout, time_left;
+	unsigned long timeout;
 	int ret;
 
 	lockdep_assert_held(&ar->conf_mutex);
@@ -364,19 +755,9 @@
 		if (time_after(jiffies, timeout))
 			return -ETIMEDOUT;
 
-		reinit_completion(&ar->debug.fw_stats_complete);
-
-		ret = ath10k_wmi_request_stats(ar, ar->fw_stats_req_mask);
-		if (ret) {
-			ath10k_warn(ar, "could not request stats (%d)\n", ret);
+		ret = ath10k_refresh_peer_stats(ar);
+		if (ret)
 			return ret;
-		}
-
-		time_left =
-		wait_for_completion_timeout(&ar->debug.fw_stats_complete,
-					    1 * HZ);
-		if (!time_left)
-			return -ETIMEDOUT;
 
 		spin_lock_bh(&ar->data_lock);
 		if (ar->debug.fw_stats_done) {
@@ -440,6 +821,330 @@
 	return 0;
 }
 
+static int ath10k_refresh_peer_stats_t(struct ath10k *ar, u32 type, u32 specifier)
+{
+	int ret;
+	unsigned long time_left;
+
+	/*ath10k_warn(ar, "Requesting stats (type 0x%x specifier %d jiffies: %lu)\n",
+	  type, specifier, jiffies);*/
+	reinit_completion(&ar->debug.fw_stats_complete);
+	ret = ath10k_wmi_request_stats(ar, type, specifier);
+
+	if (ret) {
+		ath10k_warn(ar, "could not request stats (type %d ret %d specifier %d)\n",
+			    type, ret, specifier);
+		return ret;
+	}
+
+	/* ret means 'time-left' here */
+	time_left =
+		wait_for_completion_timeout(&ar->debug.fw_stats_complete, 1*HZ);
+
+	/* ath10k_warn(ar, "Requested stats (type 0x%x ret %d specifier %d jiffies: %lu  time-left: %lu)\n",
+	   type, ret, specifier, jiffies, time_left);*/
+
+	if (time_left == 0)
+		return -ETIMEDOUT;
+
+	return 0;
+}
+
+int ath10k_refresh_peer_stats(struct ath10k *ar)
+{
+	return ath10k_refresh_peer_stats_t(ar, ar->fw_stats_req_mask, 0);
+}
+
+int ath10k_refresh_target_regs(struct ath10k *ar)
+{
+	if (test_bit(ATH10K_FW_FEATURE_REGDUMP_CT,
+		     ar->running_fw->fw_file.fw_features))
+		return ath10k_refresh_peer_stats_t(ar, WMI_REQUEST_REGISTER_DUMP, 0);
+	return 0; /* fail silently if firmware does not support this option. */
+}
+
+int ath10k_refresh_target_rx_reorder_stats(struct ath10k *ar)
+{
+	if (test_bit(ATH10K_FW_FEATURE_CUST_STATS_CT,
+		     ar->running_fw->fw_file.fw_features))
+		return ath10k_refresh_peer_stats_t(ar, WMI_REQUEST_STAT_CUSTOM, WMI_STAT_CUSTOM_RX_REORDER_STATS);
+	return 0; /* fail silently if firmware does not support this option. */
+}
+
+int ath10k_refresh_target_pdev_ext_ct_stats(struct ath10k *ar)
+{
+	if (test_bit(ATH10K_FW_FEATURE_CUST_STATS_CT,
+		     ar->running_fw->fw_file.fw_features))
+		return ath10k_refresh_peer_stats_t(ar, WMI_REQUEST_STAT_CUSTOM, WMI_STAT_CUSTOM_PDEV_EXT_STATS);
+	return 0; /* fail silently if firmware does not support this option. */
+}
+
+
+static ssize_t ath10k_read_rx_reorder_stats(struct file *file, char __user *user_buf,
+					    size_t count, loff_t *ppos)
+{
+	struct ath10k *ar = file->private_data;
+	struct ath10k_rx_reorder_stats *rrs;
+	char *buf = NULL;
+	unsigned int len = 0, buf_len = 8000;
+	ssize_t ret_cnt = 0;
+	int ret;
+
+	mutex_lock(&ar->conf_mutex);
+
+	rrs = &ar->debug.rx_reorder_stats;
+
+	if (ar->state != ATH10K_STATE_ON)
+		goto exit;
+
+	buf = kzalloc(buf_len, GFP_KERNEL);
+	if (!buf)
+		goto exit;
+
+	ret = ath10k_refresh_target_rx_reorder_stats(ar);
+	if (ret)
+		goto exit;
+
+	len += scnprintf(buf + len, buf_len - len, "\n");
+	len += scnprintf(buf + len, buf_len - len, "%30s\n",
+			 "ath10k RX Reorder Stats");
+	len += scnprintf(buf + len, buf_len - len, "%30s\n\n",
+				 "=================");
+
+#define PRINT_MY_STATS(a) len += scnprintf(buf + len, buf_len - len, "%30s %10d\n", #a, rrs->a)
+	/* Non QoS MPDUs received */
+	PRINT_MY_STATS(deliver_non_qos);
+	/* MPDUs received in-order */
+	PRINT_MY_STATS(deliver_in_order);
+	/* Flush due to reorder timer expired */
+	PRINT_MY_STATS(deliver_flush_timeout);
+	/* Flush due to move out of window */
+	PRINT_MY_STATS(deliver_flush_oow);
+	/* Flush due to DELBA */
+	PRINT_MY_STATS(deliver_flush_delba);
+	/* MPDUs dropped due to FCS error */
+	PRINT_MY_STATS(fcs_error);
+	/* MPDUs dropped due to monitor mode non-data packet */
+	PRINT_MY_STATS(mgmt_ctrl);
+	/* MPDUs dropped due to invalid peer */
+	PRINT_MY_STATS(invalid_peer);
+	/* MPDUs dropped due to duplication (non aggregation) */
+	PRINT_MY_STATS(dup_non_aggr);
+	/* MPDUs dropped due to processed before */
+	PRINT_MY_STATS(dup_past);
+	/* MPDUs dropped due to duplicate in reorder queue */
+	PRINT_MY_STATS(dup_in_reorder);
+	/* Reorder timeout happened */
+	PRINT_MY_STATS(reorder_timeout);
+	/* invalid bar ssn */
+	PRINT_MY_STATS(invalid_bar_ssn);
+	/* reorder reset due to bar ssn */
+	PRINT_MY_STATS(ssn_reset);
+
+	/* Added by Ben */
+	PRINT_MY_STATS(frag_invalid_peer);
+	PRINT_MY_STATS(frag_fcs_error);
+	PRINT_MY_STATS(frag_ok);
+	PRINT_MY_STATS(frag_discards);
+
+	PRINT_MY_STATS(rx_chatter);
+	PRINT_MY_STATS(tkip_mic_error);
+	PRINT_MY_STATS(tkip_decrypt_error);
+	PRINT_MY_STATS(mpdu_length_error);
+	PRINT_MY_STATS(non_frag_unicast_ok);
+
+	PRINT_MY_STATS(rx_flush_ind); // Flushed these due to timeout, etc.
+	PRINT_MY_STATS(rx_flush_ie_add); // Flushed these due to timeout, etc
+
+	/* Wave-2 specific */
+	PRINT_MY_STATS(rx_mesh_wrong_dest);
+	PRINT_MY_STATS(rx_mesh_filter_ra);
+	PRINT_MY_STATS(rx_mesh_filter_fromds);
+	PRINT_MY_STATS(rx_mesh_filter_tods);
+	PRINT_MY_STATS(rx_mesh_filter_nods);
+	PRINT_MY_STATS(rx_radar_fft_war);
+	PRINT_MY_STATS(rx_drop_encrypt_required);
+	PRINT_MY_STATS(rx_mpdu_tid_err);
+	PRINT_MY_STATS(rx_ba_statemachine_err);
+	PRINT_MY_STATS(rx_drop_replay);
+	PRINT_MY_STATS(rx_non_data_drop_no_bufs);
+
+	if (len > buf_len)
+		len = buf_len;
+
+	ret_cnt = simple_read_from_buffer(user_buf, count, ppos, buf, len);
+
+exit:
+	mutex_unlock(&ar->conf_mutex);
+	kfree(buf);
+	return ret_cnt;
+}
+
+static ssize_t ath10k_read_pdev_ext_ct_stats(struct file *file, char __user *user_buf,
+					     size_t count, loff_t *ppos)
+{
+	struct ath10k *ar = file->private_data;
+	struct ath10k_pdev_ext_stats_ct *rrs;
+	char *buf = NULL;
+	unsigned int len = 0, buf_len = 8000;
+	ssize_t ret_cnt = 0;
+	int ret;
+
+	mutex_lock(&ar->conf_mutex);
+
+	rrs = &ar->debug.pdev_ext_stats;
+
+	if (ar->state != ATH10K_STATE_ON)
+		goto exit;
+
+	buf = kzalloc(buf_len, GFP_KERNEL);
+	if (!buf)
+		goto exit;
+
+	ret = ath10k_refresh_target_pdev_ext_ct_stats(ar);
+	if (ret)
+		goto exit;
+
+	len += scnprintf(buf + len, buf_len - len, "\n");
+	len += scnprintf(buf + len, buf_len - len, "%30s\n",
+			 "ath10k PDEV Extended Stats");
+	len += scnprintf(buf + len, buf_len - len, "%30s\n\n",
+				 "=================");
+
+#define PRINT_MY_STATS(a) len += scnprintf(buf + len, buf_len - len, "%30s %10d\n", #a, rrs->a)
+	PRINT_MY_STATS(flags);
+	PRINT_MY_STATS(num_chains);
+	PRINT_MY_STATS(chan_nf_0);
+	PRINT_MY_STATS(chan_nf_1);
+	PRINT_MY_STATS(chan_nf_2);
+	PRINT_MY_STATS(chan_nf_3);
+	PRINT_MY_STATS(chan_nf_sec80_1);
+	PRINT_MY_STATS(chan_nf_sec80_2);
+	PRINT_MY_STATS(chan_nf_sec80_3);
+
+#undef PRINT_MY_STATS
+#define PRINT_MY_STATS(a) len += scnprintf(buf + len, buf_len - len, "%30s %10d\n", #a, ar->debug.a)
+	PRINT_MY_STATS(nf_sum[0]);
+	PRINT_MY_STATS(nf_sum[1]);
+	PRINT_MY_STATS(nf_sum[2]);
+	PRINT_MY_STATS(nf_sum[3]);
+
+	if (len > buf_len)
+		len = buf_len;
+
+	ret_cnt = simple_read_from_buffer(user_buf, count, ppos, buf, len);
+
+exit:
+	mutex_unlock(&ar->conf_mutex);
+	kfree(buf);
+	return ret_cnt;
+}
+
+static ssize_t ath10k_read_fw_regs(struct file *file, char __user *user_buf,
+				   size_t count, loff_t *ppos)
+{
+	struct ath10k *ar = file->private_data;
+	struct ath10k_fw_stats *fw_regs;
+	char *buf = NULL;
+	unsigned int len = 0, buf_len = 8000;
+	ssize_t ret_cnt = 0;
+	int ret;
+	int i;
+
+	fw_regs = &ar->debug.fw_stats;
+
+	mutex_lock(&ar->conf_mutex);
+
+	if (ar->state != ATH10K_STATE_ON)
+		goto exit;
+
+	buf = kzalloc(buf_len, GFP_KERNEL);
+	if (!buf)
+		goto exit;
+
+	ret = ath10k_refresh_target_regs(ar);
+	if (ret)
+		goto exit;
+
+	spin_lock_bh(&ar->data_lock);
+	len += scnprintf(buf + len, buf_len - len, "\n");
+	len += scnprintf(buf + len, buf_len - len, "%s (extras-count: %d)\n",
+			 "ath10k Target Register Dump", fw_regs->extras_count);
+	len += scnprintf(buf + len, buf_len - len, "%30s\n\n",
+				 "=================");
+
+	len += scnprintf(buf + len, buf_len - len, "%30s 0x%08x\n",
+			 "MAC-FILTER-ADDR-L32", fw_regs->mac_filter_addr_l32);
+	len += scnprintf(buf + len, buf_len - len, "%30s 0x%08x\n",
+			 "MAC-FILTER-ADDR-U16", fw_regs->mac_filter_addr_u16);
+	len += scnprintf(buf + len, buf_len - len, "%30s 0x%08x\n",
+			 "DCU-SLOT-TIME", fw_regs->dcu_slot_time);
+	len += scnprintf(buf + len, buf_len - len, "%30s 0x%08x\n",
+			 "PHY-MODE-SELECT", fw_regs->phy_bb_mode_select);
+	len += scnprintf(buf + len, buf_len - len, "%30s 0x%08x\n",
+			 "PHY-BB-GEN-CONTROLS", fw_regs->phy_bb_gen_controls);
+	len += scnprintf(buf + len, buf_len - len, "%30s 0x%08x\n",
+			 "DMA-IMR", fw_regs->dma_imr);
+	len += scnprintf(buf + len, buf_len - len, "%30s 0x%08x\n",
+			 "DMA-TXRX-IMR", fw_regs->dma_txrx_imr);
+	len += scnprintf(buf + len, buf_len - len, "%30s 0x%08x\n",
+			 "PCU-BSSID-L32", fw_regs->pcu_bssid_l32);
+	len += scnprintf(buf + len, buf_len - len, "%30s 0x%08x\n",
+			 "PCU-BSSID-U16", fw_regs->pcu_bssid_u16);
+	len += scnprintf(buf + len, buf_len - len, "%30s 0x%08x\n",
+			 "PCU-BSSID2-L32", fw_regs->pcu_bssid2_l32);
+	len += scnprintf(buf + len, buf_len - len, "%30s 0x%08x\n",
+			 "PCU-BSSID2-U16", fw_regs->pcu_bssid2_u16);
+	len += scnprintf(buf + len, buf_len - len, "%30s 0x%08x\n",
+			 "PCU-STA-ADDR-L32", fw_regs->pcu_sta_addr_l32);
+	len += scnprintf(buf + len, buf_len - len, "%30s 0x%08x\n",
+			 "PCU-STA-ADDR-U16", fw_regs->pcu_sta_addr_u16);
+	len += scnprintf(buf + len, buf_len - len, "%30s 0x%08x\n",
+			 "MAC-DMA-CFG", fw_regs->mac_dma_cfg);
+	len += scnprintf(buf + len, buf_len - len, "%30s 0x%08x\n",
+			 "MAC-DMA-TXCFG", fw_regs->mac_dma_txcfg);
+
+	len += scnprintf(buf + len, buf_len - len, "%30s 0x%08x\n",
+			 "SW-POWERMODE", fw_regs->sw_powermode);
+	len += scnprintf(buf + len, buf_len - len, "%30s 0x%08x\n",
+			 "SW-CHAINMASK-TX", (u32)(fw_regs->sw_chainmask_tx));
+	len += scnprintf(buf + len, buf_len - len, "%30s 0x%08x\n",
+			 "SW-CHAINMASK-RX", (u32)(fw_regs->sw_chainmask_rx));
+	len += scnprintf(buf + len, buf_len - len, "%30s 0x%08x\n",
+			 "SW-OPMODE", fw_regs->sw_opmode);
+
+	len += scnprintf(buf + len, buf_len - len, "%30s 0x%08x\n",
+			 "MAC-PCU-RXFILTER", fw_regs->pcu_rxfilter);
+	len += scnprintf(buf + len, buf_len - len, "%30s 0x%08x\n",
+			 "SW-RXFILTER", fw_regs->sw_rxfilter);
+	len += scnprintf(buf + len, buf_len - len, "%30s 0x%08x\n",
+			 "SHORT-RETRIES", fw_regs->short_retries);
+	len += scnprintf(buf + len, buf_len - len, "%30s 0x%08x\n",
+			 "LONG-RETRIES", fw_regs->long_retries);
+	len += scnprintf(buf + len, buf_len - len, "%30s 0x%08x\n",
+			 "ADC-TEMP", fw_regs->adc_temp);
+	len += scnprintf(buf + len, buf_len - len, "%30s 0x%08x\n",
+			 "NFCAL-PER-CHAIN", fw_regs->nfcal);
+
+	for (i = 0; i<fw_regs->extras_count; i++) {
+		len += scnprintf(buf + len, buf_len - len, "%26s%04d 0x%08x\n",
+				 "", i + DBG_REG_DUMP_COUNT, fw_regs->extra_regs[i]);
+	}
+
+	spin_unlock_bh(&ar->data_lock);
+
+	if (len > buf_len)
+		len = buf_len;
+
+	ret_cnt = simple_read_from_buffer(user_buf, count, ppos, buf, len);
+
+exit:
+	mutex_unlock(&ar->conf_mutex);
+	kfree(buf);
+	return ret_cnt;
+}
+
+
 static ssize_t ath10k_fw_stats_read(struct file *file, char __user *user_buf,
 				    size_t count, loff_t *ppos)
 {
@@ -517,6 +1222,27 @@
 				   ar->wmi.cmd->vdev_install_key_cmdid);
 }
 
+static const struct file_operations fops_fw_regs = {
+	.read = ath10k_read_fw_regs,
+	.open = simple_open,
+	.owner = THIS_MODULE,
+	.llseek = default_llseek,
+};
+
+static const struct file_operations fops_rx_reorder_stats = {
+	.read = ath10k_read_rx_reorder_stats,
+	.open = simple_open,
+	.owner = THIS_MODULE,
+	.llseek = default_llseek,
+};
+
+static const struct file_operations fops_pdev_ext_stats = {
+	.read = ath10k_read_pdev_ext_ct_stats,
+	.open = simple_open,
+	.owner = THIS_MODULE,
+	.llseek = default_llseek,
+};
+
 static ssize_t ath10k_read_simulate_fw_crash(struct file *file,
 					     char __user *user_buf,
 					     size_t count, loff_t *ppos)
@@ -590,11 +1316,429 @@
 		goto exit;
 	}
 
-	if (ret) {
-		ath10k_warn(ar, "failed to simulate firmware crash: %d\n", ret);
+	if (ret) {
+		ath10k_warn(ar, "failed to simulate firmware crash: %d\n", ret);
+		goto exit;
+	}
+
+	ret = count;
+
+exit:
+	mutex_unlock(&ar->conf_mutex);
+	return ret;
+}
+
+static const struct file_operations fops_simulate_fw_crash = {
+	.read = ath10k_read_simulate_fw_crash,
+	.write = ath10k_write_simulate_fw_crash,
+	.open = simple_open,
+	.owner = THIS_MODULE,
+	.llseek = default_llseek,
+};
+
+static ssize_t ath10k_read_debug_level(struct file *file,
+				       char __user *user_buf,
+				       size_t count, loff_t *ppos)
+{
+	int sz;
+	const char buf[] =
+		"To change debug level, set value adding up desired flags:\n"
+		"PCI:                0x1\n"
+		"WMI:                0x2\n"
+		"HTC:                0x4\n"
+		"HTT:                0x8\n"
+		"MAC:               0x10\n"
+		"BOOT:              0x20\n"
+		"PCI-DUMP:          0x40\n"
+		"HTT-DUMP:          0x80\n"
+		"MGMT:             0x100\n"
+		"DATA:             0x200\n"
+		"BMI:              0x400\n"
+		"REGULATORY:       0x800\n"
+		"TESTMODE:        0x1000\n"
+		"WMI-PRINT:       0x2000\n"
+		"PCI-PS:          0x4000\n"
+		"AHB:             0x8000\n"
+		"SDIO:		 0x10000\n"
+		"SDIO_DUMP:	 0x20000\n"
+		"USB:		 0x40000\n"
+		"USB_BULK:	 0x80000\n"
+		"SNOC:		0x100000\n"
+		"QMI:		0x200000\n"
+		"BEACONS:      0x8000000\n"
+		"NO-FW-DBGLOG:0x10000000\n"
+		"MAC2:        0x20000000\n"
+		"INFO-AS-DBG: 0x40000000\n"
+		"FW:          0x80000000\n"
+		"ALL:         0xEFFFFFFF\n";
+	char wbuf[sizeof(buf) + 60];
+	sz = snprintf(wbuf, sizeof(wbuf), "Current debug level: 0x%x\n\n%s",
+		      ath10k_debug_mask, buf);
+	wbuf[sizeof(wbuf) - 1] = 0;
+
+	return simple_read_from_buffer(user_buf, count, ppos, wbuf, sz);
+}
+
+/* Set logging level.
+ */
+static ssize_t ath10k_write_debug_level(struct file *file,
+					const char __user *user_buf,
+					size_t count, loff_t *ppos)
+{
+	struct ath10k *ar = file->private_data;
+	int ret;
+	unsigned long mask;
+
+	ret = kstrtoul_from_user(user_buf, count, 0, &mask);
+	if (ret)
+		return ret;
+
+	ath10k_warn(ar, "Setting debug-mask to: 0x%lx  old: 0x%x\n",
+		    mask, ath10k_debug_mask);
+	ath10k_debug_mask = mask;
+	return count;
+}
+
+static const struct file_operations fops_debug_level = {
+	.read = ath10k_read_debug_level,
+	.write = ath10k_write_debug_level,
+	.open = simple_open,
+	.owner = THIS_MODULE,
+	.llseek = default_llseek,
+};
+
+static ssize_t ath10k_read_set_rates(struct file *file,
+				     char __user *user_buf,
+				     size_t count, loff_t *ppos)
+{
+	const char buf[] =
+		"This is to set fixed bcast, mcast, and beacon rates.  Normal rate-ctrl\n"
+		"is handled through normal API using 'iw', etc.\n"
+		"To set a value, you specify the dev-name, type, band and rate-code:\n"
+		"types: bcast, mcast, beacon\n"
+		"bands: 2, 5, 60\n"
+		"rate-codes: 0x43 1M, 0x42 2M, 0x41 5.5M, 0x40 11M, 0x3 6M, 0x7 9M, 0x2 12M, 0x6 18M, 0x1 24M, 0x5 36M, 0x0 48M, 0x4 54M, 0xFF default\n"
+		" For example, to set beacon to 18Mbps on wlan0:  echo \"wlan0 beacon 2 0x6\" > /debug/..../set_rates\n";
+
+	return simple_read_from_buffer(user_buf, count, ppos, buf, strlen(buf));
+}
+
+/* Set the rates for specific types of traffic.
+ */
+static ssize_t ath10k_write_set_rates(struct file *file,
+				      const char __user *user_buf,
+				      size_t count, loff_t *ppos)
+{
+	struct ath10k *ar = file->private_data;
+	char buf[80];
+	int ret;
+	struct ath10k_vif *arvif;
+	struct ieee80211_vif *vif;
+	unsigned int vdev_id = 0xFFFF;
+	char* bufptr = buf;
+	long rc;
+	int cfg_band;
+	struct cfg80211_chan_def def;
+	char dev_name_match[IFNAMSIZ + 2];
+	struct wireless_dev *wdev;
+	int set_rate_type;
+
+	memset(buf, 0, sizeof(buf));
+
+	simple_write_to_buffer(buf, sizeof(buf) - 1, ppos, user_buf, count);
+
+	/* make sure that buf is null terminated */
+	buf[sizeof(buf) - 1] = 0;
+
+	/* drop the possible '\n' from the end */
+	if (buf[count - 1] == '\n')
+		buf[count - 1] = 0;
+
+	mutex_lock(&ar->conf_mutex);
+
+	/* Ignore empty lines, 'echo' appends them sometimes at least. */
+	if (buf[0] == 0) {
+		ret = count;
+		goto exit;
+	}
+
+	/* String starts with vdev name, ie 'wlan0'  Find the proper vif that
+	 * matches the name.
+	 */
+	list_for_each_entry(arvif, &ar->arvifs, list) {
+		vif = arvif->vif;
+		wdev = ieee80211_vif_to_wdev(vif);
+
+		if (!wdev)
+			continue;
+		snprintf(dev_name_match, sizeof(dev_name_match) - 1, "%s ", wdev->netdev->name);
+		if (strncmp(dev_name_match, buf, strlen(dev_name_match)) == 0) {
+			vdev_id = arvif->vdev_id;
+			bufptr = buf + strlen(dev_name_match);
+			break;
+		}
+	}
+
+	if (vdev_id == 0xFFFF) {
+		ath10k_warn(ar, "set-rate, unknown netdev name: %s\n", buf);
+		ret = -EINVAL;
+		goto exit;
+	}
+
+	/* Now, check the type. */
+	if (strncmp(bufptr, "beacon ", strlen("beacon ")) == 0) {
+		set_rate_type = ar->wmi.vdev_param->mgmt_rate;
+		bufptr += strlen("beacon ");
+	}
+	else if (strncmp(bufptr, "bcast ", strlen("bcast ")) == 0) {
+		set_rate_type = ar->wmi.vdev_param->bcast_data_rate;
+		bufptr += strlen("bcast ");
+	}
+	else if (strncmp(bufptr, "mcast ", strlen("mcast ")) == 0) {
+		set_rate_type = ar->wmi.vdev_param->mcast_data_rate;
+		bufptr += strlen("mcast ");
+	}
+	else {
+		ath10k_warn(ar, "set-rate, invalid rate type: %s\n",
+			    bufptr);
+		ret = -EINVAL;
+		goto exit;
+	}
+
+	/* And the band */
+	if (strncmp(bufptr, "2 ", 2) == 0) {
+		cfg_band = NL80211_BAND_2GHZ;
+		bufptr += 2;
+	}
+	else if (strncmp(bufptr, "5 ", 2) == 0) {
+		cfg_band = NL80211_BAND_5GHZ;
+		bufptr += 2;
+	}
+	else if (strncmp(bufptr, "60 ", 3) == 0) {
+		cfg_band = NL80211_BAND_60GHZ;
+		bufptr += 3;
+	}
+	else {
+		ath10k_warn(ar, "set-rate, invalid band: %s\n",
+			    bufptr);
+		ret = -EINVAL;
+		goto exit;
+	}
+
+	/* Parse the rate-code. */
+	ret = kstrtol(bufptr, 0, &rc);
+	if (ret != 0) {
+		ath10k_warn(ar, "set-rate, invalid rate-code: %s\n", bufptr);
+		goto exit;
+	}
+
+	/* Store the value so we can re-apply it if firmware is restarted. */
+	if (set_rate_type == ar->wmi.vdev_param->mgmt_rate)
+		arvif->mgt_rate[cfg_band] = rc;
+	else if (set_rate_type == ar->wmi.vdev_param->bcast_data_rate)
+		arvif->bcast_rate[cfg_band] = rc;
+	else if (set_rate_type == ar->wmi.vdev_param->mcast_data_rate)
+		arvif->mcast_rate[cfg_band] = rc;
+
+	if (ar->state != ATH10K_STATE_ON &&
+	    ar->state != ATH10K_STATE_RESTARTED) {
+		/* OK, we will set it when vdev comes up */
+		ath10k_warn(ar, "set-rates, deferred-state is down, vdev %i type: 0x%x rc: 0x%lx band: %d\n",
+			    arvif->vdev_id, set_rate_type, rc, cfg_band);
+		goto exit;
+	}
+
+	if (ath10k_mac_vif_chan(vif, &def) == 0) {
+		if (def.chan->band != cfg_band) {
+			/* We stored value, will apply it later if we move to the
+			 * different band.
+			 */
+			ath10k_warn(ar, "set-rates, deferred-other-band, vdev %i type: 0x%x rc: 0x%lx band: %d\n",
+				    arvif->vdev_id, set_rate_type, rc, cfg_band);
+			goto exit;
+		}
+	}
+
+	/* and finally, send results to the firmware. */
+	ret = ath10k_wmi_vdev_set_param(ar, arvif->vdev_id, set_rate_type, rc);
+	if (ret) {
+		ath10k_warn(ar, "set-rates: vdev %i failed to set fixed rate, param 0x%x rate-code 0x%02lx\n",
+			    arvif->vdev_id, set_rate_type, rc);
+		goto exit;
+	}
+
+	ath10k_warn(ar, "set-rates, vdev %i type: 0x%x rc: 0x%lx band: %d\n",
+		    arvif->vdev_id, set_rate_type, rc, cfg_band);
+
+	ret = count;
+
+exit:
+	mutex_unlock(&ar->conf_mutex);
+	return ret;
+}
+
+static const struct file_operations fops_set_rates = {
+	.read = ath10k_read_set_rates,
+	.write = ath10k_write_set_rates,
+	.open = simple_open,
+	.owner = THIS_MODULE,
+	.llseek = default_llseek,
+};
+
+
+static ssize_t ath10k_read_set_rate_override(struct file *file,
+					     char __user *user_buf,
+					     size_t count, loff_t *ppos)
+{
+	struct ath10k *ar = file->private_data;
+	char* buf2;
+	int size=8000;
+	struct ath10k_vif *arvif;
+	struct ieee80211_vif *vif;
+	struct wireless_dev *wdev;
+	int sofar;
+	int rv;
+	const char buf[] =
+		"This allows specify specif tx rate parameters for all DATA frames on a vdev\n"
+		"Only wave-2 CT firmware has full support.  Wave-1 CT firmware has at least\n"
+		"some support (preamble, preamble, mcs, retries).\n"
+		"To set a value, you specify the dev-name and key-value pairs:\n"
+		"tpc=10 sgi=1 mcs=x nss=x pream=x retries=x dynbw=0|1 bw=x enable=0|1\n"
+		"pream: 0=ofdm, 1=cck, 2=HT, 3=VHT\n"
+		"cck-mcs: 0=11Mbps, 1=5.5Mbps, 2=2Mbps, 3=1Mbps\n"
+		"ofdm-mcs: 0=48Mbps, 1=24Mbps, 2=12Mbps, 3=6Mbps, 4=54Mbps, 5=36Mbps, 6=18Mbps, 7=9Mbps\n"
+		"tpc is in 1db increments, 255 means use defaults, bw is 0-3 for 20-160\n"
+		" For example, wlan0:  echo \"wlan0 tpc=255 sgi=1 mcs=0 nss=1 pream=3 retries=1 dynbw=0 bw=0 active=1\" > ...ath10k/set_rate_override\n";
+
+	buf2 = kzalloc(size, GFP_KERNEL);
+	if (buf2 == NULL)
+		return -ENOMEM;
+	strcpy(buf2, buf);
+	sofar = strlen(buf2);
+
+	list_for_each_entry(arvif, &ar->arvifs, list) {
+		vif = arvif->vif;
+		wdev = ieee80211_vif_to_wdev(vif);
+
+		if (!wdev)
+			continue;
+
+		sofar += scnprintf(buf2 + sofar, size - sofar,
+				   "vdev %i(%s) active=%d tpc=%d sgi=%d mcs=%d nss=%d pream=%d retries=%d dynbw=%d bw=%d rix=%d\n",
+				   arvif->vdev_id, wdev->netdev->name,
+				   arvif->txo_active, arvif->txo_tpc, arvif->txo_sgi, arvif->txo_mcs,
+				   arvif->txo_nss, arvif->txo_pream, arvif->txo_retries, arvif->txo_dynbw,
+				   arvif->txo_bw, arvif->txo_rix);
+		if (sofar >= size)
+			break;
+	}
+
+	rv = simple_read_from_buffer(user_buf, count, ppos, buf2, sofar);
+	kfree(buf2);
+	return rv;
+}
+
+/* Set the rates for specific types of traffic.
+ */
+static ssize_t ath10k_write_set_rate_override(struct file *file,
+					      const char __user *user_buf,
+					      size_t count, loff_t *ppos)
+{
+	struct ath10k *ar = file->private_data;
+	char buf[180];
+	char tmp[20];
+	char* tok;
+	int ret;
+	struct ath10k_vif *arvif;
+	struct ieee80211_vif *vif;
+	unsigned int vdev_id = 0xFFFF;
+	char* bufptr = buf;
+	long rc;
+	char dev_name_match[IFNAMSIZ + 2];
+	struct wireless_dev *wdev;
+
+	memset(buf, 0, sizeof(buf));
+
+	simple_write_to_buffer(buf, sizeof(buf) - 1, ppos, user_buf, count);
+
+	/* make sure that buf is null terminated */
+	buf[sizeof(buf) - 1] = 0;
+
+	/* drop the possible '\n' from the end */
+	if (buf[count - 1] == '\n')
+		buf[count - 1] = 0;
+
+	mutex_lock(&ar->conf_mutex);
+
+	/* Ignore empty lines, 'echo' appends them sometimes at least. */
+	if (buf[0] == 0) {
+		ret = count;
+		goto exit;
+	}
+
+	/* String starts with vdev name, ie 'wlan0'  Find the proper vif that
+	 * matches the name.
+	 */
+	list_for_each_entry(arvif, &ar->arvifs, list) {
+		vif = arvif->vif;
+		wdev = ieee80211_vif_to_wdev(vif);
+
+		if (!wdev)
+			continue;
+		snprintf(dev_name_match, sizeof(dev_name_match) - 1, "%s ", wdev->netdev->name);
+		if (strncmp(dev_name_match, buf, strlen(dev_name_match)) == 0) {
+			vdev_id = arvif->vdev_id;
+			bufptr = buf + strlen(dev_name_match) - 1;
+			break;
+		}
+	}
+
+	if (vdev_id == 0xFFFF) {
+		if (strstr(buf, "active=0")) {
+			/* Ignore, we are disabling it anyway */
+			ret = count;
+			goto exit;
+		}
+		else {
+			ath10k_warn(ar, "set-rate-override, unknown netdev name: %s\n", buf);
+		}
+		ret = -EINVAL;
 		goto exit;
 	}
 
+#define ATH10K_PARSE_LTOK(a) \
+	if ((tok = strstr(bufptr, " " #a "="))) {			\
+		char* tspace;						\
+		tok += 1; /* move past initial space */			\
+		strncpy(tmp, tok + strlen(#a "="), sizeof(tmp) - 1);	\
+		tmp[sizeof(tmp) - 1] = 0;				\
+		tspace = strstr(tmp, " ");				\
+		if (tspace) { *tspace = 0; }				\
+		if (kstrtol(tmp, 0, &rc) != 0) {			\
+			ath10k_warn(ar, "set-rate-override: " #a "= could not be parsed, tmp: %s\n", tmp); \
+		}							\
+		else {							\
+			arvif->txo_##a = rc;				\
+		}							\
+	}
+
+	ATH10K_PARSE_LTOK(tpc);
+	ATH10K_PARSE_LTOK(sgi);
+	ATH10K_PARSE_LTOK(mcs);
+	ATH10K_PARSE_LTOK(nss);
+	ATH10K_PARSE_LTOK(pream);
+	ATH10K_PARSE_LTOK(retries);
+	ATH10K_PARSE_LTOK(dynbw);
+	ATH10K_PARSE_LTOK(bw);
+	ATH10K_PARSE_LTOK(rix);
+	ATH10K_PARSE_LTOK(active);
+
+	ath10k_warn(ar, "set-rate-overrides, vdev %i(%s) active=%d tpc=%d sgi=%d mcs=%d nss=%d pream=%d retries=%d dynbw=%d bw=%d rix=%d\n",
+		    arvif->vdev_id, dev_name_match,
+		    arvif->txo_active, arvif->txo_tpc, arvif->txo_sgi, arvif->txo_mcs,
+		    arvif->txo_nss, arvif->txo_pream, arvif->txo_retries, arvif->txo_dynbw,
+		    arvif->txo_bw, arvif->txo_rix);
+
 	ret = count;
 
 exit:
@@ -602,9 +1746,9 @@
 	return ret;
 }
 
-static const struct file_operations fops_simulate_fw_crash = {
-	.read = ath10k_read_simulate_fw_crash,
-	.write = ath10k_write_simulate_fw_crash,
+static const struct file_operations fops_set_rate_override = {
+	.read = ath10k_read_set_rate_override,
+	.write = ath10k_write_set_rate_override,
 	.open = simple_open,
 	.owner = THIS_MODULE,
 	.llseek = default_llseek,
@@ -740,6 +1884,87 @@
 	return ret;
 }
 
+static void ath10k_dbg_drop_dbg_buffer(struct ath10k *ar)
+{
+	/* Find next message boundary */
+	u32 lg_hdr;
+	unsigned int acnt;
+	int tail_idx = ar->debug.dbglog_entry_data.tail_idx;
+	int h_idx = (tail_idx + 1) % ATH10K_DBGLOG_DATA_LEN;
+
+	lockdep_assert_held(&ar->data_lock);
+
+	/* Log header is second 32-bit word */
+	lg_hdr = le32_to_cpu(ar->debug.dbglog_entry_data.data[h_idx]);
+
+	acnt = (lg_hdr & DBGLOG_NUM_ARGS_MASK) >> DBGLOG_NUM_ARGS_OFFSET;
+
+	if (acnt > DBGLOG_NUM_ARGS_MAX) {
+		/* Some sort of corruption it seems, recover as best we can. */
+		ath10k_err(ar, "invalid dbglog arg-count: %i %i %i\n",
+			   acnt, ar->debug.dbglog_entry_data.tail_idx,
+			   ar->debug.dbglog_entry_data.head_idx);
+		ar->debug.dbglog_entry_data.tail_idx =
+			ar->debug.dbglog_entry_data.head_idx;
+		return;
+	}
+
+	/* Move forward over the args and the two header fields */
+	ar->debug.dbglog_entry_data.tail_idx =
+		(tail_idx + acnt + 2) % ATH10K_DBGLOG_DATA_LEN;
+}
+
+void ath10k_dbg_save_fw_dbg_buffer(struct ath10k *ar, __le32 *buffer, int len)
+{
+	int i;
+	int z;
+	u32 lg_hdr = 0;
+	unsigned int acnt = 0;
+
+	lockdep_assert_held(&ar->data_lock);
+
+	/* Make sure input is sane */
+	i = 0;
+	while (i < len) {
+		lg_hdr = le32_to_cpu(buffer[i + 1]);
+		acnt = (lg_hdr & DBGLOG_NUM_ARGS_MASK) >> DBGLOG_NUM_ARGS_OFFSET;
+
+		if (acnt > DBGLOG_NUM_ARGS_MAX) {
+		bad:
+			ath10k_err(ar, "Invalid fw-dbg-buffer, hdr-at[%i], len: %d arg-len: %d  hdr: 0x%x\n",
+				   i + 1, len, acnt, lg_hdr);
+			for (i = 0; i<len; i++) {
+				ath10k_err(ar, "buffer[%i] 0x%x\n", i, le32_to_cpu(buffer[i]));
+			}
+			return;
+		}
+		i += 2 + acnt;
+	}
+
+	/* Some trailing garbage? */
+	if (i != len)
+		goto bad;
+
+	z = ar->debug.dbglog_entry_data.head_idx;
+
+	for (i = 0; i < len; i++) {
+		ar->debug.dbglog_entry_data.data[z] = buffer[i];
+		z++;
+		if (z >= ATH10K_DBGLOG_DATA_LEN)
+			z = 0;
+
+		/* If we are about to over-write an old message, move the
+		 * tail_idx to the next message.  If idx's are same, we
+		 * are empty.
+		 */
+		if (z == ar->debug.dbglog_entry_data.tail_idx)
+			ath10k_dbg_drop_dbg_buffer(ar);
+
+		ar->debug.dbglog_entry_data.head_idx = z;
+	}
+}
+EXPORT_SYMBOL(ath10k_dbg_save_fw_dbg_buffer);
+
 static const struct file_operations fops_reg_value = {
 	.read = ath10k_reg_value_read,
 	.write = ath10k_reg_value_write,
@@ -900,6 +2125,32 @@
 	mutex_unlock(&ar->conf_mutex);
 }
 
+static void ath10k_debug_nop_dwork(struct work_struct *work)
+{
+	struct ath10k *ar = container_of(work, struct ath10k,
+					 debug.nop_dwork.work);
+
+	mutex_lock(&ar->conf_mutex);
+
+	if (ar->state == ATH10K_STATE_ON) {
+		int ret = ath10k_wmi_request_nop(ar);
+		if (ret) {
+			ath10k_warn(ar, "failed to send wmi nop: %d\n", ret);
+		}
+
+		/* big hack, grab noise-floor stats too so that we can use them to
+		 * report more accurate RSSI.
+		 */
+		ath10k_refresh_target_pdev_ext_ct_stats(ar);
+	}
+
+	/* Re-arm periodic work. */
+	queue_delayed_work(ar->workqueue, &ar->debug.nop_dwork,
+			   msecs_to_jiffies(ATH10K_DEBUG_NOP_INTERVAL));
+
+	mutex_unlock(&ar->conf_mutex);
+}
+
 static ssize_t ath10k_read_htt_stats_mask(struct file *file,
 					  char __user *user_buf,
 					  size_t count, loff_t *ppos)
@@ -1076,6 +2327,129 @@
 	return ret;
 }
 
+static ssize_t ath10k_read_ratepwr(struct file *file,
+				   char __user *user_buf,
+				   size_t count, loff_t *ppos)
+{
+	struct ath10k *ar = file->private_data;
+	int size = 8000;
+	u8 *buf = kzalloc(size, GFP_KERNEL);
+	int retval = 0, len = 0;
+	int mx = sizeof(ar->debug.ratepwr_tbl.data) / 4;
+	int i;
+
+	if (buf == NULL)
+		return -ENOMEM;
+
+	/* TODO:  Locking? */
+
+	if (ar->state == ATH10K_STATE_ON) {
+		unsigned long time_left;
+		int ret;
+
+		reinit_completion(&ar->debug.ratepwr_tbl_complete);
+
+		ret = ath10k_wmi_request_ratepwr_tbl(ar);
+		if (ret) {
+			ath10k_warn(ar, "could not request ratepwr table: ret %d\n",
+				    ret);
+			time_left = 1;
+		}
+		else {
+			time_left = wait_for_completion_timeout(&ar->debug.ratepwr_tbl_complete, 1*HZ);
+		}
+
+		/* ath10k_warn(ar, "Requested ratepwr (type 0x%x ret %d specifier %d jiffies: %lu  time-left: %lu)\n",
+		   type, ret, specifier, jiffies, time_left);*/
+
+		if (time_left == 0)
+			ath10k_warn(ar, "Timeout requesting ratepwr table.\n");
+	}
+
+	len += scnprintf(buf + len, size - len, "RatePower table, length: %d\n",
+			 ar->debug.ratepwr_tbl_len);
+	for (i = 0; i<mx; i++) {
+		len += scnprintf(buf + len, size - len, "%08x ", ar->debug.ratepwr_tbl.data[i]);
+		if (((i + 1) % 8) == 0)
+			buf[len - 1] = '\n';
+	}
+	buf[len - 1] = '\n';
+
+	retval = simple_read_from_buffer(user_buf, count, ppos, buf, len);
+	kfree(buf);
+
+	return retval;
+}
+
+static const struct file_operations fops_ratepwr_table = {
+	.read = ath10k_read_ratepwr,
+	.open = simple_open,
+	.owner = THIS_MODULE,
+	.llseek = default_llseek,
+};
+
+static ssize_t ath10k_read_powerctl(struct file *file,
+				    char __user *user_buf,
+				    size_t count, loff_t *ppos)
+{
+	struct ath10k *ar = file->private_data;
+	int size = 8000;
+	u8 *buf = kzalloc(size, GFP_KERNEL);
+	int retval = 0, len = 0;
+	int mx = sizeof(ar->debug.powerctl_tbl.data) / 4;
+	int i;
+
+	if (buf == NULL)
+		return -ENOMEM;
+
+	/* TODO:  Locking? */
+
+	if (ar->state == ATH10K_STATE_ON) {
+		unsigned long time_left;
+		int ret;
+
+		reinit_completion(&ar->debug.powerctl_tbl_complete);
+
+		ret = ath10k_wmi_request_powerctl_tbl(ar);
+		if (ret) {
+			ath10k_warn(ar, "could not request powerctl table: ret %d\n",
+				    ret);
+			time_left = 1;
+		}
+		else {
+			time_left = wait_for_completion_timeout(&ar->debug.powerctl_tbl_complete, 1*HZ);
+		}
+
+		/* ath10k_warn(ar, "Requested powerctl (type 0x%x ret %d specifier %d jiffies: %lu  time-left: %lu)\n",
+		   type, ret, specifier, jiffies, time_left);*/
+
+		if (time_left == 0)
+			ath10k_warn(ar, "Timeout requesting powerctl table.\n");
+	}
+
+	len += scnprintf(buf + len, size - len, "PowerCtl table, length: %d\n",
+			 ar->debug.powerctl_tbl_len);
+	for (i = 0; i<mx; i++) {
+		len += scnprintf(buf + len, size - len, "%08x ", ar->debug.powerctl_tbl.data[i]);
+		if (((i + 1) % 8) == 0)
+			buf[len - 1] = '\n';
+	}
+	buf[len - 1] = '\n';
+
+	retval = simple_read_from_buffer(user_buf, count, ppos, buf, len);
+	kfree(buf);
+
+	return retval;
+}
+
+static const struct file_operations fops_powerctl_table = {
+	.read = ath10k_read_powerctl,
+	.open = simple_open,
+	.owner = THIS_MODULE,
+	.llseek = default_llseek,
+};
+
+
 /* TODO:  Would be nice to always support ethtool stats, would need to
  * move the stats storage out of ath10k_debug, or always have ath10k_debug
  * struct available..
@@ -1083,12 +2457,22 @@
 
 /* This generally cooresponds to the debugfs fw_stats file */
 static const char ath10k_gstrings_stats[][ETH_GSTRING_LEN] = {
-	"tx_pkts_nic",
-	"tx_bytes_nic",
-	"rx_pkts_nic",
-	"rx_bytes_nic",
+	"tx_hw_reaped", /* from firmware, tx-pkts count */
+	"tx_pkts_nic", /* from driver, tx-ok pkts */
+	"tx_bytes_nic", /* from driver, tx-ok bytes */
+	"tx_bytes_to_fw", /* sent to firmware, counts all failures */
+	"rx_pkts_nic", /* From firmware...maybe should be from driver for symmetry? */
+	"rx_bytes_nic", /* from driver, firmware does not keep this stat. */
+	"rx_drop_unchain_oom", /* Dropped due to OOM pressure in unchain_msdu path */
+	"rx_drop_decap_non_raw_chained",
+	"rx_drop_no_freq",
+	"rx_drop_cac_running",
 	"d_noise_floor",
-	"d_cycle_count",
+	"d_cycle_count", /* this is duty cycle counter, basically channel-time. 88MHz clock */
+	"d_tx_cycle_count", /* tx cycle count */
+	"d_rx_cycle_count", /* rx cycle count */
+	"d_busy_count", /* Total channel busy time cycles (called 'clear' by firmware) */
+	"d_flags", /* 0x1:  hw has shifted cycle-count wrap, see ath10k_hw_fill_survey_time */
 	"d_phy_error",
 	"d_rts_bad",
 	"d_rts_good",
@@ -1108,6 +2492,10 @@
 	"d_tx_excessive_retries",
 	"d_tx_hw_rate",
 	"d_tx_dropped_sw_retries",
+	"d_tx_noack", /* reported by driver */
+	"d_tx_noack_bytes", /* reported by driver */
+	"d_tx_discard", /* reported by driver */
+	"d_tx_discard_bytes", /* reported by driver */
 	"d_tx_illegal_rate",
 	"d_tx_continuous_xretries",
 	"d_tx_timeout",
@@ -1129,6 +2517,10 @@
 	"d_fw_crash_count",
 	"d_fw_warm_reset_count",
 	"d_fw_cold_reset_count",
+	"d_fw_powerup_failed", /* boolean */
+	"d_short_tx_retries", /* RTS tx retries */
+	"d_long_tx_retries", /* DATA tx retries */
+	"d_fw_adc_temp", /* ADC Temperature readings. */
 };
 
 #define ATH10K_SSTATS_LEN ARRAY_SIZE(ath10k_gstrings_stats)
@@ -1151,18 +2543,23 @@
 	return 0;
 }
 
-void ath10k_debug_get_et_stats(struct ieee80211_hw *hw,
-			       struct ieee80211_vif *vif,
-			       struct ethtool_stats *stats, u64 *data)
+void ath10k_debug_get_et_stats2(struct ieee80211_hw *hw,
+				struct ieee80211_vif *vif,
+				struct ethtool_stats *stats, u64 *data, u32 level)
 {
 	struct ath10k *ar = hw->priv;
 	static const struct ath10k_fw_stats_pdev zero_stats = {};
 	const struct ath10k_fw_stats_pdev *pdev_stats;
 	int i = 0, ret;
+	u64 d_flags = 0;
 
 	mutex_lock(&ar->conf_mutex);
 
+	if (level && level < 5)
+		goto skip_query_fw_stats;
+
 	if (ar->state == ATH10K_STATE_ON) {
+		ath10k_refresh_target_regs(ar); /* Request some CT FW stats. */
 		ret = ath10k_debug_fw_stats_request(ar);
 		if (ret) {
 			/* just print a warning and try to use older results */
@@ -1172,6 +2569,7 @@
 		}
 	}
 
+skip_query_fw_stats:
 	pdev_stats = list_first_entry_or_null(&ar->debug.fw_stats.pdevs,
 					      struct ath10k_fw_stats_pdev,
 					      list);
@@ -1182,12 +2580,25 @@
 
 	spin_lock_bh(&ar->data_lock);
 
+	if (ar->hw_params.cc_wraparound_type == ATH10K_HW_CC_WRAP_SHIFTED_ALL)
+		d_flags |= 0x1;
+
 	data[i++] = pdev_stats->hw_reaped; /* ppdu reaped */
-	data[i++] = 0; /* tx bytes */
+	data[i++] = ar->debug.tx_ok;
+	data[i++] = ar->debug.tx_ok_bytes;
+	data[i++] = ar->debug.tx_bytes;
 	data[i++] = pdev_stats->htt_mpdus;
-	data[i++] = 0; /* rx bytes */
+	data[i++] = ar->debug.rx_bytes;
+	data[i++] = ar->debug.rx_drop_unchain_oom;
+	data[i++] = ar->debug.rx_drop_decap_non_raw_chained;
+	data[i++] = ar->debug.rx_drop_no_freq;
+	data[i++] = ar->debug.rx_drop_cac_running;
 	data[i++] = pdev_stats->ch_noise_floor;
 	data[i++] = pdev_stats->cycle_count;
+	data[i++] = pdev_stats->tx_frame_count;
+	data[i++] = pdev_stats->rx_frame_count;
+	data[i++] = pdev_stats->rx_clear_count; /* yes, this appears to actually be 'busy' count */
+	data[i++] = d_flags; /* give user-space a chance to decode cycle counters */
 	data[i++] = pdev_stats->phy_err_count;
 	data[i++] = pdev_stats->rts_bad;
 	data[i++] = pdev_stats->rts_good;
@@ -1207,6 +2618,10 @@
 	data[i++] = pdev_stats->tx_ko;
 	data[i++] = pdev_stats->data_rc;
 	data[i++] = pdev_stats->sw_retry_failure;
+	data[i++] = ar->debug.tx_noack;
+	data[i++] = ar->debug.tx_noack_bytes;
+	data[i++] = ar->debug.tx_discard;
+	data[i++] = ar->debug.tx_discard_bytes;
 	data[i++] = pdev_stats->illgl_rate_phy_err;
 	data[i++] = pdev_stats->pdev_cont_xretry;
 	data[i++] = pdev_stats->pdev_tx_timeout;
@@ -1228,6 +2643,10 @@
 	data[i++] = ar->stats.fw_crash_counter;
 	data[i++] = ar->stats.fw_warm_reset_counter;
 	data[i++] = ar->stats.fw_cold_reset_counter;
+	data[i++] = ar->fw_powerup_failed;
+	data[i++] = ar->debug.fw_stats.short_retries;
+	data[i++] = ar->debug.fw_stats.long_retries;
+	data[i++] = ar->debug.fw_stats.adc_temp;
 
 	spin_unlock_bh(&ar->data_lock);
 
@@ -1236,6 +2655,14 @@
 	WARN_ON(i != ATH10K_SSTATS_LEN);
 }
 
+void ath10k_debug_get_et_stats(struct ieee80211_hw *hw,
+                              struct ieee80211_vif *vif,
+                              struct ethtool_stats *stats, u64 *data)
+{
+       ath10k_debug_get_et_stats2(hw, vif, stats, data, 0);
+}
+
+
 static const struct file_operations fops_fw_dbglog = {
 	.read = ath10k_read_fw_dbglog,
 	.write = ath10k_write_fw_dbglog,
@@ -1401,8 +2828,21 @@
 		return -EINVAL;
 
 	/* there's no way to switch back to the firmware default */
-	if (period == 0)
-		return -EINVAL;
+	if (period == 0) {
+		/* if CT an 10.1 firmware, then it OK to set 0 */
+		if ((ar->running_fw->fw_file.wmi_op_version == ATH10K_FW_WMI_OP_VERSION_10_1) &&
+		    (test_bit(ATH10K_FW_FEATURE_CUST_STATS_CT, ar->running_fw->fw_file.fw_features))) {
+			/* wave-1 CT firmware (since March 11, 2020), will let you set the period
+			 * to zero (0) to disable calibration.  Older CT firmware will just ignore this
+			 * setting anyway.
+			 */
+			ath10k_warn(ar, "Disabling calibration (period == 0)\n");
+		}
+		else {
+			ath10k_warn(ar, "Calibration period of zero is not allowed on this firmware.\n");
+			return -EINVAL;
+		}
+	}
 
 	mutex_lock(&ar->conf_mutex);
 
@@ -1417,8 +2857,8 @@
 	ret = ath10k_wmi_pdev_set_param(ar, ar->wmi.pdev_param->cal_period,
 					ar->debug.nf_cal_period);
 	if (ret) {
-		ath10k_warn(ar, "cal period cfg failed from debugfs: %d\n",
-			    ret);
+		ath10k_warn(ar, "cal period %ld cfg failed from debugfs: %d\n",
+			    period, ret);
 		goto exit;
 	}
 
@@ -1493,13 +2933,13 @@
 {
 	int i;
 	size_t buf_len;
-	static const char table_str[][5] = { "CDD",
+	static const char table_str[][5] = { " CDD",
 					     "STBC",
 					     "TXBF" };
-	static const char pream_str[][6] = { "CCK",
-					     "OFDM",
-					     "HT20",
-					     "HT40",
+	static const char pream_str[][6] = { "  CCK",
+					     " OFDM",
+					     " HT20",
+					     " HT40",
 					     "VHT20",
 					     "VHT40",
 					     "VHT80",
@@ -1507,12 +2947,12 @@
 
 	buf_len = ATH10K_TPC_CONFIG_BUF_SIZE;
 	*len += scnprintf(buf + *len, buf_len - *len,
-			  "********************************\n");
+			  "*****************************************************\n");
 	*len += scnprintf(buf + *len, buf_len - *len,
 			  "******************* %s POWER TABLE ****************\n",
 			  table_str[j]);
 	*len += scnprintf(buf + *len, buf_len - *len,
-			  "********************************\n");
+			  "*****************************************************\n");
 	*len += scnprintf(buf + *len, buf_len - *len,
 			  "No.  Preamble Rate_code ");
 
@@ -1524,14 +2964,13 @@
 
 	for (i = 0; i < tpc_stats->rate_max; i++) {
 		*len += scnprintf(buf + *len, buf_len - *len,
-				  "%8d %s 0x%2x %s\n", i,
+				  "%3d     %s   0x%2x %s\n", i,
 				  pream_str[tpc_stats->tpc_table[j].pream_idx[i]],
 				  tpc_stats->tpc_table[j].rate_code[i],
 				  tpc_stats->tpc_table[j].tpc_value[i]);
 	}
 
-	*len += scnprintf(buf + *len, buf_len - *len,
-			  "***********************************\n");
+	*len += scnprintf(buf + *len, buf_len - *len, "\n\n");
 }
 
 static void ath10k_tpc_stats_fill(struct ath10k *ar,
@@ -1692,6 +3131,21 @@
 
 	lockdep_assert_held(&ar->conf_mutex);
 
+	/* initilize this to defaults */
+	ar->debug.nf_sum[0] = 0x80;
+	ar->debug.nf_sum[1] = 0x80;
+	ar->debug.nf_sum[2] = 0x80;
+	ar->debug.nf_sum[3] = 0x80;
+
+	ar->debug.pdev_ext_stats.chan_nf_0 = 0x80;
+	ar->debug.pdev_ext_stats.chan_nf_1 = 0x80;
+	ar->debug.pdev_ext_stats.chan_nf_2 = 0x80;
+	ar->debug.pdev_ext_stats.chan_nf_3 = 0x80;
+
+	ar->debug.pdev_ext_stats.chan_nf_sec80_1 = 0x80;
+	ar->debug.pdev_ext_stats.chan_nf_sec80_2 = 0x80;
+	ar->debug.pdev_ext_stats.chan_nf_sec80_3 = 0x80;
+
 	ret = ath10k_debug_htt_stats_req(ar);
 	if (ret)
 		/* continue normally anyway, this isn't serious */
@@ -1734,6 +3188,9 @@
 				    ret);
 	}
 
+	queue_delayed_work(ar->workqueue, &ar->debug.nop_dwork,
+			   msecs_to_jiffies(ATH10K_DEBUG_NOP_INTERVAL));
+
 	return ret;
 }
 
@@ -1752,6 +3209,8 @@
 	if (ar->debug.htt_stats_mask != 0)
 		cancel_delayed_work(&ar->debug.htt_stats_dwork);
 
+	cancel_delayed_work(&ar->debug.nop_dwork);
+
 	ath10k_wmi_pdev_pktlog_disable(ar);
 }
 
@@ -1827,6 +3286,9 @@
 	ATH10K_DFS_POOL_STAT("Seqs. alloc error", pseq_alloc_error);
 	ATH10K_DFS_POOL_STAT("Seqs. in use", pseq_used);
 
+	len += scnprintf(buf + len, size - len, "Last-DFS-Msg: %s\n",
+			 ar->debug.dfs_last_msg);
+
 exit:
 	if (len > size)
 		len = size;
@@ -1912,6 +3374,342 @@
 	.open = simple_open
 };
 
+static ssize_t ath10k_write_thresh62_ext(struct file *file,
+					 const char __user *ubuf,
+					 size_t count, loff_t *ppos)
+{
+	struct ath10k *ar = file->private_data;
+	u8 val;
+	int ret = 0;
+
+	if (kstrtou8_from_user(ubuf, count, 0, &val))
+		return -EINVAL;
+
+	mutex_lock(&ar->conf_mutex);
+	ar->eeprom_overrides.thresh62_ext = val;
+	ret = ath10k_wmi_pdev_set_special(ar, SET_SPECIAL_ID_THRESH62_EXT, val);
+	mutex_unlock(&ar->conf_mutex);
+
+	return ret ?: count;
+}
+
+static ssize_t ath10k_read_thresh62_ext(struct file *file,
+					char __user *ubuf,
+					size_t count, loff_t *ppos)
+{
+	char buf[32];
+	struct ath10k *ar = file->private_data;
+	int len = 0;
+
+	mutex_lock(&ar->conf_mutex);
+	len = scnprintf(buf, sizeof(buf) - len, "%d\n",
+			ar->eeprom_overrides.thresh62_ext);
+	mutex_unlock(&ar->conf_mutex);
+
+	return simple_read_from_buffer(ubuf, count, ppos, buf, len);
+}
+
+static const struct file_operations fops_thresh62_ext = {
+	.read = ath10k_read_thresh62_ext,
+	.write = ath10k_write_thresh62_ext,
+	.open = simple_open
+};
+
+static ssize_t ath10k_write_ct_special(struct file *file,
+				       const char __user *ubuf,
+				       size_t count, loff_t *ppos)
+{
+	struct ath10k *ar = file->private_data;
+	u64 tmp;
+	u32 id;
+	u32 val;
+	int ret = 0;
+
+	if (kstrtou64_from_user(ubuf, count, 0, &tmp))
+		return -EINVAL;
+
+	id = tmp >> 32;
+	val = tmp & 0xFFFFFFFF;
+
+	mutex_lock(&ar->conf_mutex);
+	if (id == SET_SPECIAL_ID_ACK_CTS) {
+		ar->eeprom_overrides.reg_ack_cts = val;
+	}
+	else if (id == SET_SPECIAL_ID_SLOT) {
+		ar->eeprom_overrides.reg_ifs_slot = val;
+	}
+	else if (id == SET_SPECIAL_ID_THRESH62_EXT) {
+		ar->eeprom_overrides.thresh62_ext = val;
+	}
+	else if (id == SET_SPECIAL_ID_NOISE_FLR_THRESH) {
+		u8 band = val >> 24;
+		u8 type = (val >> 16) & 0xFF;
+		if ((band > 2) || (type > CT_CCA_TYPE_MAX)) {
+			ret = -EINVAL;
+			goto unlock;
+		}
+		if (type <= CT_CCA_TYPE_MIN2)
+			ar->eeprom_overrides.bands[band].minCcaPwrCT[type] = val & 0xFFFF;
+		else if (type == CT_CCA_TYPE_NOISE_FLOOR)
+			ar->eeprom_overrides.bands[band].noiseFloorThresh = val & 0xFFFF;
+		else if (type == CT_CCA_TYPE_EN_MINCCAPWR)
+			ar->eeprom_overrides.bands[band].enable_minccapwr_thresh = val & 0xFFFF;
+	}
+	else if (id == SET_SPECIAL_ID_IBSS_AMSDU_OK) {
+		ar->eeprom_overrides.allow_ibss_amsdu = !!val;
+		ath10k_warn(ar, "Setting ibss-amsdu-ok to %d\n",
+			    ar->eeprom_overrides.allow_ibss_amsdu);
+	}
+	else if (id == SET_SPECIAL_ID_MAX_TXPOWER) {
+		/* This can only be set once, and is designed to be
+		 * a way to try to ensure that no other tools can
+		 * accidently or otherwise set the power in the firmware
+		 * higher.
+		 */
+		if (ar->eeprom_overrides.max_txpower == 0xFFFF) {
+			ar->eeprom_overrides.max_txpower = val;
+			ath10k_warn(ar, "Latching max-txpower to: %d (%d dBm)\n", val, val/2);
+		}
+		else {
+			ath10k_err(ar, "Cannot re-set max-txpower, old: %d  new: %d (%d dBm)\n",
+				   ar->eeprom_overrides.max_txpower, val, val/2);
+			ret = -EPERM;
+			goto unlock;
+		}
+	}
+	else if (id == SET_SPECIAL_ID_RC_MAX_PER_THR) {
+		ar->eeprom_overrides.rc_rate_max_per_thr = val;
+		ath10k_warn(ar, "Setting rc-max-per-threshold to %d\n",
+			    ar->eeprom_overrides.rc_rate_max_per_thr);
+	}
+	else if (id == SET_SPECIAL_ID_STA_TXBW_MASK) {
+		/* Specify Station tx bandwidth mask (20, 40, 80Mhz). */
+		ar->eeprom_overrides.tx_sta_bw_mask = val;
+		ath10k_warn(ar, "Setting sta-tx-bw-mask to 0x%x\n", val);
+	}
+	else if (id == SET_SPECIAL_ID_PDEV_XRETRY_TH) {
+		/* Set the threshold for resetting phy due to failed retries, U16 */
+		ar->eeprom_overrides.pdev_xretry_th = val;
+		ath10k_warn(ar, "Setting pdev-xretry-th to 0x%x\n", val);
+	}
+	else if (id == SET_SPECIAL_ID_RIFS_ENABLE) {
+		/* Enable(1)/disable(0) baseband RIFS. */
+		ar->eeprom_overrides.rifs_enable_override = val;
+		ath10k_warn(ar, "Setting RIFS enable override to 0x%x\n", val);
+	}
+	else if (id == SET_SPECIAL_ID_WMI_WD) {
+		ar->eeprom_overrides.wmi_wd_keepalive_ms = val;
+		ath10k_warn(ar, "Setting WMI WD to 0x%x\n", val);
+		if (val == 0)
+			goto unlock; /* 0 means don't set */
+
+		if (val == 0xFFFFFFFF)
+			val = 0; /* 0xFFFFFFFF means disable, FW uses 0 to mean disable */
+	}
+	else if (id == SET_SPECIAL_ID_PSHACK) {
+		ar->eeprom_overrides.ct_pshack = val;
+		ath10k_warn(ar, "Setting CT-PSHACK override to 0x%x\n", val);
+	}
+	else if (id == SET_SPECIAL_ID_CSI) {
+		ar->eeprom_overrides.ct_csi = val;
+		ath10k_warn(ar, "Setting CT-CSI dump override to 0x%x\n", val);
+	}
+	else if (id == SET_SPECIAL_ID_BW_DISABLE_MASK) {
+		/* Set bandwidth-disable mask */
+		ar->eeprom_overrides.rate_bw_disable_mask = val;
+
+		ath10k_warn(ar, "Setting pdev rate-bw-disable-mask to 0x%x.  Will take effect next time rates are configured.\n",
+			    val);
+	}
+	else if (id == SET_SPECIAL_ID_TXBF_CV_MSG) {
+		ar->eeprom_overrides.txbf_cv_msg = val;
+
+		ath10k_warn(ar, "Setting pdev txbf-cv-msg to 0x%x.\n",
+			    val);
+	}
+	else if (id == SET_SPECIAL_ID_RX_ALL_MGT) {
+		ar->eeprom_overrides.rx_all_mgt = val;
+
+		ath10k_warn(ar, "Setting pdev rx-all-mgt to 0x%x.\n",
+			    val);
+	}
+	else if (id == SET_SPECIAL_ID_TX_HANG_COLD_RESET) {
+		ar->eeprom_overrides.tx_hang_cold_reset_ok = !!val;
+		ath10k_warn(ar, "Setting tx-hang-cold-reset-ok to %d\n",
+			    ar->eeprom_overrides.tx_hang_cold_reset_ok);
+	}
+	else if (id == SET_SPECIAL_ID_DISABLE_IBSS_CCA) {
+		ar->eeprom_overrides.disable_ibss_cca = val;
+		ath10k_warn(ar, "Setting disable-ibss-cca to %d\n",
+			    ar->eeprom_overrides.disable_ibss_cca);
+	}
+	else if (id == SET_SPECIAL_ID_RC_DBG) {
+		/* Set Rate-Ctrl debugging */
+		ar->eeprom_overrides.rc_debug = val;
+
+		ath10k_warn(ar, "Setting firmware rc-debug to 0x%x.\n", val);
+	}
+	else if (id == SET_SPECIAL_ID_TX_DBG) {
+		/* Set TX debugging */
+		ar->eeprom_overrides.tx_debug = val;
+
+		ath10k_warn(ar, "Setting firmware tx-debug to 0x%x.\n", val);
+	}
+	else if (id == SET_SPECIAL_ID_PEER_CT_ANTMASK) {
+		/* Not stored in driver, will not be restored upon FW crash/restart */
+		ath10k_warn(ar, "Setting ct-andmask for peer: %d to 0x%x.\n", val >> 16, val & 0x16);
+	}
+	else if (id == SET_SPECIAL_ID_EEPROM_CFG_ADDR_A) {
+		/* Not stored in driver, will not be restored upon FW crash/restart */
+		ath10k_warn(ar, "Adding EEPROM configAddr address setting 0x08%x.\n", val);
+	}
+	else if (id == SET_SPECIAL_ID_EEPROM_CFG_ADDR_V) {
+		/* Not stored in driver, will not be restored upon FW crash/restart */
+		ath10k_warn(ar, "Adding EEPROM configAddr value setting 0x08%x.\n", val);
+	}
+	else if (id == SET_SPECIAL_ID_PEER_STATS_PN) {
+		ar->eeprom_overrides.peer_stats_pn = val;
+		ath10k_warn(ar, "Setting peer-stats-pn to %d\n",
+			    ar->eeprom_overrides.peer_stats_pn);
+	}
+	/* Below here are local driver hacks, and not necessarily passed directly to firmware. */
+	else if (id == 0x1001) {
+		/* Set station failed-transmit kickout threshold. */
+		ar->sta_xretry_kickout_thresh = val;
+
+		ath10k_warn(ar, "Setting pdev sta-xretry-kickout-thresh to 0x%x\n",
+			    val);
+
+		ath10k_mac_set_pdev_kickout(ar);
+		goto unlock;
+	}
+	else if (id == 0x1002) {
+		/* Set SU sounding frame timer. */
+		ar->eeprom_overrides.su_sounding_timer_ms = val;
+
+		ath10k_warn(ar, "Setting pdev su-sounding-timer-ms to 0x%x\n",
+			    val);
+
+		ath10k_wmi_pdev_set_param(ar, ar->wmi.pdev_param->txbf_sound_period_cmdid,
+					  ar->eeprom_overrides.su_sounding_timer_ms);
+		goto unlock;
+	}
+	else if (id == 0x1003) {
+		/* Set MU sounding frame timer. */
+		ar->eeprom_overrides.mu_sounding_timer_ms = val;
+
+		ath10k_warn(ar, "Setting pdev mu-sounding-timer-ms to 0x%x\n",
+			    val);
+
+		/* Search for WMI_FWTEST_CMDID in core.c */
+		ath10k_wmi_pdev_set_fwtest(ar, 81,
+					  ar->eeprom_overrides.mu_sounding_timer_ms);
+		goto unlock;
+	}
+	else if (id == 0x1004) {
+		/* Set rc-txbf-probe. */
+		ar->eeprom_overrides.rc_txbf_probe = val;
+
+		ath10k_warn(ar, "Setting pdev rc-txbf-probe to 0x%x\n",
+			    ar->eeprom_overrides.rc_txbf_probe);
+
+		/* Search for WMI_FWTEST_CMDID in core.c */
+		ath10k_wmi_pdev_set_fwtest(ar, 20,
+					  ar->eeprom_overrides.rc_txbf_probe);
+		goto unlock;
+	}
+	else if (id == 0x1005) {
+		/* Over-write power-ctl table with what was ready in from the board data */
+		/* Use with care! */
+		ar->eeprom_overrides.apply_board_power_ctl_table = val;
+
+		ath10k_warn(ar, "Setting overwrite power-ctl table with calibration-file data to: %d\n",
+			    ar->eeprom_overrides.apply_board_power_ctl_table);
+
+		ath10k_wmi_check_apply_board_power_ctl_table(ar);
+		goto unlock;
+	}
+	/* else, pass it through to firmware...but will not be stored locally, so
+	 * won't survive through firmware reboots, etc.
+	 */
+
+	if ((id & 0xFF0000) == 0xFF0000) {
+		/* Send it to the firmware through the fwtest (stock-ish) API */
+		/* Search for WMI_FWTEST_CMDID in core.c */
+		if (ar->state == ATH10K_STATE_ON) {
+			ret = ath10k_wmi_pdev_set_fwtest(ar, id & 0xFFFF, val);
+		}
+	}
+	else {
+		/* Send it to the firmware though ct-special API */
+		if (ar->state == ATH10K_STATE_ON) {
+			ret = ath10k_wmi_pdev_set_special(ar, id, val);
+		}
+	}
+unlock:
+	mutex_unlock(&ar->conf_mutex);
+
+	return ret ?: count;
+}
+
+static ssize_t ath10k_read_ct_special(struct file *file,
+				      char __user *user_buf,
+				      size_t count, loff_t *ppos)
+{
+	static const char buf[] =
+		"BE WARNED:  You should understand the values before setting anything here.\n"
+		"You could put your NIC out of spec or maybe even break the hardware if you\n"
+		"put in bad values.\n\n"
+		"Value is u64, encoded thus:\n"
+		"id = t64 >> 32\n"
+		"val = t64 & 0xFFFFFFFF\n"
+		"id: 3 THRESH62_EXT (both bands use same value currently)\n"
+		"  value = val & 0xFF;\n"
+		"id: 4 CCA-Values, encoded as below:\n"
+		"  band = val >> 24;  //(0 5Ghz, 1 2.4Ghz)\n"
+		"  type = (val >> 16) & 0xFF; // 0-2 minCcaPwr[type], 3 noiseFloorThresh\n"
+		"         4 enable_minccapwr_thresh\n"
+		"  value = val & 0xFFFF;\n"
+		"    Unless otherwise specified, 0 means don't set.\n"
+		"    enable-minccapwr-thresh:  1 disabled, 2 enabled.\n"
+		"id: 5 Allow-AMSDU-IBSS, 1 enabled, 0 disabled, global setting.\n"
+		"id: 6 Max TX-Power, 0-65535:  Latch max-tx-power, in 0.5 dbM Units.\n"
+		"id: 7 RC max PER Threshold: 0-256 (50 is default). Tune with Care.\n"
+		"id: 8 STA-TX-BW-MASK,  0:  all, 0x1: 20Mhz, 0x2 40Mhz, 0x4 80Mhz (station vdevs only)\n"
+		"id: 9 pdev failed retry threshold, U16, 10.1 firmware default is 0x40\n"
+		"id: 0xA Enable(1)/Disable(0) baseband RIFS.  Default is disabled.\n"
+		"id: 0xB WMI WD Keepalive(ms): 0xFFFFFFFF disables, otherwise suggest 8000+.\n"
+		"id: 0xC Power-Save hack:  0x1 ignore PS sleep message from STA\n"
+		"id:                       0x2 mark mcast as 'data-is-buffered' regardless\n"
+		"id: 0xD Enable CSI reporting for at least probe requests.\n"
+		"id: 0xE set rate-bandwidth-disable-mask: 20Mhz 0x1, 40Mhz 0x2, 80Mhz 0x4, 160Mhz 0x8.\n"
+		"    Takes effect next time rates are set.  Set to 0x0 for default rates.\n"
+		"id: 0xF Enable TXBF-CV-MSG.\n"
+		"id: 0x10 rx-all-mgt.\n"
+		"id: 0x11 allow tx-hang logic to try cold resets instead of just warm resets.\n"
+		"id: 0x12 disable special CCA setting for IBSS queues.\n"
+		"id: 0x13 set 5-bit antenna-mask for peer, format:  (peer-id << 16) | ant_mask\n"
+		"id: 0x14 Add a 32-bit sticky register address override to the eeprom."
+		"id: 0x15 Add a 32-bit sticky register value override to the eeprom."
+		"id: 0x16 Enable/Disable reporting PN in peer-stats."
+		"\nBelow here should work with most firmware, including non-CT firmware.\n"
+		"id: 0x1001 set sta-kickout threshold due to tx-failures (0 means disable.  Default is 20 * 16.)\n"
+		"id: 0x1002 set su-sounding-timer-ms (0 means use defaults next FW reload.  Default is 100, max is 500)\n"
+		"id: 0x1003 set mu-sounding-timer-ms (0 means use defaults next FW reload.  Default is 40)\n"
+		"id: 0x1004 set rc-txbf-probe (1 means sent txbf probe, 0 (default) means do not\n"
+		"id: 0x1005 set apply-board-power-ctl-table (1 means apply, 0 means not)\n"
+		"\n";
+
+	return simple_read_from_buffer(user_buf, count, ppos, buf, strlen(buf));
+}
+
+static const struct file_operations fops_ct_special = {
+	.read = ath10k_read_ct_special,
+	.write = ath10k_write_ct_special,
+	.open = simple_open
+};
+
+
 static ssize_t ath10k_write_quiet_period(struct file *file,
 					 const char __user *ubuf,
 					 size_t count, loff_t *ppos)
@@ -2521,6 +4319,8 @@
 	INIT_LIST_HEAD(&ar->debug.fw_stats.peers);
 	INIT_LIST_HEAD(&ar->debug.fw_stats.peers_extd);
 
+	INIT_DELAYED_WORK(&ar->debug.nop_dwork, ath10k_debug_nop_dwork);
+
 	return 0;
 }
 
@@ -2532,6 +4332,8 @@
 	ath10k_debug_fw_stats_reset(ar);
 
 	kfree(ar->debug.tpc_stats);
+
+	cancel_delayed_work_sync(&ar->debug.nop_dwork);
 }
 
 int ath10k_debug_register(struct ath10k *ar)
@@ -2550,6 +4352,8 @@
 
 	init_completion(&ar->debug.tpc_complete);
 	init_completion(&ar->debug.fw_stats_complete);
+	init_completion(&ar->debug.ratepwr_tbl_complete);
+	init_completion(&ar->debug.powerctl_tbl_complete);
 
 	debugfs_create_file("fw_stats", 0400, ar->debug.debugfs_phy, ar,
 			    &fops_fw_stats);
@@ -2557,12 +4361,36 @@
 	debugfs_create_file("fw_reset_stats", 0400, ar->debug.debugfs_phy, ar,
 			    &fops_fw_reset_stats);
 
+	debugfs_create_file("fw_regs", 0400, ar->debug.debugfs_phy, ar,
+			    &fops_fw_regs);
+
+	debugfs_create_file("rx_reorder_stats", 0400, ar->debug.debugfs_phy, ar,
+			    &fops_rx_reorder_stats);
+
+	debugfs_create_file("pdev_ext_stats", 0400, ar->debug.debugfs_phy, ar,
+			    &fops_pdev_ext_stats);
+
 	debugfs_create_file("wmi_services", 0400, ar->debug.debugfs_phy, ar,
 			    &fops_wmi_services);
 
+	debugfs_create_file("set_rates", 0600, ar->debug.debugfs_phy,
+			    ar, &fops_set_rates);
+
+	debugfs_create_file("set_rate_override", 0600, ar->debug.debugfs_phy,
+			    ar, &fops_set_rate_override);
+
+	debugfs_create_file("firmware_info", 0400, ar->debug.debugfs_phy, ar,
+			    &fops_fwinfo_services);
+
 	debugfs_create_file("simulate_fw_crash", 0600, ar->debug.debugfs_phy, ar,
 			    &fops_simulate_fw_crash);
 
+	debugfs_create_file("misc", 0400, ar->debug.debugfs_phy, ar,
+			    &fops_misc);
+
+	debugfs_create_file("debug_level", 0600, ar->debug.debugfs_phy,
+			    ar, &fops_debug_level);
+
 	debugfs_create_file("reg_addr", 0600, ar->debug.debugfs_phy, ar,
 			    &fops_reg_addr);
 
@@ -2600,7 +4428,7 @@
 		debugfs_create_file("dfs_simulate_radar", 0200, ar->debug.debugfs_phy,
 				    ar, &fops_simulate_radar);
 
-		debugfs_create_bool("dfs_block_radar_events", 0200,
+		debugfs_create_bool("dfs_block_radar_events", 0644,
 				    ar->debug.debugfs_phy,
 				    &ar->dfs_block_radar_events);
 
@@ -2615,13 +4443,27 @@
 		debugfs_create_file("quiet_period", 0644, ar->debug.debugfs_phy, ar,
 				    &fops_quiet_period);
 
+	debugfs_create_file("powerctl_table", 0600, ar->debug.debugfs_phy, ar,
+			    &fops_powerctl_table);
+
+	debugfs_create_file("ratepwr_table", 0600, ar->debug.debugfs_phy, ar,
+			    &fops_ratepwr_table);
+
 	debugfs_create_file("tpc_stats", 0400, ar->debug.debugfs_phy, ar,
 			    &fops_tpc_stats);
 
+	debugfs_create_file("thresh62_ext", S_IRUGO | S_IWUSR,
+			    ar->debug.debugfs_phy, ar, &fops_thresh62_ext);
+
+	debugfs_create_file("ct_special", S_IRUGO | S_IWUSR,
+			    ar->debug.debugfs_phy, ar, &fops_ct_special);
+
 	if (test_bit(WMI_SERVICE_COEX_GPIO, ar->wmi.svc_map))
 		debugfs_create_file("btcoex", 0644, ar->debug.debugfs_phy, ar,
 				    &fops_btcoex);
 
+	debugfs_create_file("peers", 0400, ar->debug.debugfs_phy, ar,
+			    &fops_peers);
 	if (test_bit(WMI_SERVICE_PEER_STATS, ar->wmi.svc_map)) {
 		debugfs_create_file("peer_stats", 0644, ar->debug.debugfs_phy, ar,
 				    &fops_peer_stats);
@@ -2658,6 +4500,7 @@
 
 void ath10k_debug_unregister(struct ath10k *ar)
 {
+	cancel_delayed_work_sync(&ar->debug.nop_dwork);
 	cancel_delayed_work_sync(&ar->debug.htt_stats_dwork);
 }
 
@@ -2718,3 +4561,75 @@
 EXPORT_SYMBOL(ath10k_dbg_dump);
 
 #endif /* CONFIG_ATH10K_DEBUG */
+
+void ath10k_dbg_print_fw_dbg_buffer(struct ath10k *ar, __le32 *ibuf, int len,
+				    const char* lvl)
+{
+	/* Print out raw hex, external tools can decode if
+	 * they care.
+	 * TODO:  Add ar identifier to messages.
+	 */
+	int q = 0;
+
+	dev_printk(lvl, ar->dev, "ath10k_pci ATH10K_DBG_BUFFER:\n");
+	while (q < len) {
+		if (q + 8 <= len) {
+			printk("%sath10k: [%04d]: %08X %08X %08X %08X %08X %08X %08X %08X\n",
+			       lvl, q,
+			       ibuf[q], ibuf[q+1], ibuf[q+2], ibuf[q+3],
+			       ibuf[q+4], ibuf[q+5], ibuf[q+6], ibuf[q+7]);
+			q += 8;
+		}
+		else if (q + 7 <= len) {
+			printk("%sath10k: [%04d]: %08X %08X %08X %08X %08X %08X %08X\n",
+			       lvl, q,
+			       ibuf[q], ibuf[q+1], ibuf[q+2], ibuf[q+3],
+			       ibuf[q+4], ibuf[q+5], ibuf[q+6]);
+			q += 7;
+		}
+		else if (q + 6 <= len) {
+			printk("%sath10k: [%04d]: %08X %08X %08X %08X %08X %08X\n",
+			       lvl, q,
+			       ibuf[q], ibuf[q+1], ibuf[q+2], ibuf[q+3],
+			       ibuf[q+4], ibuf[q+5]);
+			q += 6;
+		}
+		else if (q + 5 <= len) {
+			printk("%sath10k: [%04d]: %08X %08X %08X %08X %08X\n",
+			       lvl, q,
+			       ibuf[q], ibuf[q+1], ibuf[q+2], ibuf[q+3],
+			       ibuf[q+4]);
+			q += 5;
+		}
+		else if (q + 4 <= len) {
+			printk("%sath10k: [%04d]: %08X %08X %08X %08X\n",
+			       lvl, q,
+			       ibuf[q], ibuf[q+1], ibuf[q+2], ibuf[q+3]);
+			q += 4;
+		}
+		else if (q + 3 <= len) {
+			printk("%sath10k: [%04d]: %08X %08X %08X\n",
+			       lvl, q,
+			       ibuf[q], ibuf[q+1], ibuf[q+2]);
+			q += 3;
+		}
+		else if (q + 2 <= len) {
+			printk("%sath10k: [%04d]: %08X %08X\n",
+			       lvl, q,
+			       ibuf[q], ibuf[q+1]);
+			q += 2;
+		}
+		else if (q + 1 <= len) {
+			printk("%sath10k: [%04d]: %08X\n",
+			       lvl, q,
+			       ibuf[q]);
+			q += 1;
+		}
+		else {
+			break;
+		}
+	}/* while */
+
+	dev_printk(lvl, ar->dev, "ATH10K_END\n");
+}
+EXPORT_SYMBOL(ath10k_dbg_print_fw_dbg_buffer);
diff -Nur linux-5.4.39/drivers/net/wireless/ath/ath10k/debug.h linux-5.4.39-ct/drivers/net/wireless/ath/ath10k/debug.h
--- linux-5.4.39/drivers/net/wireless/ath/ath10k/debug.h	2020-05-06 07:15:17.000000000 +0100
+++ linux-5.4.39-ct/drivers/net/wireless/ath/ath10k/debug.h	2020-05-12 23:23:34.000000000 +0100
@@ -11,6 +11,10 @@
 #include <linux/types.h>
 #include "trace.h"
 
+/**
+ * ATH10K_DBG_INFO_AS_DBG: use dev_dbg instead of dev_info
+ *       for ath10k_info messages
+ */
 enum ath10k_debug_mask {
 	ATH10K_DBG_PCI		= 0x00000001,
 	ATH10K_DBG_WMI		= 0x00000002,
@@ -34,6 +38,11 @@
 	ATH10K_DBG_USB_BULK	= 0x00080000,
 	ATH10K_DBG_SNOC		= 0x00100000,
 	ATH10K_DBG_QMI		= 0x00200000,
+	ATH10K_DBG_BEACON       = 0x08000000, /* Print out beacon debug info */
+	ATH10K_DBG_NO_DBGLOG    = 0x10000000, /* Don't print DBGLOG firmware hex messages in kernel logs. */
+	ATH10K_DBG_MAC2	        = 0x20000000, /* more verbose MAC debugging */
+	ATH10K_DBG_INFO_AS_DBG	= 0x40000000,
+	ATH10K_DBG_FW		= 0x80000000,
 	ATH10K_DBG_ANY		= 0xffffffff,
 };
 
@@ -74,6 +83,12 @@
 #define ATH10K_TX_POWER_MAX_VAL 70
 #define ATH10K_TX_POWER_MIN_VAL 0
 
+struct ath10k_dbglog_entry_storage_user {
+	__le32 head_idx; /* Where to write next chunk of data */
+	__le32 tail_idx; /* Index of first msg */
+	__le32 data[ATH10K_DBGLOG_DATA_LEN];
+} __packed;
+
 extern unsigned int ath10k_debug_mask;
 
 __printf(2, 3) void ath10k_info(struct ath10k *ar, const char *fmt, ...);
@@ -84,6 +99,7 @@
 void ath10k_debug_print_board_info(struct ath10k *ar);
 void ath10k_debug_print_boot_info(struct ath10k *ar);
 void ath10k_print_driver_info(struct ath10k *ar);
+void ath10k_set_debug_mask(unsigned int v);
 
 #ifdef CONFIG_ATH10K_DEBUGFS
 int ath10k_debug_start(struct ath10k *ar);
@@ -110,6 +126,9 @@
 void ath10k_debug_get_et_stats(struct ieee80211_hw *hw,
 			       struct ieee80211_vif *vif,
 			       struct ethtool_stats *stats, u64 *data);
+void ath10k_debug_get_et_stats2(struct ieee80211_hw *hw,
+				struct ieee80211_vif *vif,
+				struct ethtool_stats *stats, u64 *data, u32 level);
 
 static inline u64 ath10k_debug_get_fw_dbglog_mask(struct ath10k *ar)
 {
@@ -125,8 +144,16 @@
 {
 	return ar->debug.enable_extd_tx_stats;
 }
+
+void ath10k_dbg_save_fw_dbg_buffer(struct ath10k *ar, __le32 *buffer, int len);
+
 #else
 
+static inline void ath10k_dbg_save_fw_dbg_buffer(struct ath10k *ar,
+						 __le32 *buffer, int len)
+{
+}
+
 static inline int ath10k_debug_start(struct ath10k *ar)
 {
 	return 0;
@@ -276,4 +303,10 @@
 	    trace_ath10k_log_dbg_enabled())			\
 		__ath10k_dbg(ar, dbg_mask, fmt, ##__VA_ARGS__); \
 } while (0)
+
+int ath10k_debug_fw_stats_request(struct ath10k *ar);
+int ath10k_refresh_peer_stats(struct ath10k *ar);
+void ath10k_dbg_print_fw_dbg_buffer(struct ath10k *ar, __le32 *buffer,
+				    int len, const char* lvl);
+
 #endif /* _DEBUG_H_ */
diff -Nur linux-5.4.39/drivers/net/wireless/ath/ath10k/hif.h linux-5.4.39-ct/drivers/net/wireless/ath/ath10k/hif.h
--- linux-5.4.39/drivers/net/wireless/ath/ath10k/hif.h	2020-05-06 07:15:17.000000000 +0100
+++ linux-5.4.39-ct/drivers/net/wireless/ath/ath10k/hif.h	2020-05-12 23:23:34.000000000 +0100
@@ -77,6 +77,9 @@
 
 	void (*write32)(struct ath10k *ar, u32 address, u32 value);
 
+	/* We think firmware has crashed, attempt to gather logs and recover. */
+	void (*fw_crashed_dump)(struct ath10k *ar);
+
 	/* Power up the device and enter BMI transfer mode for FW download */
 	int (*power_up)(struct ath10k *ar, enum ath10k_firmware_mode fw_mode);
 
@@ -129,12 +132,14 @@
 
 static inline int ath10k_hif_start(struct ath10k *ar)
 {
+	ar->hif_running = true;
 	return ar->hif.ops->start(ar);
 }
 
 static inline void ath10k_hif_stop(struct ath10k *ar)
 {
-	return ar->hif.ops->stop(ar);
+	ar->hif_running = false;
+	ar->hif.ops->stop(ar);
 }
 
 static inline int ath10k_hif_swap_mailbox(struct ath10k *ar)
@@ -207,6 +212,17 @@
 	return ar->hif.ops->read32(ar, address);
 }
 
+static inline int ath10k_hif_fw_crashed_dump(struct ath10k *ar)
+{
+	if (!ar->hif.ops->fw_crashed_dump) {
+		ath10k_warn(ar, "hif fw_crashed_dump\n");
+		return -EINVAL;
+	}
+
+	ar->hif.ops->fw_crashed_dump(ar);
+	return 0;
+}
+
 static inline void ath10k_hif_write32(struct ath10k *ar,
 				      u32 address, u32 data)
 {
diff -Nur linux-5.4.39/drivers/net/wireless/ath/ath10k/htc.c linux-5.4.39-ct/drivers/net/wireless/ath/ath10k/htc.c
--- linux-5.4.39/drivers/net/wireless/ath/ath10k/htc.c	2020-05-06 07:15:17.000000000 +0100
+++ linux-5.4.39-ct/drivers/net/wireless/ath/ath10k/htc.c	2020-05-12 23:23:34.000000000 +0100
@@ -120,9 +120,18 @@
 			goto err_pull;
 		}
 		ep->tx_credits -= credits;
-		ath10k_dbg(ar, ATH10K_DBG_HTC,
-			   "htc ep %d consumed %d credits (total %d)\n",
-			   eid, credits, ep->tx_credits);
+		if (eid == ar->wmi.eid) {
+			struct wmi_cmd_hdr* hdr;
+			hdr = (struct wmi_cmd_hdr*)(skb->data + sizeof(struct ath10k_htc_hdr));
+			ath10k_dbg(ar, ATH10K_DBG_HTC,
+				   "htc ep %d consumed %d credits (total %d, wmi-cmd 0x%x)\n",
+				   eid, credits, ep->tx_credits, __le32_to_cpu(hdr->cmd_id));
+		}
+		else {
+			ath10k_dbg(ar, ATH10K_DBG_HTC,
+				   "htc ep %d consumed %d credits (total %d)\n",
+				   eid, credits, ep->tx_credits);
+		}
 		spin_unlock_bh(&htc->tx_lock);
 	}
 
diff -Nur linux-5.4.39/drivers/net/wireless/ath/ath10k/htt.c linux-5.4.39-ct/drivers/net/wireless/ath/ath10k/htt.c
--- linux-5.4.39/drivers/net/wireless/ath/ath10k/htt.c	2020-05-06 07:15:17.000000000 +0100
+++ linux-5.4.39-ct/drivers/net/wireless/ath/ath10k/htt.c	2020-05-12 23:23:34.000000000 +0100
@@ -261,8 +261,8 @@
 					     htt->max_num_ampdu,
 					     htt->max_num_amsdu);
 	if (status) {
-		ath10k_warn(ar, "failed to setup amsdu/ampdu limit: %d\n",
-			    status);
+		ath10k_warn(ar, "failed to setup amsdu=%d/ampdu=%d limit: %d\n",
+			    htt->max_num_ampdu, htt->max_num_amsdu, status);
 		return status;
 	}
 
diff -Nur linux-5.4.39/drivers/net/wireless/ath/ath10k/htt.h linux-5.4.39-ct/drivers/net/wireless/ath/ath10k/htt.h
--- linux-5.4.39/drivers/net/wireless/ath/ath10k/htt.h	2020-05-06 07:15:17.000000000 +0100
+++ linux-5.4.39-ct/drivers/net/wireless/ath/ath10k/htt.h	2020-05-12 23:23:34.000000000 +0100
@@ -150,7 +150,7 @@
 	HTT_DATA_TX_DESC_FLAGS1_MORE_IN_BATCH    = 1 << 12,
 	HTT_DATA_TX_DESC_FLAGS1_CKSUM_L3_OFFLOAD = 1 << 13,
 	HTT_DATA_TX_DESC_FLAGS1_CKSUM_L4_OFFLOAD = 1 << 14,
-	HTT_DATA_TX_DESC_FLAGS1_RSVD1            = 1 << 15
+	HTT_DATA_TX_DESC_FLAGS1_NO_ACK_CT /*RSVD1*/ = 1 << 15 /* Using this for no-ack flag, raw-tx only. --Ben */
 };
 
 enum htt_data_tx_ext_tid {
@@ -374,7 +374,9 @@
 enum htt_mgmt_tx_status {
 	HTT_MGMT_TX_STATUS_OK    = 0,
 	HTT_MGMT_TX_STATUS_RETRY = 1,
-	HTT_MGMT_TX_STATUS_DROP  = 2
+	HTT_MGMT_TX_STATUS_DROP  = 2,
+	HTT_MGMT_TX_STATUS_TXFILT = 3 /* Seems to be logically similar to
+					 RETRY failure. */
 };
 
 /*=== target -> host messages ===============================================*/
@@ -579,6 +581,9 @@
 #define HTT_TX_CMPL_FLAG_PA_PRESENT		BIT(2)
 #define HTT_TX_CMPL_FLAG_PPDU_DURATION_PRESENT	BIT(3)
 
+#define HTT_TX_CMPL_FLAG_RETRIES_FILLED		BIT(5)
+#define HTT_TX_CMPL_FLAG_RATE_FILLED		BIT(6)
+
 #define HTT_TX_DATA_RSSI_ENABLE_WCN3990 BIT(3)
 #define HTT_TX_DATA_APPEND_RETRIES BIT(0)
 #define HTT_TX_DATA_APPEND_TIMESTAMP BIT(1)
@@ -837,8 +842,9 @@
 #define ATH10K_TXRX_NUM_EXT_TIDS 19
 
 enum htt_security_flags {
-#define HTT_SECURITY_TYPE_MASK 0x7F
+#define HTT_SECURITY_TYPE_MASK 0x3F
 #define HTT_SECURITY_TYPE_LSB  0
+	HTT_SECURITY_IS_FAILURE = 1 << 6, /* CT firmware only */
 	HTT_SECURITY_IS_UNICAST = 1 << 7
 };
 
@@ -847,7 +853,9 @@
 		/* dont use bitfields; undefined behaviour */
 		u8 flags; /* %htt_security_flags */
 		struct {
-			u8 security_type:7, /* %htt_security_types */
+			u8 security_type:6, /* %htt_security_types */
+			   is_failure:1, /* does this response indicate failure
+					    (CT Firmware) */
 			   is_unicast:1;
 		} __packed;
 	} __packed;
@@ -981,7 +989,7 @@
 		} __packed;
 	} __packed;
 	u8 num_msdus;
-	u8 flags2; /* HTT_TX_CMPL_FLAG_DATA_RSSI */
+	u8 flags2;
 	__le16 msdus[0]; /* variable length based on %num_msdus */
 } __packed;
 
@@ -1000,6 +1008,49 @@
 	struct htt_data_tx_ppdu_dur ppdu_dur[0];
 } __packed;
 
+struct msdu_rx_compl_info_ct {
+	__le16 id; /* msdu id */
+	u8 tx_rate_code; /* what rate index the firmware reports transmitting at. */
+	u8 tx_rate_flags; /* what rate flags, See ATH10K_RC_FLAG_SGI, etc */
+};
+
+struct msdu_rx_compl_info_ct2 {
+	__le16 id; /* msdu id */
+	u8 tx_rate_code; /* what rate index the firmware reports transmitting at. */
+	u8 tx_rate_flags; /* what rate flags, See ATH10K_RC_FLAG_SGI, etc */
+	u8 mpdus_tried; /* Frames we tried to transmit */
+	u8 mpdus_failed; /* Frames we failed to get (block)ack'd */
+	u8 unused[2];
+};
+
+struct htt_data_tx_completion_ct {
+	union {
+		u8 flags;
+		struct {
+			u8 status:3,
+			   tid:4,
+			   tid_invalid:1;
+		} __packed;
+	} __packed;
+	u8 num_msdus;
+	u8 rsvd0;
+	struct msdu_rx_compl_info_ct msdus[0]; /* variable length based on %num_msdus */
+} __packed;
+
+struct htt_data_tx_completion_ct2 {
+	union {
+		u8 flags;
+		struct {
+			u8 status:3,
+			   tid:4,
+			   tid_invalid:1;
+		} __packed;
+	} __packed;
+	u8 num_msdus;
+	u8 rsvd0;
+	struct msdu_rx_compl_info_ct2 msdus[0]; /* variable length based on %num_msdus */
+} __packed;
+
 struct htt_tx_compl_ind_base {
 	u32 hdr;
 	u16 payload[1/*or more*/];
@@ -1802,6 +1853,8 @@
 		struct htt_ver_resp ver_resp;
 		struct htt_mgmt_tx_completion mgmt_tx_completion;
 		struct htt_data_tx_completion data_tx_completion;
+		struct htt_data_tx_completion_ct data_tx_completion_ct;
+		struct htt_data_tx_completion_ct2 data_tx_completion_ct2;
 		struct htt_rx_indication rx_ind;
 		struct htt_rx_indication_hl rx_ind_hl;
 		struct htt_rx_fragment_indication rx_frag_ind;
@@ -1828,10 +1881,27 @@
 
 /*** host side structures follow ***/
 
+/* tx-rate flags field definitions, see firmware whal_desc.h */
+/* First two bits are for tx-completion report. */
+#define ATH10K_RC_FLAG_TXOK       0x00 /* Pkt transmitted OK */
+#define ATH10K_RC_FLAG_XRETRY     0x01 /* Pkt failed to transmit, too many retries. */
+#define ATH10K_RC_FLAG_DROP       0x02 /* Dropped due to tid flush, local buffer exhaustion, etc. */
+
+#define ATH10K_RC_FLAG_SGI        0x08 /* use HT SGI if set */
+#define ATH10K_RC_FLAG_STBC       0x10 /* use HT STBC if set */
+#define ATH10K_RC_FLAG_40MHZ      0x20 /* 40 mhz mode */
+#define ATH10K_RC_FLAG_80MHZ      0x40 /* 80 mhz mode */
+#define ATH10K_RC_FLAG_160MHZ     0x80 /* 160 mhz mode */
+
+
 struct htt_tx_done {
 	u16 msdu_id;
 	u16 status;
 	u8 ack_rssi;
+	u8 tx_rate_code; /* CT firmware only, see firmware ar_desc_wifi_ip01.h (search for 0x44) */
+	u8 tx_rate_flags; /* CT firmware only, see flag defs above */
+	u8 mpdus_tried; /* CT firmware only */
+	u8 mpdus_failed; /* CT firmware only */
 };
 
 enum htt_tx_compl_state {
@@ -1871,6 +1941,7 @@
 
 	u8 target_version_major;
 	u8 target_version_minor;
+	bool needs_unlock;
 	struct completion target_version_received;
 	u8 max_num_amsdu;
 	u8 max_num_ampdu;
@@ -2026,7 +2097,8 @@
 	int (*htt_send_frag_desc_bank_cfg)(struct ath10k_htt *htt);
 	int (*htt_alloc_frag_desc)(struct ath10k_htt *htt);
 	void (*htt_free_frag_desc)(struct ath10k_htt *htt);
-	int (*htt_tx)(struct ath10k_htt *htt, enum ath10k_hw_txrx_mode txmode,
+	int (*htt_tx)(struct ath10k_htt *htt, struct ieee80211_vif *vif,
+		      enum ath10k_hw_txrx_mode txmode,
 		      struct sk_buff *msdu);
 	int (*htt_alloc_txbuff)(struct ath10k_htt *htt);
 	void (*htt_free_txbuff)(struct ath10k_htt *htt);
@@ -2066,10 +2138,11 @@
 }
 
 static inline int ath10k_htt_tx(struct ath10k_htt *htt,
+				struct ieee80211_vif *vif,
 				enum ath10k_hw_txrx_mode txmode,
 				struct sk_buff *msdu)
 {
-	return htt->tx_ops->htt_tx(htt, txmode, msdu);
+	return htt->tx_ops->htt_tx(htt, vif, txmode, msdu);
 }
 
 static inline int ath10k_htt_alloc_txbuff(struct ath10k_htt *htt)
@@ -2218,7 +2291,7 @@
  * Should be: sizeof(struct htt_host_rx_desc) + max rx MSDU size,
  * rounded up to a cache line size.
  */
-#define HTT_RX_BUF_SIZE 1920
+#define HTT_RX_BUF_SIZE 2048 /* used to be 1920, but then MTU > 1500 fails, see CT bug 89 */
 #define HTT_RX_MSDU_SIZE (HTT_RX_BUF_SIZE - (int)sizeof(struct htt_rx_desc))
 
 /* Refill a bunch of RX buffers for each refill round so that FW/HW can handle
diff -Nur linux-5.4.39/drivers/net/wireless/ath/ath10k/htt_rx.c linux-5.4.39-ct/drivers/net/wireless/ath/ath10k/htt_rx.c
--- linux-5.4.39/drivers/net/wireless/ath/ath10k/htt_rx.c	2020-05-06 07:15:17.000000000 +0100
+++ linux-5.4.39-ct/drivers/net/wireless/ath/ath10k/htt_rx.c	2020-05-12 23:23:34.000000000 +0100
@@ -284,17 +284,25 @@
 	ath10k_htt_rx_ring_free(htt);
 	spin_unlock_bh(&htt->rx_ring.lock);
 
-	dma_free_coherent(htt->ar->dev,
-			  ath10k_htt_get_rx_ring_size(htt),
-			  ath10k_htt_get_vaddr_ring(htt),
-			  htt->rx_ring.base_paddr);
+	if (htt->rx_ring.base_paddr) {
+		dma_free_coherent(htt->ar->dev,
+				  ath10k_htt_get_rx_ring_size(htt),
+				  ath10k_htt_get_vaddr_ring(htt),
+				  htt->rx_ring.base_paddr);
+		htt->rx_ring.base_paddr = 0;
+	}
 
-	dma_free_coherent(htt->ar->dev,
-			  sizeof(*htt->rx_ring.alloc_idx.vaddr),
-			  htt->rx_ring.alloc_idx.vaddr,
-			  htt->rx_ring.alloc_idx.paddr);
+	if (htt->rx_ring.alloc_idx.paddr) {
+		dma_free_coherent(htt->ar->dev,
+				  sizeof(*htt->rx_ring.alloc_idx.vaddr),
+				  htt->rx_ring.alloc_idx.vaddr,
+				  htt->rx_ring.alloc_idx.paddr);
+		htt->rx_ring.alloc_idx.paddr = 0;
+	}
 
 	kfree(htt->rx_ring.netbufs_ring);
+	htt->rx_ring.netbufs_ring = NULL;
+	htt->rx_ring.size = 0;
 }
 
 static inline struct sk_buff *ath10k_htt_rx_netbuf_pop(struct ath10k_htt *htt)
@@ -1074,8 +1082,18 @@
 	if (WARN_ON_ONCE(!arvif))
 		return NULL;
 
-	if (ath10k_mac_vif_chan(arvif->vif, &def))
+	if (ath10k_mac_vif_chan(arvif->vif, &def)) {
+		/* This used to WARN_ON_ONCE, but that bothers users, and I am not sure this is really
+		 * a bug. --Ben
+		 */
+		static bool do_once = 1;
+		if (do_once) {
+			ath10k_warn(ar, "mac-vif-chan had error in htt_rx_h_vdev_channel, peer-id: %d  vdev-id: %d peer-addr: %pM.",
+				    peer_id, peer->vdev_id, peer->addr);
+			do_once = 0;
+		}
 		return NULL;
+	}
 
 	return def.chan;
 }
@@ -1155,20 +1173,77 @@
 {
 	int i;
 
+	int nf = ATH10K_DEFAULT_NOISE_FLOOR;
+
+#ifdef CONFIG_ATH10K_DEBUGFS
+	struct ath10k_pdev_ext_stats_ct *pes = &ar->debug.pdev_ext_stats;
+	s32* nfa = &(pes->chan_nf_0);
+	s32 sums[IEEE80211_MAX_CHAINS];
+	bool has_nf = false;
+	sums[0] = sums[1] = sums[2] = sums[3] = 0x80;
+
+	/* FIXME:  Need to figure out how to take the secondary 80Mhz noise floor into
+	 * account too when using 160Mhz, but not worrying about that for now.
+	 */
+#endif
+
 	for (i = 0; i < IEEE80211_MAX_CHAINS ; i++) {
 		status->chains &= ~BIT(i);
 
 		if (rxd->ppdu_start.rssi_chains[i].pri20_mhz != 0x80) {
-			status->chain_signal[i] = ATH10K_DEFAULT_NOISE_FLOOR +
-				rxd->ppdu_start.rssi_chains[i].pri20_mhz;
+#ifdef CONFIG_ATH10K_DEBUGFS
+			if (nfa[i] != 0x80) {
+				nf = nfa[i];
+				has_nf = true;
+			}
+			sums[i] =
+#endif
+			status->chain_signal[i] = nf
+				+ ath10k_sum_sigs(rxd->ppdu_start.rssi_chains[i].pri20_mhz,
+						  rxd->ppdu_start.rssi_chains[i].ext20_mhz,
+						  rxd->ppdu_start.rssi_chains[i].ext40_mhz,
+						  rxd->ppdu_start.rssi_chains[i].ext80_mhz);
+			/* ath10k_warn(ar, "rx-h-sig, chain[%i] pri20: %d ext20: %d  ext40: %d  ext80: %d\n",
+			 *	    i, rxd->ppdu_start.rssi_chains[i].pri20_mhz,
+			 *          rxd->ppdu_start.rssi_chains[i].ext20_mhz,
+			 *	    rxd->ppdu_start.rssi_chains[i].ext40_mhz,
+			 *          rxd->ppdu_start.rssi_chains[i].ext80_mhz);
+			 */
 
 			status->chains |= BIT(i);
 		}
 	}
 
-	/* FIXME: Get real NF */
-	status->signal = ATH10K_DEFAULT_NOISE_FLOOR +
-			 rxd->ppdu_start.rssi_comb;
+	/* So, noise-floor is really per-chain, so I guess we average it here. */
+	/* This does not yield good results for 80Mhz, but does for 20Mhz.  I'm thinking
+	 * the rssi_comb is for just the first 20Mhz perhaps?  So, just add up the per-chain
+	 * values if we have a valid noise floor.
+	 */
+#ifdef CONFIG_ATH10K_DEBUGFS
+	nf = ATH10K_DEFAULT_NOISE_FLOOR;
+	if (has_nf) {
+		status->signal = ath10k_sum_sigs(sums[0], sums[1], sums[2], sums[3]);
+	}
+	else
+#endif
+	{
+
+		/* 0x80 means value-is-not-set on wave-2 firmware.
+		 * For wave-2 firmware, value is not defined and is set to zero. */
+		if (rxd->ppdu_start.rssi_comb_ht &&
+		    (rxd->ppdu_start.rssi_comb_ht != 0x80)) {
+			status->signal = nf + rxd->ppdu_start.rssi_comb_ht;
+		}
+		else {
+			status->signal = nf + rxd->ppdu_start.rssi_comb;
+		}
+	}
+
+	/* ath10k_warn(ar, "rx-h-sig, signal: %d  chains: 0x%x  chain[0]: %d  chain[1]: %d  chain[2]: %d chain[3]: %d\n",
+	 *	    status->signal, status->chains, status->chain_signal[0],
+	 *	    status->chain_signal[1], status->chain_signal[2],
+	 *          status->chain_signal[3]);
+	 */
 	status->flag &= ~RX_FLAG_NO_SIGNAL_VAL;
 }
 
@@ -1213,6 +1288,7 @@
 		status->rate_idx = 0;
 		status->nss = 0;
 		status->encoding = RX_ENC_LEGACY;
+		status->enc_flags = 0;
 		status->bw = RATE_INFO_BW_20;
 
 		status->flag &= ~RX_FLAG_MACTIME_END;
@@ -1379,6 +1455,12 @@
 	if (WARN_ON_ONCE(!(is_first && is_last) && !msdu_limit_err))
 		return;
 
+	/* We see zero length msdus, not sure why.  At least don't
+	 * try to trim it further.
+	 */
+	if (unlikely(msdu->len < 4))
+		return;
+
 	skb_trim(msdu, msdu->len - FCS_LEN);
 
 	/* Push original 80211 header */
@@ -1670,6 +1752,12 @@
 	decap = MS(__le32_to_cpu(rxd->msdu_start.common.info1),
 		   RX_MSDU_START_INFO1_DECAP_FORMAT);
 
+	/*
+	  ath10k_dbg(ar, ATH10K_DBG_HTT,
+		   "rx-undecap: msdu-len: %d  decap: %d  ip-summed: %d decrypted: %d enctype: %d\n",
+		   msdu->len, decap, msdu->ip_summed, is_decrypted, enctype);
+	*/
+
 	switch (decap) {
 	case RX_MSDU_DECAP_RAW:
 		ath10k_htt_rx_h_undecap_raw(ar, msdu, status, enctype,
@@ -1844,7 +1932,16 @@
 			status->flag |= RX_FLAG_IV_STRIPPED;
 	}
 
+	/*
+	ath10k_dbg(ar, ATH10K_DBG_HTT,
+		   "rx-mpdu: first-len: %d  fcs-err: %i  tkip-err: %i decrypted: %i crypto-err: %i  peer-idx-inval: %i  enctype: %i\n",
+		   first->len, has_fcs_err, has_tkip_err, is_decrypted, has_crypto_err,
+		   has_peer_idx_invalid, enctype);
+	*/
 	skb_queue_walk(amsdu, msdu) {
+#ifdef CONFIG_ATH10K_DEBUGFS
+		ar->debug.rx_bytes += msdu->len;
+#endif
 		ath10k_htt_rx_h_csum_offload(msdu);
 		ath10k_htt_rx_h_undecap(ar, msdu, status, first_hdr, enctype,
 					is_decrypted);
@@ -1893,7 +1990,7 @@
 	}
 }
 
-static int ath10k_unchain_msdu(struct sk_buff_head *amsdu,
+static int ath10k_unchain_msdu(struct ath10k* ar, struct sk_buff_head *amsdu,
 			       unsigned long *unchain_cnt)
 {
 	struct sk_buff *skb, *first;
@@ -1917,10 +2014,12 @@
 	space = total_len - skb_tailroom(first);
 	if ((space > 0) &&
 	    (pskb_expand_head(first, 0, space, GFP_ATOMIC) < 0)) {
-		/* TODO:  bump some rx-oom error stat */
 		/* put it back together so we can free the
 		 * whole list at once.
 		 */
+#ifdef CONFIG_ATH10K_DEBUGFS
+		ar->debug.rx_drop_unchain_oom++;
+#endif
 		__skb_queue_head(amsdu, first);
 		return -1;
 	}
@@ -1963,11 +2062,14 @@
 	if (decap != RX_MSDU_DECAP_RAW ||
 	    skb_queue_len(amsdu) != 1 + rxd->frag_info.ring2_more_count) {
 		*drop_cnt += skb_queue_len(amsdu);
+#ifdef CONFIG_ATH10K_DEBUGFS
+		ar->debug.rx_drop_decap_non_raw_chained++;
+#endif
 		__skb_queue_purge(amsdu);
 		return;
 	}
 
-	ath10k_unchain_msdu(amsdu, unchain_cnt);
+	ath10k_unchain_msdu(ar, amsdu, unchain_cnt);
 }
 
 static bool ath10k_htt_rx_amsdu_allowed(struct ath10k *ar,
@@ -1980,11 +2082,17 @@
 
 	if (!rx_status->freq) {
 		ath10k_dbg(ar, ATH10K_DBG_HTT, "no channel configured; ignoring frame(s)!\n");
+#ifdef CONFIG_ATH10K_DEBUGFS
+		ar->debug.rx_drop_no_freq++;
+#endif
 		return false;
 	}
 
 	if (test_bit(ATH10K_CAC_RUNNING, &ar->dev_flags)) {
 		ath10k_dbg(ar, ATH10K_DBG_HTT, "htt rx cac running\n");
+#ifdef CONFIG_ATH10K_DEBUGFS
+		ar->debug.rx_drop_cac_running++;
+#endif
 		return false;
 	}
 
@@ -2622,7 +2730,7 @@
 {
 	struct ath10k_htt *htt = &ar->htt;
 	struct htt_resp *resp = (struct htt_resp *)skb->data;
-	struct htt_tx_done tx_done = {};
+	struct htt_tx_done tx_done = {0};
 	int status = MS(resp->data_tx_completion.flags, HTT_DATA_TX_STATUS);
 	__le16 msdu_id, *msdus;
 	bool rssi_enabled = false;
@@ -2651,50 +2759,202 @@
 		break;
 	}
 
-	ath10k_dbg(ar, ATH10K_DBG_HTT, "htt tx completion num_msdus %d\n",
-		   resp->data_tx_completion.num_msdus);
+	ath10k_dbg(ar, ATH10K_DBG_HTT,
+		   "htt tx completion num_msdus %d status: %d  discard: %d  no-ack: %d wmi-op-ver: %d\n",
+		   resp->data_tx_completion.num_msdus, status,
+		   tx_done.status == HTT_TX_COMPL_STATE_DISCARD,
+		   tx_done.status == HTT_TX_COMPL_STATE_NOACK,
+		   ar->running_fw->fw_file.wmi_op_version);
 
 	msdu_count = resp->data_tx_completion.num_msdus;
 	msdus = resp->data_tx_completion.msdus;
 	rssi_enabled = ath10k_is_rssi_enable(&ar->hw_params, resp);
 
+	if (resp->data_tx_completion.flags2 & HTT_TX_CMPL_FLAG_DATA_RSSI)
+		rssi_enabled = true;
+
 	if (rssi_enabled)
 		htt_pad = ath10k_tx_data_rssi_get_pad_bytes(&ar->hw_params,
 							    resp);
 
-	for (i = 0; i < msdu_count; i++) {
-		msdu_id = msdus[i];
-		tx_done.msdu_id = __le16_to_cpu(msdu_id);
-
-		if (rssi_enabled) {
-			/* Total no of MSDUs should be even,
-			 * if odd MSDUs are sent firmware fills
-			 * last msdu id with 0xffff
+	ath10k_dbg(ar, ATH10K_DBG_HTT, "htt tx completion num_msdus %d\n",
+		   resp->data_tx_completion.num_msdus);
+
+	if (test_bit(ATH10K_FW_FEATURE_TXRATE_CT,
+		     ar->running_fw->fw_file.fw_features) &&
+	    ar->running_fw->fw_file.wmi_op_version != ATH10K_FW_WMI_OP_VERSION_10_4) {
+		/* CT firmware reports tx-rate-kbps as well as the msdu id */
+		for (i = 0; i < resp->data_tx_completion_ct.num_msdus; i++) {
+			if (likely(test_bit(ATH10K_FW_FEATURE_TXRATE2_CT,
+					    ar->running_fw->fw_file.fw_features))) {
+				msdu_id = resp->data_tx_completion_ct2.msdus[i].id;
+				tx_done.msdu_id = __le16_to_cpu(msdu_id);
+				tx_done.tx_rate_code = resp->data_tx_completion_ct2.msdus[i].tx_rate_code;
+				tx_done.tx_rate_flags = resp->data_tx_completion_ct2.msdus[i].tx_rate_flags;
+				tx_done.mpdus_tried = resp->data_tx_completion_ct2.msdus[i].mpdus_tried;
+				tx_done.mpdus_failed = resp->data_tx_completion_ct2.msdus[i].mpdus_failed;
+			}
+			else {
+				msdu_id = resp->data_tx_completion_ct.msdus[i].id;
+				tx_done.msdu_id = __le16_to_cpu(msdu_id);
+				tx_done.tx_rate_code = resp->data_tx_completion_ct.msdus[i].tx_rate_code;
+				tx_done.tx_rate_flags = resp->data_tx_completion_ct.msdus[i].tx_rate_flags;
+			}
+
+			/* NOTE:  It seems only the first ampdu returns useful info here, at least with 'v1'
+			 * of the ath10k-ct wave-1 tx-rate logic.
 			 */
-			if (msdu_count & 0x01) {
-				msdu_id = msdus[msdu_count +  i + 1 + htt_pad];
-				tx_done.ack_rssi = __le16_to_cpu(msdu_id);
-			} else {
-				msdu_id = msdus[msdu_count +  i + htt_pad];
-				tx_done.ack_rssi = __le16_to_cpu(msdu_id);
+			if (ar->eeprom_overrides.tx_debug & 0x3)
+				ath10k_warn(ar,
+					    "htt tx completion, msdu_id: %d  tx-rate-code: 0x%x tx-rate-flags: 0x%x  tried: %d  failed: %d\n",
+					    tx_done.msdu_id,
+					    tx_done.tx_rate_code,
+					    tx_done.tx_rate_flags,
+					    tx_done.mpdus_tried,
+					    tx_done.mpdus_failed);
+
+			/* workaround for possibly firmware bug */
+			if (unlikely(tx_done.tx_rate_code == ATH10K_CT_TX_BEACON_INVALID_RATE_CODE)) {
+				dev_warn_once(ar->dev, "htt tx ct: fixing invalid VHT TX rate code 0xff\n");
+				tx_done.tx_rate_code = 0;
 			}
-		}
 
-		/* kfifo_put: In practice firmware shouldn't fire off per-CE
-		 * interrupt and main interrupt (MSI/-X range case) for the same
-		 * HTC service so it should be safe to use kfifo_put w/o lock.
-		 *
-		 * From kfifo_put() documentation:
-		 *  Note that with only one concurrent reader and one concurrent
-		 *  writer, you don't need extra locking to use these macro.
+			/* kfifo_put: In practice firmware shouldn't fire off per-CE
+			 * interrupt and main interrupt (MSI/-X range case) for the same
+			 * HTC service so it should be safe to use kfifo_put w/o lock.
+			 *
+			 * From kfifo_put() documentation:
+			 *  Note that with only one concurrent reader and one concurrent
+			 *  writer, you don't need extra locking to use these macro.
+			 */
+			if (!kfifo_put(&htt->txdone_fifo, tx_done)) {
+				ath10k_warn(ar, "txdone fifo overrun, msdu_id %d status %d\n",
+					    tx_done.msdu_id, tx_done.status);
+				ath10k_txrx_tx_unref(htt, &tx_done);
+			}
+		}
+	} else if (rssi_enabled) {
+		/* Round up, firmware will align to 32-bit boundaries */
+		int storage_idx = (resp->data_tx_completion_ct.num_msdus + 1) & ~1;
+		__le16 ack_rssi;
+		__le16 rate_info;
+		__le16 retries_info;
+		/* 10.4 firmware may report the ack rssi.  If so, it is
+		 * a series of uint16 appended on the end of the report.
+		 * And, 10.4 CT firmware may also report tx-rate, which
+		 * will again be a series of uint16 appended on the end.
 		 */
-		if (ar->bus_param.dev_type == ATH10K_DEV_TYPE_HL) {
-			ath10k_txrx_tx_unref(htt, &tx_done);
-		} else if (!kfifo_put(&htt->txdone_fifo, tx_done)) {
-			ath10k_warn(ar, "txdone fifo overrun, msdu_id %d status %d\n",
-				    tx_done.msdu_id, tx_done.status);
+		if (WARN_ON_ONCE(skb->len < ((storage_idx * 2) + sizeof(struct htt_data_tx_completion)))) {
+			ath10k_err(ar, "Invalid length for ack-rssi report, skb->len: %d  storage_idx: %d msdu: %d\n",
+				   skb->len, storage_idx, resp->data_tx_completion_ct.num_msdus);
+			goto do_generic;
+		}
+
+		if ((resp->data_tx_completion.flags2 & HTT_TX_CMPL_FLAG_RATE_FILLED) &&
+		    WARN_ON_ONCE(skb->len < ((storage_idx * 3) + sizeof(struct htt_data_tx_completion)))) {
+			ath10k_err(ar, "Invalid length for tx-rates report, skb->len: %d  storage_idx: %d msdu: %d\n",
+				   skb->len, storage_idx, resp->data_tx_completion_ct.num_msdus);
+			goto do_generic;
+		}
+
+		if ((resp->data_tx_completion.flags2 & HTT_TX_CMPL_FLAG_RETRIES_FILLED) &&
+		    WARN_ON_ONCE(skb->len < ((storage_idx * 4) + sizeof(struct htt_data_tx_completion)))) {
+			ath10k_err(ar, "Invalid length for tx-retries report, skb->len: %d  storage_idx: %d msdu: %d\n",
+				   skb->len, storage_idx, resp->data_tx_completion_ct.num_msdus);
+			goto do_generic;
+		}
+
+		tx_done.tx_rate_code = 0;
+		tx_done.tx_rate_flags = 0;
+		tx_done.mpdus_tried = 0;
+		tx_done.mpdus_failed = 0;
+		for (i = 0; i < resp->data_tx_completion_ct.num_msdus; i++) {
+			msdu_id = resp->data_tx_completion.msdus[i];
+			tx_done.msdu_id = __le16_to_cpu(msdu_id);
+			ack_rssi = resp->data_tx_completion.msdus[storage_idx + i];
+			tx_done.ack_rssi = __le16_to_cpu(ack_rssi);
+			if (resp->data_tx_completion.flags2 & HTT_TX_CMPL_FLAG_RATE_FILLED) {
+				rate_info = resp->data_tx_completion.msdus[storage_idx * 2 + i];
+				rate_info = __le16_to_cpu(rate_info);
+				tx_done.tx_rate_code = rate_info >> 8;
+				tx_done.tx_rate_flags = rate_info & 0xFF;
+				if (resp->data_tx_completion.flags2 & HTT_TX_CMPL_FLAG_RETRIES_FILLED) {
+					/* NOTE:  It seems that if 'probe' frames in the firmware
+					 * fail, then they will be retried at a lower rate, and because
+					 * the tx rate is different, it is not counted as 'mpdus_failed'
+					 * when finally reporting the tx status here.  So, this will
+					 * undercount, at least when using rate-ctrl.  I think that using
+					 * a single fixed rate might not see this issue, but that needs
+					 * testing. --Ben
+					 */
+					retries_info = resp->data_tx_completion.msdus[storage_idx * 3 + i];
+					retries_info = __le16_to_cpu(retries_info);
+					tx_done.mpdus_tried = retries_info & 0xFF;
+					tx_done.mpdus_failed = retries_info >> 8;
+				}
+			}
+			if (ar->eeprom_overrides.tx_debug & 0x3)
+				ath10k_warn(ar,
+					    "htt tx completion-w2, msdu_id: %d  tx-rate-code: 0x%x tx-rate-flags: 0x%x  tried: %d  failed: %d ack-rssi: %d\n",
+					    tx_done.msdu_id,
+					    tx_done.tx_rate_code,
+					    tx_done.tx_rate_flags,
+					    tx_done.mpdus_tried,
+					    tx_done.mpdus_failed,
+					    tx_done.ack_rssi);
+
+			/* Firmware reports garbage for ack-rssi if packet was not acked. */
+			if (unlikely(tx_done.status != HTT_TX_COMPL_STATE_ACK))
+				tx_done.ack_rssi = 0;
+
+			/* workaround for possibly firmware bug */
+			if (unlikely(tx_done.tx_rate_code == ATH10K_CT_TX_BEACON_INVALID_RATE_CODE)) {
+				dev_warn_once(ar->dev, "htt tx: fixing invalid VHT TX rate code 0xff\n");
+				tx_done.tx_rate_code = 0;
+			}
+
 			ath10k_txrx_tx_unref(htt, &tx_done);
 		}
+	} else {
+do_generic:
+		/* Upstream firmware does not report any tx-rate */
+		tx_done.tx_rate_code = 0;
+		tx_done.tx_rate_flags = 0;
+		for (i = 0; i < msdu_count; i++) {
+			msdus = resp->data_tx_completion.msdus;
+			msdu_id = msdus[i];
+			tx_done.msdu_id = __le16_to_cpu(msdu_id);
+
+			if (rssi_enabled) {
+				/* Total no of MSDUs should be even,
+				 * if odd MSDUs are sent firmware fills
+				 * last msdu id with 0xffff
+				 */
+				if (msdu_count & 0x01) {
+					msdu_id = msdus[msdu_count +  i + 1 + htt_pad];
+					tx_done.ack_rssi = __le16_to_cpu(msdu_id);
+				} else {
+					msdu_id = msdus[msdu_count +  i + htt_pad];
+					tx_done.ack_rssi = __le16_to_cpu(msdu_id);
+				}
+			}
+
+			/* kfifo_put: In practice firmware shouldn't fire off per-CE
+			 * interrupt and main interrupt (MSI/-X range case) for the same
+			 * HTC service so it should be safe to use kfifo_put w/o lock.
+			 *
+			 * From kfifo_put() documentation:
+			 *  Note that with only one concurrent reader and one concurrent
+			 *  writer, you don't need extra locking to use these macro.
+			 */
+			if (ar->bus_param.dev_type == ATH10K_DEV_TYPE_HL) {
+				ath10k_txrx_tx_unref(htt, &tx_done);
+			} else if (!kfifo_put(&htt->txdone_fifo, tx_done)) {
+				ath10k_warn(ar, "txdone fifo overrun, msdu_id %d status %d\n",
+					    tx_done.msdu_id, tx_done.status);
+				ath10k_txrx_tx_unref(htt, &tx_done);
+			}
+		}
 	}
 
 	if (!(resp->data_tx_completion.flags2 & HTT_TX_CMPL_FLAG_PPDU_DURATION_PRESENT))
@@ -2760,16 +3020,16 @@
 	spin_lock_bh(&ar->data_lock);
 	peer = ath10k_peer_find_by_id(ar, peer_id);
 	if (!peer) {
-		ath10k_warn(ar, "received addba event for invalid peer_id: %hu\n",
-			    peer_id);
+		ath10k_warn(ar, "received addba event for invalid peer_id: %hu tid: %d\n",
+			    peer_id, tid);
 		spin_unlock_bh(&ar->data_lock);
 		return;
 	}
 
 	arvif = ath10k_get_arvif(ar, peer->vdev_id);
 	if (!arvif) {
-		ath10k_warn(ar, "received addba event for invalid vdev_id: %u\n",
-			    peer->vdev_id);
+		ath10k_warn(ar, "received addba event for invalid vdev_id: %u peer_id: %hu tid: %d\n",
+			    peer->vdev_id, peer_id, tid);
 		spin_unlock_bh(&ar->data_lock);
 		return;
 	}
@@ -3091,6 +3351,13 @@
 
 	rcu_read_lock();
 
+	/* Wave-2 firmware that I saw uses a u8 to store the num-records in the handler
+	 * code, so if driver sends > 256, driver and firmware will be out of sync.  I am
+	 * fixing this in my firmware, but WARN here so we can know if other firmware would
+	 * ever see this problem.
+	 */
+	WARN_ON_ONCE(num_records > 256);
+
 	for (i = 0; i < num_records; i++) {
 		record = &resp->tx_fetch_ind.records[i];
 		peer_id = MS(le16_to_cpu(record->info),
@@ -3119,8 +3386,13 @@
 		 */
 
 		if (unlikely(!txq)) {
-			ath10k_warn(ar, "failed to lookup txq for peer_id %hu tid %hhu\n",
-				    peer_id, tid);
+			if (net_ratelimit()) {
+				ath10k_warn(ar, "fetch-ind: failed to lookup txq for peer_id %hu tid %hhu\n",
+					    peer_id, tid);
+				spin_lock_bh(&ar->data_lock);
+				ath10k_mac_print_txq_info(ar, peer_id, tid);
+				spin_unlock_bh(&ar->data_lock);
+			}
 			continue;
 		}
 
@@ -3283,8 +3555,9 @@
 		 */
 
 		if (unlikely(!txq)) {
-			ath10k_warn(ar, "failed to lookup txq for peer_id %hu tid %hhu\n",
-				    peer_id, tid);
+			if (net_ratelimit())
+				ath10k_warn(ar, "mode-switch: failed to lookup txq for peer_id %hu tid %hhu\n",
+					    peer_id, tid);
 			continue;
 		}
 
@@ -3321,7 +3594,19 @@
 			return i;
 	}
 
-	ath10k_warn(ar, "Invalid legacy rate %hhd peer stats", rate);
+	{
+		static bool done_once = 0;
+		if (!done_once) {
+			ath10k_warn(ar, "Invalid legacy rate %hhd peer stats",
+				    rate);
+			done_once = true;
+		}
+		else {
+			ath10k_dbg(ar, ATH10K_DBG_HTT,
+				   "Invalid legacy rate %hhd peer stats",
+				   rate);
+		}
+	}
 	return -EINVAL;
 }
 
@@ -3475,14 +3760,30 @@
 		return;
 
 	if (txrate.flags == WMI_RATE_PREAMBLE_VHT && txrate.mcs > 9) {
-		ath10k_warn(ar, "Invalid VHT mcs %hhd peer stats",  txrate.mcs);
+		static bool done_once = 0;
+		if (!done_once) {
+			ath10k_warn(ar, "Invalid VHT mcs %hhd peer stats",  txrate.mcs);
+			done_once = true;
+		}
+		else {
+			ath10k_dbg(ar, ATH10K_DBG_HTT, "Invalid VHT mcs %hhd peer stats",  txrate.mcs);
+		}
 		return;
 	}
 
 	if (txrate.flags == WMI_RATE_PREAMBLE_HT &&
 	    (txrate.mcs > 7 || txrate.nss < 1)) {
-		ath10k_warn(ar, "Invalid HT mcs %hhd nss %hhd peer stats",
-			    txrate.mcs, txrate.nss);
+		static bool done_once = 0;
+		if (!done_once) {
+			ath10k_warn(ar, "Invalid HT mcs %hhd nss %hhd peer stats",
+				    txrate.mcs, txrate.nss);
+			done_once = true;
+		}
+		else {
+			ath10k_dbg(ar, ATH10K_DBG_HTT,
+				   "Invalid HT mcs %hhd nss %hhd peer stats",
+				   txrate.mcs, txrate.nss);
+		}
 		return;
 	}
 
@@ -3593,8 +3894,17 @@
 	spin_lock_bh(&ar->data_lock);
 	peer = ath10k_peer_find_by_id(ar, peer_id);
 	if (!peer || !peer->sta) {
-		ath10k_warn(ar, "Invalid peer id %d peer stats buffer\n",
-			    peer_id);
+		static bool done_once = false;
+		if (!done_once) {
+			ath10k_warn(ar, "Invalid peer id %d or peer stats buffer, peer: %p  sta: %p\n",
+				    peer_id, peer, peer ? peer->sta : NULL);
+			done_once = true;
+		}
+		else {
+			ath10k_dbg(ar, ATH10K_DBG_HTT,
+				   "Invalid peer id %d or peer stats buffer, peer: %p  sta: %p\n",
+				   peer_id, peer, peer ? peer->sta : NULL);
+		}
 		goto out;
 	}
 
@@ -3747,6 +4057,16 @@
 	case HTT_T2H_MSG_TYPE_VERSION_CONF: {
 		htt->target_version_major = resp->ver_resp.major;
 		htt->target_version_minor = resp->ver_resp.minor;
+
+		/* CT firmware with HTT-MGT?  No official firmware has this
+		 * htt version combination as far as I am aware. --Ben
+		 */
+		if ((htt->target_version_major == 2 &&
+		     htt->target_version_minor == 2))
+			ar->ct_all_pkts_htt = true;
+		else
+			ar->ct_all_pkts_htt = false;
+
 		complete(&htt->target_version_received);
 		break;
 	}
@@ -3777,11 +4097,13 @@
 		break;
 	}
 	case HTT_T2H_MSG_TYPE_MGMT_TX_COMPLETION: {
-		struct htt_tx_done tx_done = {};
+		struct htt_tx_done tx_done = {0};
 		int status = __le32_to_cpu(resp->mgmt_tx_completion.status);
 		int info = __le32_to_cpu(resp->mgmt_tx_completion.info);
 
 		tx_done.msdu_id = __le32_to_cpu(resp->mgmt_tx_completion.desc_id);
+		tx_done.tx_rate_code = 0;
+		tx_done.tx_rate_flags = 0;
 
 		switch (status) {
 		case HTT_MGMT_TX_STATUS_OK:
@@ -3798,6 +4120,9 @@
 		case HTT_MGMT_TX_STATUS_RETRY:
 			tx_done.status = HTT_TX_COMPL_STATE_NOACK;
 			break;
+		case HTT_MGMT_TX_STATUS_TXFILT:
+			tx_done.status = HTT_TX_COMPL_STATE_NOACK;
+			break;
 		case HTT_MGMT_TX_STATUS_DROP:
 			tx_done.status = HTT_TX_COMPL_STATE_DISCARD;
 			break;
@@ -3821,9 +4146,23 @@
 		ath10k_htt_rx_sec_ind_handler(ar, ev);
 		ath10k_dbg(ar, ATH10K_DBG_HTT,
 			   "sec ind peer_id %d unicast %d type %d\n",
-			  __le16_to_cpu(ev->peer_id),
-			  !!(ev->flags & HTT_SECURITY_IS_UNICAST),
-			  MS(ev->flags, HTT_SECURITY_TYPE));
+			   __le16_to_cpu(ev->peer_id),
+			   !!(ev->flags & HTT_SECURITY_IS_UNICAST),
+			   MS(ev->flags, HTT_SECURITY_TYPE));
+
+		/* CT firmware adds way to determine failure of key set, without
+		 * just timing things out.  Indication of failure is determined
+		 * by the 6th bit of the security-type being set.
+		 */
+		if (ev->flags & HTT_SECURITY_IS_FAILURE) {
+			ath10k_warn(ar, "Firmware failed to set security key, peer_id: %d unicast %d type %d\n",
+				    __le16_to_cpu(ev->peer_id),
+				    !!(ev->flags & HTT_SECURITY_IS_UNICAST),
+				    MS(ev->flags, HTT_SECURITY_TYPE));
+			ar->install_key_rv = -EINVAL;
+		} else {
+			ar->install_key_rv = 0;
+		}
 		complete(&ar->install_key_done);
 		break;
 	}
@@ -3951,7 +4290,7 @@
 int ath10k_htt_txrx_compl_task(struct ath10k *ar, int budget)
 {
 	struct ath10k_htt *htt = &ar->htt;
-	struct htt_tx_done tx_done = {};
+	struct htt_tx_done tx_done = {0};
 	struct sk_buff_head tx_ind_q;
 	struct sk_buff *skb;
 	unsigned long flags;
diff -Nur linux-5.4.39/drivers/net/wireless/ath/ath10k/htt_tx.c linux-5.4.39-ct/drivers/net/wireless/ath/ath10k/htt_tx.c
--- linux-5.4.39/drivers/net/wireless/ath/ath10k/htt_tx.c	2020-05-06 07:15:17.000000000 +0100
+++ linux-5.4.39-ct/drivers/net/wireless/ath/ath10k/htt_tx.c	2020-05-12 23:23:34.000000000 +0100
@@ -145,8 +145,10 @@
 	lockdep_assert_held(&htt->tx_lock);
 
 	htt->num_pending_tx--;
-	if (htt->num_pending_tx == htt->max_num_pending_tx - 1)
+	if ((htt->num_pending_tx <= (htt->max_num_pending_tx / 4)) && htt->needs_unlock) {
+		htt->needs_unlock = false;
 		ath10k_mac_tx_unlock(htt->ar, ATH10K_TX_PAUSE_Q_FULL);
+	}
 }
 
 int ath10k_htt_tx_inc_pending(struct ath10k_htt *htt)
@@ -157,8 +159,10 @@
 		return -EBUSY;
 
 	htt->num_pending_tx++;
-	if (htt->num_pending_tx == htt->max_num_pending_tx)
+	if (htt->num_pending_tx == htt->max_num_pending_tx) {
+		htt->needs_unlock = true;
 		ath10k_mac_tx_lock(htt->ar, ATH10K_TX_PAUSE_Q_FULL);
+	}
 
 	return 0;
 }
@@ -531,6 +535,7 @@
 
 void ath10k_htt_tx_stop(struct ath10k_htt *htt)
 {
+
 	idr_for_each(&htt->pending_tx, ath10k_htt_tx_clean_up_pending, htt->ar);
 	idr_destroy(&htt->pending_tx);
 }
@@ -1146,12 +1151,53 @@
 
 	if (!is_eth && ieee80211_is_mgmt(hdr->frame_control))
 		return HTT_DATA_TX_EXT_TID_MGMT;
+
+	else if (ieee80211_is_nullfunc(hdr->frame_control))
+		return HTT_DATA_TX_EXT_TID_NON_QOS_MCAST_BCAST;
 	else if (cb->flags & ATH10K_SKB_F_QOS)
 		return skb->priority & IEEE80211_QOS_CTL_TID_MASK;
 	else
 		return HTT_DATA_TX_EXT_TID_NON_QOS_MCAST_BCAST;
 }
 
+/* Copied from ieee80211_is_robust_mgmt_frame, but disable the check for has_protected
+ * since we do tx hw crypt, and it won't actually be encrypted even when this flag is
+ * set.
+ */
+bool ieee80211_is_robust_mgmt_frame_tx(struct ieee80211_hdr *hdr)
+{
+        if (ieee80211_is_disassoc(hdr->frame_control) ||
+            ieee80211_is_deauth(hdr->frame_control))
+                return true;
+
+        if (ieee80211_is_action(hdr->frame_control)) {
+                u8 *category;
+
+                /*
+                 * Action frames, excluding Public Action frames, are Robust
+                 * Management Frames. However, if we are looking at a Protected
+                 * frame, skip the check since the data may be encrypted and
+                 * the frame has already been found to be a Robust Management
+                 * Frame (by the other end).
+                 */
+		/*
+		if (ieee80211_has_protected(hdr->frame_control))
+                        return true;
+		*/
+                category = ((u8 *) hdr) + 24;
+                return *category != WLAN_CATEGORY_PUBLIC &&
+                        *category != WLAN_CATEGORY_HT &&
+                        *category != WLAN_CATEGORY_WNM_UNPROTECTED &&
+                        *category != WLAN_CATEGORY_SELF_PROTECTED &&
+                        *category != WLAN_CATEGORY_UNPROT_DMG &&
+                        *category != WLAN_CATEGORY_VHT &&
+                        *category != WLAN_CATEGORY_VENDOR_SPECIFIC;
+        }
+
+        return false;
+}
+
+
 int ath10k_htt_mgmt_tx(struct ath10k_htt *htt, struct sk_buff *msdu)
 {
 	struct ath10k *ar = htt->ar;
@@ -1163,6 +1209,7 @@
 	int len = 0;
 	int msdu_id = -1;
 	int res;
+	int skb_len;
 	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)msdu->data;
 
 	len += sizeof(cmd->hdr);
@@ -1187,7 +1234,8 @@
 		goto err_free_msdu_id;
 	}
 
-	skb_cb->paddr = dma_map_single(dev, msdu->data, msdu->len,
+	skb_len = msdu->len;
+	skb_cb->paddr = dma_map_single(dev, msdu->data, skb_len,
 				       DMA_TO_DEVICE);
 	res = dma_mapping_error(dev, skb_cb->paddr);
 	if (res) {
@@ -1201,16 +1249,20 @@
 
 	cmd->hdr.msg_type         = HTT_H2T_MSG_TYPE_MGMT_TX;
 	cmd->mgmt_tx.msdu_paddr = __cpu_to_le32(ATH10K_SKB_CB(msdu)->paddr);
-	cmd->mgmt_tx.len        = __cpu_to_le32(msdu->len);
+	cmd->mgmt_tx.len        = __cpu_to_le32(skb_len);
 	cmd->mgmt_tx.desc_id    = __cpu_to_le32(msdu_id);
 	cmd->mgmt_tx.vdev_id    = __cpu_to_le32(vdev_id);
 	memcpy(cmd->mgmt_tx.hdr, msdu->data,
-	       min_t(int, msdu->len, HTT_MGMT_FRM_HDR_DOWNLOAD_LEN));
+	       min_t(int, skb_len, HTT_MGMT_FRM_HDR_DOWNLOAD_LEN));
 
 	res = ath10k_htc_send(&htt->ar->htc, htt->eid, txdesc);
 	if (res)
 		goto err_unmap_msdu;
 
+#ifdef CONFIG_ATH10K_DEBUGFS
+	ar->debug.tx_bytes += skb_len;
+#endif
+
 	return 0;
 
 err_unmap_msdu:
@@ -1231,7 +1283,8 @@
 	sizeof(struct htt_data_tx_desc) + \
 	sizeof(struct ath10k_htc_hdr))
 
-static int ath10k_htt_tx_hl(struct ath10k_htt *htt, enum ath10k_hw_txrx_mode txmode,
+static int ath10k_htt_tx_hl(struct ath10k_htt *htt, struct ieee80211_vif *vif,
+			    enum ath10k_hw_txrx_mode txmode,
 			    struct sk_buff *msdu)
 {
 	struct ath10k *ar = htt->ar;
@@ -1341,6 +1394,7 @@
 }
 
 static int ath10k_htt_tx_32(struct ath10k_htt *htt,
+			    struct ieee80211_vif *vif,
 			    enum ath10k_hw_txrx_mode txmode,
 			    struct sk_buff *msdu)
 {
@@ -1360,10 +1414,147 @@
 	u8 flags0 = 0;
 	u16 msdu_id, flags1 = 0;
 	u16 freq = 0;
+	int skb_len;
 	u32 frags_paddr = 0;
 	u32 txbuf_paddr;
 	struct htt_msdu_ext_desc *ext_desc = NULL;
 	struct htt_msdu_ext_desc *ext_desc_t = NULL;
+	u32 peer_id = HTT_INVALID_PEERID;
+	struct ath10k_vif *arvif = (void *)vif->drv_priv;
+
+	if (ar->state != ATH10K_STATE_ON) {
+		static bool done_once = 0;
+		if (!done_once) {
+			done_once = true;
+			ath10k_err(ar, "Invalid state: %d in ath10k_htt_tx_32, warning will not be repeated.\n",
+				   ar->state);
+			WARN_ON(1);
+		}
+		res = -ENODEV;
+		goto err;
+	}
+
+	if ((ar->eeprom_overrides.tx_debug & 0x3) &&
+	    (info->control.flags & IEEE80211_TX_CTRL_RATE_INJECT)) {
+		ath10k_warn(ar, "rate-inject, off-chan: %d txmode: %d\n",
+			    info->flags & IEEE80211_TX_CTL_TX_OFFCHAN, txmode);
+	}
+
+	/* ath10k_warn(ar, "info: %p  vif: %p arvif: %p txo-active: %d\n", info, vif, arvif, arvif && arvif->txo_active); */
+
+	if (unlikely(info->flags & IEEE80211_TX_CTL_TX_OFFCHAN))
+		freq = ar->scan.roc_freq;
+
+	else if (unlikely((arvif && arvif->txo_active)
+			  || (info->control.flags & IEEE80211_TX_CTRL_RATE_INJECT))) {
+		if (test_bit(ATH10K_FW_FEATURE_HAS_TX_RC_CT,
+			     ar->running_fw->fw_file.fw_features)) {
+			__le16 fc = hdr->frame_control;
+			enum nl80211_band band = info->band;
+			const struct ieee80211_supported_band *sband;
+			u8 tpc = 0xFF; /* don't need to set this */
+			u8 sgi = 0;
+			u8 mcs = 0;
+			u8 nss = 0;
+			u8 pream_type;
+			u8 num_retries;
+			u8 dyn_bw = 0;
+			u8 bw = 0;
+			u16 rix;
+			bool is_ht, is_vht;
+
+			sband = ar->hw->wiphy->bands[band];
+
+			rix = info->control.rates[0].idx;
+			is_ht = info->control.rates[0].flags & IEEE80211_TX_RC_MCS;
+			is_vht = info->control.rates[0].flags & IEEE80211_TX_RC_VHT_MCS;
+
+			if (info->control.flags & IEEE80211_TX_CTRL_RATE_INJECT) {
+				if (is_ht) {
+					mcs = rix % 8;
+					nss = rix / 8;
+					pream_type = WMI_RATE_PREAMBLE_HT;
+				/* VHT is untested: */
+				} else if (is_vht) {
+					mcs = ieee80211_rate_get_vht_mcs(&info->control.rates[0]);
+					nss = ieee80211_rate_get_vht_nss(&info->control.rates[0]); /* maybe -1? */
+					pream_type = WMI_RATE_PREAMBLE_VHT;
+				} else if (ath10k_mac_bitrate_is_cck(sband->bitrates[rix].bitrate)) {
+					mcs = sband->bitrates[rix].hw_value;
+					pream_type = WMI_RATE_PREAMBLE_CCK;
+				} else {
+					mcs = sband->bitrates[rix].hw_value; /* maybe - 4 ??? */
+					pream_type = WMI_RATE_PREAMBLE_OFDM;
+				}
+
+				num_retries = info->control.rates[0].count;
+			} else if ((msdu->len >= 100) &&
+			    (ieee80211_is_data_qos(fc) || ieee80211_is_data(fc)) &&
+			    (!(ieee80211_is_qos_nullfunc(fc) || ieee80211_is_nullfunc(fc)))) {
+				/* Only do the overrides for data frames. */
+				/*ath10k_warn(ar, "qos-data: %d data: %d  qos-nullfunc: %d  nullfunc: %d\n",
+					    ieee80211_is_data_qos(fc), ieee80211_is_data(fc),
+					    ieee80211_is_qos_nullfunc(fc), ieee80211_is_nullfunc(fc));*/
+				/* In order to allow ARP to work, don't mess with frames < 100 bytes in length, assume
+				 * test frames are larger.
+				 */
+
+				tpc = arvif->txo_tpc;
+				sgi = arvif->txo_sgi;
+				mcs = arvif->txo_mcs;
+				nss = arvif->txo_nss;
+				pream_type = arvif->txo_pream;
+				num_retries = arvif->txo_retries;
+				dyn_bw = arvif->txo_dynbw;
+				bw = arvif->txo_bw;
+				rix = arvif->txo_rix;
+				/*ath10k_warn(ar, "gathering txrate info from arvif, tpc: %d mcs: %d nss: %d pream_type: %d num_retries: %d dyn_bw: %d bw: %d rix: %d\n",
+				  tpc, mcs, nss, pream_type, num_retries, dyn_bw, bw, rix);*/
+			} else {
+				goto skip_fixed_rate;
+			}
+
+			if (ar->dev_id == QCA988X_2_0_DEVICE_ID ||
+			    ar->dev_id == QCA988X_2_0_DEVICE_ID_UBNT ||
+			    ar->dev_id == QCA9887_1_0_DEVICE_ID) {
+				/* wave-1 CT firmware has this API */
+				u32 rate_code = (pream_type << 6) | (nss << 4) | mcs;
+
+				if (num_retries == 0) {
+					/* Will never hit the air..surely this is not what user wanted! */
+					num_retries = 1;
+				}
+
+				peer_id = (0x8000); /* Earlier FW needed this, but this alone would break off-channel tx */
+				peer_id |= ((rate_code << 16) & 0xFF0000);
+				peer_id |= (((u32)(num_retries) << 24) & 0xF000000);
+				peer_id |= (0x20000000); /* Let FW know this is definitely a rate-code */
+
+				if (ar->eeprom_overrides.tx_debug & 0x3)
+					ath10k_warn(ar, "wave-1 vdev-id: %d msdu: %p  info: %p peer_id: 0x%x  rates.idx: %d  rate_code: 0x%x  hw-value: %d  bitrate: %d count: %d mcs: %d pream-type: %d  nss: %d\n",
+						    (int)(vdev_id), msdu, info, peer_id, rix, rate_code, sband->bitrates[rix].hw_value,
+						    sband->bitrates[rix].bitrate, (u32)(info->control.rates[0].count), mcs, pream_type, nss);
+			}
+			else {
+				if (unlikely(info->flags & IEEE80211_TX_CTL_NO_ACK)) {
+					num_retries = 0;
+				}
+
+				/* wave-2 supports this API */
+				peer_id = ath10k_convert_hw_rate_to_rate_info(tpc, mcs, sgi, nss, pream_type, num_retries, bw, dyn_bw);
+
+				if (ar->eeprom_overrides.tx_debug & 0x3)
+					ath10k_warn(ar, "wave-2 vdev-id: %d msdu: %p peer_id: 0x%x  tpc: %d sgi: %d mcs: %d nss: %d pream_type: %d num_retries: %d bw: %d dyn_bw: %d\n",
+						    (int)(vdev_id), msdu, peer_id, tpc, sgi, mcs, nss, pream_type, num_retries, bw, dyn_bw);
+			}
+		}
+	}
+
+skip_fixed_rate:
+	if (unlikely(info->flags & IEEE80211_TX_CTL_NO_ACK)) {
+		/* only works on wave-1, but should be properly ignored on wave-2 */
+		flags1 |= HTT_DATA_TX_DESC_FLAGS1_NO_ACK_CT;
+	}
 
 	res = ath10k_htt_tx_alloc_msdu_id(htt, msdu);
 	if (res < 0)
@@ -1378,17 +1569,25 @@
 	txbuf_paddr = htt->txbuf.paddr +
 		      (sizeof(struct ath10k_htt_txbuf_32) * msdu_id);
 
-	if ((ieee80211_is_action(hdr->frame_control) ||
-	     ieee80211_is_deauth(hdr->frame_control) ||
-	     ieee80211_is_disassoc(hdr->frame_control)) &&
-	     ieee80211_has_protected(hdr->frame_control)) {
-		skb_put(msdu, IEEE80211_CCMP_MIC_LEN);
-	} else if (!(skb_cb->flags & ATH10K_SKB_F_NO_HWCRYPT) &&
-		   txmode == ATH10K_HW_TXRX_RAW &&
-		   ieee80211_has_protected(hdr->frame_control)) {
-		skb_put(msdu, IEEE80211_CCMP_MIC_LEN);
+	if (ar->eeprom_overrides.tx_debug & 0x3) {
+		ath10k_warn(ar,
+			    "htt tx, is-action: %d  deauth: %d  disassoc: %d  has-protected: %d  nohwcrypt: %d txmode: %d data-qos: %d\n",
+			    ieee80211_is_action(hdr->frame_control), ieee80211_is_deauth(hdr->frame_control),
+			    ieee80211_is_disassoc(hdr->frame_control), ieee80211_has_protected(hdr->frame_control),
+			    skb_cb->flags & ATH10K_SKB_F_NO_HWCRYPT, txmode, ieee80211_is_data_qos(hdr->frame_control));
+	}
+
+	if (!(skb_cb->flags & ATH10K_SKB_F_NO_HWCRYPT)) {
+		if (ieee80211_is_robust_mgmt_frame_tx(hdr) &&
+		    ieee80211_has_protected(hdr->frame_control)) {
+			skb_put(msdu, IEEE80211_CCMP_MIC_LEN);
+		} else if (txmode == ATH10K_HW_TXRX_RAW &&
+			   ieee80211_has_protected(hdr->frame_control)) {
+			skb_put(msdu, IEEE80211_CCMP_MIC_LEN);
+		}
 	}
 
+	/* NOTE:  This writes over info->control.rates[0], at least. */
 	skb_cb->paddr = dma_map_single(dev, msdu->data, msdu->len,
 				       DMA_TO_DEVICE);
 	res = dma_mapping_error(dev, skb_cb->paddr);
@@ -1397,9 +1596,6 @@
 		goto err_free_msdu_id;
 	}
 
-	if (unlikely(info->flags & IEEE80211_TX_CTL_TX_OFFCHAN))
-		freq = ar->scan.roc_freq;
-
 	switch (txmode) {
 	case ATH10K_HW_TXRX_RAW:
 	case ATH10K_HW_TXRX_NATIVE_WIFI:
@@ -1495,17 +1691,32 @@
 		txbuf->cmd_tx.offchan_tx.freq =
 				__cpu_to_le16(freq);
 	} else {
-		txbuf->cmd_tx.peerid =
-				__cpu_to_le32(HTT_INVALID_PEERID);
+		txbuf->cmd_tx.peerid = __cpu_to_le32(peer_id);
 	}
 
+	skb_len = msdu->len;
 	trace_ath10k_htt_tx(ar, msdu_id, msdu->len, vdev_id, tid);
-	ath10k_dbg(ar, ATH10K_DBG_HTT,
-		   "htt tx flags0 %hhu flags1 %hu len %d id %hu frags_paddr %pad, msdu_paddr %pad vdev %hhu tid %hhu freq %hu\n",
-		   flags0, flags1, msdu->len, msdu_id, &frags_paddr,
-		   &skb_cb->paddr, vdev_id, tid, freq);
-	ath10k_dbg_dump(ar, ATH10K_DBG_HTT_DUMP, NULL, "htt tx msdu: ",
-			msdu->data, msdu->len);
+
+	if (ar->eeprom_overrides.tx_debug & 0x3) {
+		ath10k_warn(ar,
+			    "htt tx flags0 %hhu flags1 %hu (noack: %d) len %d id %hu frags_paddr %pad, msdu_paddr %pad vdev %hhu tid %hhu freq %hu\n",
+			    flags0, flags1, (flags1 & HTT_DATA_TX_DESC_FLAGS1_NO_ACK_CT), skb_len, msdu_id, &frags_paddr,
+			    &skb_cb->paddr, vdev_id, tid, freq);
+		if (ar->eeprom_overrides.tx_debug & 0x10) {
+			ath10k_dbg_dump(ar, ATH10K_DBG_BOOT, NULL, "htt tx msdu: ",
+					msdu->data, skb_len);
+		}
+	}
+	else {
+		ath10k_dbg(ar, ATH10K_DBG_HTT,
+			   "htt tx flags0 %hhu flags1 %hu len %d id %hu frags_paddr %pad, msdu_paddr %pad vdev %hhu tid %hhu freq %hu\n",
+			   flags0, flags1, skb_len, msdu_id, &frags_paddr,
+			   &skb_cb->paddr, vdev_id, tid, freq);
+
+		ath10k_dbg_dump(ar, ATH10K_DBG_HTT_DUMP, NULL, "htt tx msdu: ",
+				msdu->data, skb_len);
+	}
+
 	trace_ath10k_tx_hdr(ar, msdu->data, msdu->len);
 	trace_ath10k_tx_payload(ar, msdu->data, msdu->len);
 
@@ -1530,6 +1741,10 @@
 	if (res)
 		goto err_unmap_msdu;
 
+#ifdef CONFIG_ATH10K_DEBUGFS
+	ar->debug.tx_bytes += skb_len;
+#endif
+
 	return 0;
 
 err_unmap_msdu:
@@ -1541,6 +1756,7 @@
 }
 
 static int ath10k_htt_tx_64(struct ath10k_htt *htt,
+			    struct ieee80211_vif *vif,
 			    enum ath10k_hw_txrx_mode txmode,
 			    struct sk_buff *msdu)
 {
@@ -1565,6 +1781,18 @@
 	struct htt_msdu_ext_desc_64 *ext_desc = NULL;
 	struct htt_msdu_ext_desc_64 *ext_desc_t = NULL;
 
+	if (ar->state != ATH10K_STATE_ON) {
+		static bool done_once = 0;
+		if (!done_once) {
+			done_once = true;
+			ath10k_err(ar, "Invalid state: %d in ath10k_htt_tx_64, warning will not be repeated.\n",
+				   ar->state);
+			WARN_ON(1);
+		}
+		res = -ENODEV;
+		goto err;
+	}
+
 	res = ath10k_htt_tx_alloc_msdu_id(htt, msdu);
 	if (res < 0)
 		goto err;
diff -Nur linux-5.4.39/drivers/net/wireless/ath/ath10k/hw.c linux-5.4.39-ct/drivers/net/wireless/ath/ath10k/hw.c
--- linux-5.4.39/drivers/net/wireless/ath/ath10k/hw.c	2020-05-06 07:15:17.000000000 +0100
+++ linux-5.4.39-ct/drivers/net/wireless/ath/ath10k/hw.c	2020-05-12 23:23:34.000000000 +0100
@@ -581,7 +581,7 @@
 	survey->time_busy = CCNT_TO_MSEC(ar, rcc);
 }
 
-/* The firmware does not support setting the coverage class. Instead this
+/* The stock firmware does not support setting the coverage class. Instead this
  * function monitors and modifies the corresponding MAC registers.
  */
 static void ath10k_hw_qca988x_set_coverage_class(struct ath10k *ar,
@@ -632,6 +632,15 @@
 	    phyclk_reg == ar->fw_coverage.reg_phyclk)
 		goto unlock;
 
+	{
+		static int did_once = 0;
+		if (!did_once) {
+			ath10k_warn(ar, "set-coverage-class, phyclk: %d  value: %d\n", phyclk, value);
+			did_once = true;
+		}
+	}
+
+
 	/* Store new initial register values from the firmware. */
 	if (slottime_reg != ar->fw_coverage.reg_slottime_conf)
 		ar->fw_coverage.reg_slottime_orig = slottime_reg;
@@ -692,6 +701,22 @@
 			   WLAN_MAC_BASE_ADDRESS + WAVE1_PCU_ACK_CTS_TIMEOUT,
 			   timeout_reg);
 
+	if (test_bit(ATH10K_FW_FEATURE_SET_SPECIAL_CT,
+		     ar->running_fw->fw_file.fw_features)) {
+		/* CT firmware can set and make this value stick w/out all the hackery,
+		 * but go ahead and use this logic to calculate the appropriate values.
+		 * We should then short-circuit this logic earlier in this method because
+		 * the values in the firmware will already match expected values.
+		 * --Ben
+		 */
+		ar->eeprom_overrides.reg_ack_cts = timeout_reg;
+		ar->eeprom_overrides.reg_ifs_slot = slottime_reg;
+
+		ath10k_wmi_pdev_set_special(ar, SET_SPECIAL_ID_ACK_CTS, ar->eeprom_overrides.reg_ack_cts);
+		ath10k_wmi_pdev_set_special(ar, SET_SPECIAL_ID_SLOT, ar->eeprom_overrides.reg_ifs_slot);
+		ar->eeprom_overrides.coverage_already_set = true;
+	}
+
 	/* Ensure we have a debug level of WARN set for the case that the
 	 * coverage class is larger than 0. This is important as we need to
 	 * set the registers again if the firmware does an internal reset and
diff -Nur linux-5.4.39/drivers/net/wireless/ath/ath10k/hw.h linux-5.4.39-ct/drivers/net/wireless/ath/ath10k/hw.h
--- linux-5.4.39/drivers/net/wireless/ath/ath10k/hw.h	2020-05-06 07:15:17.000000000 +0100
+++ linux-5.4.39-ct/drivers/net/wireless/ath/ath10k/hw.h	2020-05-12 23:23:34.000000000 +0100
@@ -162,6 +162,8 @@
 
 #define REG_DUMP_COUNT_QCA988X 60
 
+#define ATH10K_FW_STACK_SIZE 4096
+
 struct ath10k_fw_ie {
 	__le32 id;
 	__le32 len;
@@ -187,6 +189,8 @@
 
 	/* Code swap image for firmware binary */
 	ATH10K_FW_IE_FW_CODE_SWAP_IMAGE = 7,
+
+	ATH10K_FW_IE_BSS_INFO_CT = 30,
 };
 
 enum ath10k_fw_wmi_op_version {
@@ -723,6 +727,26 @@
 						 (TARGET_10X_NUM_VDEVS))
 #define TARGET_10X_TX_STATS_NUM_PEERS		((TARGET_10X_TX_STATS_NUM_STATIONS) + \
 						 (TARGET_10X_NUM_VDEVS))
+
+/* Over-rides for Candela Technologies firmware */
+#define DEF_TARGET_10X_NUM_VDEVS_CT		16 /* Can support up to 64 with proper config of other settings.
+						    * override w/module parm or fwcfg file */
+/* NOTE:  AST can really hold 4 keys, and there can be some temporarily in use as well.  So this
+ * needs to be pretty large.  256 works in my testing with 64 station vdevs (360 works better). --Ben
+ */
+#define TARGET_10X_AST_SKID_LIMIT_CT		360 /*((ath10k_modparam_target_num_peers_ct * TARGET_10X_NUM_PEER_AST)*/
+#define TARGET_10X_NUM_PEER_KEYS_CT             (WMI_MAX_KEY_INDEX + 1) /* 4 */
+
+/* Related to HTC buffers */
+/* return any credit immediately */
+#define TARGET_HTC_MAX_PENDING_TXCREDITS_RPTS   1
+/* 8 ctrl buffers for sending info to host */
+#define TARGET_HTC_MAX_CONTROL_BUFFERS          6
+/* Only CT firmware will actually use this value.  Each buffer is close to 2K
+ * of firmware RAM, so not sure if increasing this is worth the RAM cost.
+ */
+#define TARGET_HTC_MAX_TX_CREDITS_CT            4
+
 #define TARGET_10X_NUM_OFFLOAD_PEERS		0
 #define TARGET_10X_NUM_OFFLOAD_REORDER_BUFS	0
 #define TARGET_10X_NUM_PEER_KEYS		2
@@ -971,6 +995,7 @@
 #define PCIE_INTR_ENABLE_ADDRESS		0x0008
 #define PCIE_INTR_CAUSE_ADDRESS			0x000c
 #define PCIE_INTR_CLR_ADDRESS			ar->regs->pcie_intr_clr_address
+#define SCRATCH_2_ADDRESS                       0x002c
 #define SCRATCH_3_ADDRESS			ar->regs->scratch_3_address
 #define CPU_INTR_ADDRESS			0x0010
 #define FW_RAM_CONFIG_ADDRESS			0x0018
@@ -983,6 +1008,10 @@
 #define FW_IND_INITIALIZED			2
 #define FW_IND_HOST_READY			0x80000000
 
+/* CT firmware only */
+#define FW_IND_SCRATCH2_WR      (1<<14) /* scratch2 has data written to it */
+#define FW_IND_SCRATCH2_RD      (1<<15) /* scratch2 has been read (by host) */
+
 /* HOST_REG interrupt from firmware */
 #define PCIE_INTR_FIRMWARE_MASK			ar->regs->pcie_intr_fw_mask
 #define PCIE_INTR_CE_MASK_ALL			ar->regs->pcie_intr_ce_mask_all
@@ -1198,4 +1227,25 @@
 #define REGION_ACCESS_SIZE_LIMIT	0x100000
 #define REGION_ACCESS_SIZE_MASK		(REGION_ACCESS_SIZE_LIMIT - 1)
 
+/* Target debug log related defines and structs */
+
+/* Target is 32-bit CPU, so we just use u32 for
+ * the pointers.  The memory space is relative to the
+ * target, not the host.  Values are converted to host
+ * byte order when reading from firmware.
+ */
+struct ath10k_fw_dbglog_buf {
+	__le32 next; /* pointer to ath10k_fw_dbglog_buf. */
+	__le32 buffer; /* pointer to u8 buffer */
+	__le32 bufsize;
+	__le32 length;
+	__le32 count;
+	__le32 free;
+} __packed;
+
+struct ath10k_fw_dbglog_hdr {
+	__le32 dbuf; /* pointer to ath10k_fw_dbglog_buf */
+	__le32 dropped;
+} __packed;
+
 #endif /* _HW_H_ */
diff -Nur linux-5.4.39/drivers/net/wireless/ath/ath10k/mac.c linux-5.4.39-ct/drivers/net/wireless/ath/ath10k/mac.c
--- linux-5.4.39/drivers/net/wireless/ath/ath10k/mac.c	2020-05-06 07:15:17.000000000 +0100
+++ linux-5.4.39-ct/drivers/net/wireless/ath/ath10k/mac.c	2020-05-12 23:23:34.000000000 +0100
@@ -12,6 +12,7 @@
 #include <linux/etherdevice.h>
 #include <linux/acpi.h>
 #include <linux/of.h>
+#include <linux/module.h>
 
 #include "hif.h"
 #include "core.h"
@@ -93,7 +94,7 @@
 
 #define ath10k_wmi_legacy_rates ath10k_rates
 
-static bool ath10k_mac_bitrate_is_cck(int bitrate)
+bool ath10k_mac_bitrate_is_cck(int bitrate)
 {
 	switch (bitrate) {
 	case 10:
@@ -146,6 +147,77 @@
 	return 0;
 }
 
+/* Create a rate-info object that (some) 10.4 CT firmware
+ * can understand.
+ */
+u32 ath10k_convert_hw_rate_to_rate_info(u8 tpc, u8 mcs, u8 sgi, u8 nss, u8 pream_type,
+					u8 num_retries, u8 bw, u8 dyn_bw)
+{
+
+	/* Re-use logic from 10.4 firmware */
+	struct __ath10k_rate_info {
+		u32     power              : 6,   /* units of the power field is 1/2 dbm */
+			unused             : 1,   /* Room for growth */
+			sgi                : 1,   /* Enable SGI or not, checked when valid_rate is enabled. */
+			mcs                : 4,    /* mcs = 0 ~ 9 */
+			nss                : 2,    /* 0 = 1 nss, 1 = 2 nss, 2 = 3 nss, 3 = 4 nss */
+			pream_type         : 2,    /* 0 = WIFI_RATECODE_PREAM_OFDM,
+						      1 = WIFI_RATECODE_PREAM_CCK,
+						      2 = WIFI_RATECODE_PREAM_HT ,
+						      3 = WIFI_RATECODE_PREAM_VHT */
+			num_retries        : 4,    /* 0 ~ 15:  0 means no-ack */
+			dyn_bw             : 1,    /* 0 = static bw, 1 = dynamic bw */
+			bw                 : 3,    /* valid only if dyn_bw == 0 (static bw).
+						      (0 = 20 mhz, 1 = 40 mhz, 2 = 80 mhz, 3 = 160 mhz , 4 = 80+80mhz) */
+			valid_power        : 1,   /*  power info field has valid power. */
+			valid_rate         : 1,    /*  mcs,nss,pream_type fields have valid rates. */
+			valid_num_retries  : 1,    /*  num_retries field has valid value */
+			valid_dyn_bw       : 1,    /*  dyn_bw field has valid value */
+			valid_bw           : 1,    /*   bw field has valid value */
+
+			any_valid          : 1,    /* 1 : htt_tx_msdu_desc_t contains valid tx meta data */
+			key_id             : 2;    /* key index 0 to 3 for per packet key rotation */
+	};
+
+	struct __ath10k_rate_info ri;
+	u32 *rvi = (u32*)(&ri);
+	rvi[0] = 0;
+
+	if (tpc != 0xFF) {
+		ri.power = tpc;
+		ri.valid_power = 1;
+		ri.any_valid = 1;
+	}
+
+	if (mcs != 0xFF) {
+		ri.mcs = mcs;
+		ri.nss = nss;
+		ri.pream_type = pream_type;
+		ri.sgi = sgi;
+		ri.valid_rate = 1;
+		ri.any_valid = 1;
+	}
+
+	if (num_retries != 0xFF) {
+		ri.num_retries = num_retries;
+		ri.valid_num_retries = 1;
+		ri.any_valid = 1;
+	}
+
+	if (dyn_bw != 0xFF) {
+		ri.dyn_bw = dyn_bw;
+		ri.valid_dyn_bw = 1;
+		if (ri.dyn_bw == 0) {
+			ri.bw = bw;
+			ri.valid_bw = 1;
+		}
+		ri.any_valid = 1;
+	}
+
+	/* leave key-id set to zero for now */
+	return rvi[0];
+}
+
 static int ath10k_mac_get_rate_hw_value(int bitrate)
 {
 	int i;
@@ -216,6 +288,55 @@
 	return 0;
 }
 
+/* 0:  Full hardware crypt
+ * 1:  Tx hardware crypt, but expect rx software crypt (use native wifi tx type)
+ */
+int ath10k_modparam_nohwcrypt;
+module_param_named(nohwcrypt, ath10k_modparam_nohwcrypt, int, 0444);
+MODULE_PARM_DESC(nohwcrypt, "Disable hardware rx decrypt feature");
+
+int ath10k_modparam_ct_sta;
+module_param_named(ct_sta, ath10k_modparam_ct_sta, int, 0444);
+MODULE_PARM_DESC(ct_sta, "Use CT-STA mode, a bit like proxy-STA");
+
+int ath10k_modparam_nobeamform_mu;
+module_param_named(nobeamform_mu, ath10k_modparam_nobeamform_mu, int, 0444);
+MODULE_PARM_DESC(nobeamform_mu, "Disable TX/RX MU Beamforming capabilities");
+
+int ath10k_modparam_nobeamform_su;
+module_param_named(nobeamform_su, ath10k_modparam_nobeamform_su, int, 0444);
+MODULE_PARM_DESC(nobeamform_su, "Disable TX/RX SU Beamforming capabilities");
+
+int ath10k_modparam_target_num_vdevs_ct = DEF_TARGET_10X_NUM_VDEVS_CT;
+module_param_named(num_vdevs_ct, ath10k_modparam_target_num_vdevs_ct, int, 0444);
+MODULE_PARM_DESC(num_vdevs_ct, "Maximum vdevs to request from firmware");
+
+/* More than 127 seems to cause issues when using HW de-crypt, so default to 127. */
+int ath10k_modparam_target_num_peers_ct = 127;
+module_param_named(num_peers_ct, ath10k_modparam_target_num_peers_ct, int, 0444);
+MODULE_PARM_DESC(num_peers_ct, "Maximum peers to request from firmware");
+
+/* These consume a fair bit of RAM on target. */
+int ath10k_modparam_target_num_msdu_desc_ct = TARGET_10X_NUM_MSDU_DESC;
+module_param_named(num_msdu_desc_ct, ath10k_modparam_target_num_msdu_desc_ct, int, 0444);
+MODULE_PARM_DESC(num_msdu_desc_ct, "Maximum MSDU Descriptors in firmware (must be multiple of 8)");
+
+/* The firmware tries to cache rate-ctrl objects in the host (driver) memory.  But,
+ * with lots of active stations, this appears to cause constant cache swapping and
+ * in the end, rate-ctrl fails to work well at all.
+ * CT Firmware has lots of RAM savings, especially when using fewer than 64 vdevs,
+ * so allow users to configure more than the default (currently 32) of in-ram
+ * rate-ctrl objects.  As long as firmware RAM is available, allocating as many
+ * rate-ctrl objects as possible (up to number of peers) is probably a good idea.
+ * This setting should be harmless in all CT firmware, but it will only have an
+ * effect in beta-16 firmware and later.  Setting value to 0 means use firmware
+ * defaults.
+ */
+int ath10k_modparam_target_num_rate_ctrl_objs_ct = 0;
+module_param_named(num_rate_ctrl_objs_ct, ath10k_modparam_target_num_rate_ctrl_objs_ct, int, 0444);
+MODULE_PARM_DESC(num_rate_ctrl_objs_ct, "Number of rate-ctrl objects to cache in firmware RAM");
+
+
 /**********/
 /* Crypto */
 /**********/
@@ -234,6 +355,7 @@
 		.key_flags = flags,
 		.macaddr = macaddr,
 	};
+	int ret1, ret2;
 
 	lockdep_assert_held(&arvif->ar->conf_mutex);
 
@@ -277,7 +399,13 @@
 		arg.key_data = NULL;
 	}
 
-	return ath10k_wmi_vdev_install_key(arvif->ar, &arg);
+	ret1 = ath10k_wmi_vdev_install_key(arvif->ar, &arg);
+	ret2 = ath10k_wmi_barrier(ar);
+	if (ret2) {
+		ath10k_err(ar, "failed to ping firmware: %d\n", ret2);
+		return ret2;
+	}
+	return ret1;
 }
 
 static int ath10k_install_key(struct ath10k_vif *arvif,
@@ -304,7 +432,8 @@
 	if (time_left == 0)
 		return -ETIMEDOUT;
 
-	return 0;
+	ret = ar->install_key_rv;
+	return ret;
 }
 
 static int ath10k_install_peer_wep_keys(struct ath10k_vif *arvif,
@@ -733,8 +862,11 @@
 	list_for_each_entry(arvif, &ar->arvifs, list)
 		num_peers++;
 
-	if (num_peers >= ar->max_num_peers)
+	if (num_peers >= ar->max_num_peers) {
+		ath10k_warn(ar, "failed to create peer %pM for vdev %d, too-many-peers (ar->num_peers: %d  num_peers: %d  max_peers: %d)\n",
+			    sta->addr, vdev_id, ar->num_peers, num_peers, ar->max_num_peers);
 		return -ENOBUFS;
+	}
 
 	ret = ath10k_wmi_peer_create(ar, vdev_id, addr, peer_type);
 	if (ret) {
@@ -771,21 +903,26 @@
 	return 0;
 }
 
+int ath10k_mac_set_pdev_kickout(struct ath10k *ar)
+{
+	u32 param = ar->wmi.pdev_param->sta_kickout_th;
+	int rv;
+
+	rv = ath10k_wmi_pdev_set_param(ar, param,
+				       ar->sta_xretry_kickout_thresh);
+	if (rv) {
+		ath10k_warn(ar, "failed to set sta kickout threshold to %d: %d\n",
+			    ar->sta_xretry_kickout_thresh, rv);
+	}
+	return rv;
+}
+
 static int ath10k_mac_set_kickout(struct ath10k_vif *arvif)
 {
 	struct ath10k *ar = arvif->ar;
 	u32 param;
 	int ret;
 
-	param = ar->wmi.pdev_param->sta_kickout_th;
-	ret = ath10k_wmi_pdev_set_param(ar, param,
-					ATH10K_KICKOUT_THRESHOLD);
-	if (ret) {
-		ath10k_warn(ar, "failed to set kickout threshold on vdev %i: %d\n",
-			    arvif->vdev_id, ret);
-		return ret;
-	}
-
 	param = ar->wmi.vdev_param->ap_keepalive_min_idle_inactive_time_secs;
 	ret = ath10k_wmi_vdev_set_param(ar, arvif->vdev_id, param,
 					ATH10K_KEEPALIVE_MIN_IDLE);
@@ -828,14 +965,20 @@
 static int ath10k_peer_delete(struct ath10k *ar, u32 vdev_id, const u8 *addr)
 {
 	int ret;
+	int tries = 3;
 
 	lockdep_assert_held(&ar->conf_mutex);
 
-	ret = ath10k_wmi_peer_delete(ar, vdev_id, addr);
-	if (ret)
-		return ret;
+	do {
+		ret = ath10k_wmi_peer_delete(ar, vdev_id, addr);
+		if (ret)
+			return ret;
+
+		ret = ath10k_wait_for_peer_deleted(ar, vdev_id, addr);
+		if (ret == 0) /* else, try again, maybe FW dropped a msg? */
+			break;
+	} while (--tries);
 
-	ret = ath10k_wait_for_peer_deleted(ar, vdev_id, addr);
 	if (ret)
 		return ret;
 
@@ -874,6 +1017,8 @@
 
 		for_each_set_bit(peer_id, peer->peer_ids,
 				 ATH10K_MAX_NUM_PEER_IDS) {
+			ath10k_warn(ar, "removing peer mapping %pM peer-id: %d\n",
+				    peer->addr, peer_id);
 			ar->peer_map[peer_id] = NULL;
 		}
 
@@ -895,6 +1040,24 @@
 	spin_unlock_bh(&ar->data_lock);
 }
 
+void ath10k_dump_peer_info(struct ath10k *ar)
+{
+	struct ath10k_peer *peer;
+	int peer_id;
+
+	lockdep_assert_held(&ar->data_lock);
+
+	list_for_each_entry(peer, &ar->peers, list) {
+		ath10k_warn(ar, "peer: %p vdev: %d  addr: %pM\n",
+			    peer, peer->vdev_id, peer->addr);
+		for_each_set_bit(peer_id, peer->peer_ids,
+				 ATH10K_MAX_NUM_PEER_IDS) {
+			ath10k_warn(ar, "  peer %pM peer-id: %d\n",
+				    peer->addr, peer_id);
+		}
+	}
+}
+
 static void ath10k_peer_cleanup_all(struct ath10k *ar)
 {
 	struct ath10k_peer *peer, *tmp;
@@ -904,6 +1067,8 @@
 
 	spin_lock_bh(&ar->data_lock);
 	list_for_each_entry_safe(peer, tmp, &ar->peers, list) {
+		ath10k_warn(ar, "removing peer, cleanup-all, deleting: peer %p vdev: %d addr: %pM \n",
+			    peer, peer->vdev_id, peer->addr);
 		list_del(&peer->list);
 		kfree(peer);
 	}
@@ -1008,6 +1173,40 @@
 	return ar->last_wmi_vdev_start_status;
 }
 
+static u32 ath10k_get_max_antenna_gain(struct ath10k *ar,
+				       u32 ch_max_antenna_gain)
+{
+	u32 max_antenna_gain;
+
+	if (ar->dfs_detector && ar->dfs_detector->region == NL80211_DFS_FCC) {
+		/* FCC allows maximum antenna gain of 6 dBi. 15.247(b)(4):
+		 *
+		 * > (4) The conducted output power limit
+		 * > specified in paragraph (b) of this section
+		 * > is based on the use of antennas
+		 * > with directional gains that do not exceed
+		 * > 6 dBi. Except as shown in paragraph
+		 * > (c) of this section, if transmitting
+		 * > antennas of directional gain greater
+		 * > than 6 dBi are used, the conducted
+		 * > output power from the intentional radiator
+		 * > shall be reduced below the stated
+		 * > values in paragraphs (b)(1), (b)(2),
+		 * > and (b)(3) of this section, as appropriate,
+		 * > by the amount in dB that the
+		 * > directional gain of the antenna exceeds
+		 * > 6 dBi.
+		 *
+		 * https://www.gpo.gov/fdsys/pkg/CFR-2013-title47-vol1/pdf/CFR-2013-title47-vol1-sec15-247.pdf
+		 */
+		max_antenna_gain = 6;
+	} else {
+		max_antenna_gain = 0;
+	}
+
+	return max(ch_max_antenna_gain, max_antenna_gain);
+}
+
 static int ath10k_monitor_vdev_start(struct ath10k *ar, int vdev_id)
 {
 	struct cfg80211_chan_def *chandef = NULL;
@@ -1040,7 +1239,8 @@
 	arg.channel.min_power = 0;
 	arg.channel.max_power = channel->max_power * 2;
 	arg.channel.max_reg_power = channel->max_reg_power * 2;
-	arg.channel.max_antenna_gain = channel->max_antenna_gain * 2;
+	arg.channel.max_antenna_gain = ath10k_get_max_antenna_gain(ar,
+						channel->max_antenna_gain);
 
 	reinit_completion(&ar->vdev_setup_done);
 	reinit_completion(&ar->vdev_delete_done);
@@ -1486,7 +1686,24 @@
 	arg.channel.min_power = 0;
 	arg.channel.max_power = chandef->chan->max_power * 2;
 	arg.channel.max_reg_power = chandef->chan->max_reg_power * 2;
-	arg.channel.max_antenna_gain = chandef->chan->max_antenna_gain * 2;
+	arg.channel.max_antenna_gain = ath10k_get_max_antenna_gain(ar,
+					chandef->chan->max_antenna_gain);
+
+	/* CT Firmware can support 32+ VDEVS, but can only support
+	 * beacon-ing devs with dev ids 0 - 31 due to firmware limitations.
+	 * Create VAPs first and all should be well...likely most people
+	 * won't ever hit this anyway, but some day the vdev ID allocation
+	 * could be made smarter to make it more likely to work no matter the
+	 * order the vdevs are created. --Ben
+	 */
+	if ((arvif->vdev_type == WMI_VDEV_TYPE_AP) ||
+	    (arvif->vdev_type == WMI_VDEV_TYPE_IBSS)) {
+		if (arg.vdev_id > 31) {
+			ath10k_warn(ar, "failed to start vdev %i  Beaconing VIFS must have IDs <= 31 to work-around firmware limitations.\n",
+				    arg.vdev_id);
+			return -EINVAL;
+		}
+	}
 
 	if (arvif->vdev_type == WMI_VDEV_TYPE_AP) {
 		arg.ssid = arvif->u.ap.ssid;
@@ -1502,9 +1719,9 @@
 	}
 
 	ath10k_dbg(ar, ATH10K_DBG_MAC,
-		   "mac vdev %d start center_freq %d phymode %s\n",
+		   "mac vdev %d start center_freq %d phymode %s beacon-int: %d\n",
 		   arg.vdev_id, arg.channel.freq,
-		   ath10k_wmi_phymode_str(arg.channel.mode));
+		   ath10k_wmi_phymode_str(arg.channel.mode), arg.bcn_intval);
 
 	if (restart)
 		ret = ath10k_wmi_vdev_restart(ar, &arg);
@@ -1519,9 +1736,14 @@
 
 	ret = ath10k_vdev_setup_sync(ar);
 	if (ret) {
-		ath10k_warn(ar,
-			    "failed to synchronize setup for vdev %i restart %d: %d\n",
+		ath10k_err(ar,
+			    "Failed to synchronize setup for vdev %i restart %d: %d, will restart firmware\n",
 			    arg.vdev_id, restart, ret);
+		/* I see this on a wave-1 NIC when doing lots of station create/delete very fast.
+		 * In my particular case, the keepalive timer is also showing communication errors.
+		 * Reset the NIC by faking a crash, it seems unlikely it will recover. --Ben
+		 */
+		ath10k_hif_fw_crashed_dump(ar);
 		return ret;
 	}
 
@@ -1970,6 +2192,16 @@
 	return 0;
 }
 
+static int ath10k_mac_vif_config_retry_limit(struct ath10k_vif *arvif, int limit)
+{
+	struct ath10k *ar = arvif->ar;
+	int vdev_param = ar->wmi.vdev_param->rc_num_retries;
+
+	lockdep_assert_held(&arvif->ar->conf_mutex);
+
+	return ath10k_wmi_vdev_set_param(ar, arvif->vdev_id, vdev_param, limit);
+}
+
 static int ath10k_mac_vif_disable_keepalive(struct ath10k_vif *arvif)
 {
 	struct ath10k *ar = arvif->ar;
@@ -2278,6 +2510,209 @@
 	return true;
 }
 
+static void ath10k_set_rate_enabled(int rix, u8 *rt_array, int val) {
+	int idx = rix / 8;
+	int bit = rix - (idx * 8);
+
+	//pr_err(" rix: %d  idx: %d  bit: %d\n", rix, idx, bit);
+	if (WARN_ON_ONCE(idx >= RATE_OVERRIDES_COUNT))
+		return;
+
+	if (val) {
+		rt_array[idx] |= (1<<bit);
+	}
+	else {
+		rt_array[idx] &= ~(1<<bit);
+	}
+}
+
+static void ath10k_peer_assoc_h_rate_overrides(struct ath10k *ar,
+					       struct ieee80211_vif *vif,
+					       struct ieee80211_sta *sta,
+					       struct wmi_peer_assoc_complete_arg *arg)
+{
+	struct ath10k_vif *arvif = (void *)vif->drv_priv;
+	const struct ieee80211_supported_band *sband;
+	const struct ieee80211_rate *rates;
+	struct cfg80211_chan_def def;
+	enum nl80211_band band;
+	u32 ratemask;
+	int i;
+	int j;
+	int hw_rix;
+	bool ok160 = false;
+	u16 rate_bw_disable_mask = ar->eeprom_overrides.rate_bw_disable_mask;
+
+	/* So, what we really want here is the max number of chains the firmware
+	 * is compiled for.  But, since we can have 3x3 firmware run on 2x2 chips,
+	 * then we need to hack on this in gruesome ways.  Better have the hack here
+	 * than try to extend FW's ability to send that value I think.
+	 */
+	int hw_nss = ar->num_rf_chains;
+	if (! test_bit(ATH10K_FW_FEATURE_CT_RATEMASK,
+		       ar->running_fw->fw_file.fw_features))
+		return;
+
+	/* Ignore devices not known to be supported, this is a minor feature and
+	 * not worth breaking systems for users that don't need it.
+	 */
+	if (!((ar->dev_id == QCA9887_1_0_DEVICE_ID) ||
+	      (ar->dev_id == QCA988X_2_0_DEVICE_ID) ||
+	      (ar->dev_id == QCA9888_2_0_DEVICE_ID) || /* Wave-2 2x2 MU-MIMO NIC */
+	      (ar->dev_id == QCA99X0_2_0_DEVICE_ID) ||
+	      (ar->dev_id == QCA9984_1_0_DEVICE_ID))) {
+#ifdef STANDALONE_CT
+		/* Assume OpenWRT/LEDE users don't need this anyway, so don't warn loudly. */
+		ath10k_dbg(ar, ATH10K_DBG_MAC,
+			   "rate-override:  Skipping un-supported device-id, hw-nss: %d dev-id: 0x%x\n",
+			   hw_nss, ar->dev_id);
+#else
+		ath10k_warn(ar, "rate-override:  Skipping un-supported device-id, hw-nss: %d dev-id: 0x%x\n",
+			    hw_nss, ar->dev_id);
+#endif
+		return;
+	}
+
+	if ((ar->dev_id == QCA9984_1_0_DEVICE_ID) ||
+	    (ar->dev_id == QCA9888_2_0_DEVICE_ID)) {
+		ok160 = true;
+	}
+
+	if (hw_nss < 3) {
+		/* Maybe 2x2 NIC booting 3x3 988x firmware? */
+		/* 9887 is weird, NSS = 1, but FW rate-table is compiled for 3x3 evidently */
+		if ((ar->dev_id == QCA988X_2_0_DEVICE_ID) ||
+		    (ar->dev_id == QCA9887_1_0_DEVICE_ID)) {
+			hw_nss = 3;
+		}
+	}
+
+	lockdep_assert_held(&ar->conf_mutex);
+
+	if (WARN_ON(ath10k_mac_vif_chan(vif, &def)))
+		return;
+
+	band = def.chan->band;
+	sband = ar->hw->wiphy->bands[band];
+	ratemask = arvif->bitrate_mask.control[band].legacy;
+	rates = sband->bitrates;
+
+	ath10k_dbg(ar, ATH10K_DBG_MAC2, "band: %d  ratemask: 0x%x  hw-nss: %d dev-id: 0x%x rate-bw-disable-mask: 0x%x\n",
+		   band, ratemask, hw_nss, ar->dev_id, rate_bw_disable_mask);
+
+	arg->has_rate_overrides = true;
+
+	/* Clear the rateset */
+	memset(arg->rate_overrides, 0x0, sizeof(arg->rate_overrides));
+
+	/* Legacy rates */
+	for (i = 0; i < sband->n_bitrates; i++, ratemask >>= 1, rates++) {
+		if (!(ratemask & 1))
+			continue;
+
+		if (ath10k_mac_bitrate_is_cck(rates->bitrate)) {
+			hw_rix = rates->hw_value;
+		}
+		else {
+			/* ofdm rates start at rix 4 */
+			hw_rix = rates->hw_value + 4;
+		}
+		ath10k_dbg(ar, ATH10K_DBG_MAC2,
+			   "set-enabled, bitrate: %d  i: %d  hw-value: %d hw-rix: %d\n",
+			   rates->bitrate, i, rates->hw_value, hw_rix);
+		ath10k_set_rate_enabled(hw_rix, arg->rate_overrides, 1);
+	}
+
+	/* HT rate logic (ath10k AR98XX, at least, uses 3x3 rateset).  First set
+	 * of 3 is HT20, second set is HT40.  No way to specify HT20 vs HT40
+	 * using normal rate-set info as far as I can tell, so set both to the
+	 * same value.
+	 */
+	for (i = 0; i < hw_nss; i++) {
+		unsigned int mcs = arvif->bitrate_mask.control[band].ht_mcs[i];
+		ath10k_dbg(ar, ATH10K_DBG_MAC2, "ht-mcs [%i]: 0x%x\n", i, mcs);
+		for (j = 0; j<8; j++) {
+			if (mcs & (1<<j)) {
+				hw_rix = 12 + i * 8 + j;
+				ath10k_dbg(ar, ATH10K_DBG_MAC2,
+					   "set-enabled, ht: hw-rix: %d, %d  i: %d j: %d\n",
+					   hw_rix, hw_rix + hw_nss * 8, i, j);
+				if (!(rate_bw_disable_mask & CT_DISABLE_20MHZ))
+					ath10k_set_rate_enabled(hw_rix, arg->rate_overrides, 1);
+				/* Set HT40 rateset too */
+				if (!(rate_bw_disable_mask & CT_DISABLE_40MHZ))
+					ath10k_set_rate_enabled(hw_rix + hw_nss * 8, arg->rate_overrides, 1);
+			}
+		}
+	}
+
+	/* VHT rate logic (ath10k AR98XX, at least, uses 3x3 rateset).
+	 * One set of rates for each of 20, 40, 80Mhz bandwidth.
+	 * Each set has 10 rates for each of 1, 2, and 3 streams.
+	 * No way to specify HT20 vs HT40 vs HT80
+	 * using normal rate-set info as far as I can tell, so set all three to the
+	 * same value.
+	 */
+	/* NOTE: VHT has some illegal rates (VHT-20 MCS 9 at 1x1 and 2x2, and MCS6 at VHT-80).  If user has
+	 * specified only these rates, then the rateset for that bandwidth will be null, and that will
+	 * crash the firmware.  So, try to set the nearest thing.
+	 */
+
+
+	for (i = 0; i < hw_nss; i++) {
+		unsigned int mcs = arvif->bitrate_mask.control[band].vht_mcs[i];
+		ath10k_dbg(ar, ATH10K_DBG_MAC2, "vht-mcs [%i]: 0x%x\n", i, mcs);
+		for (j = 0; j<10; j++) {
+			if (mcs & (1<<j)) {
+				int hw_rix_20_40, hw_rix_80;
+				hw_rix = 12 + (hw_nss * 2) * 8 + i * 10 + j;
+				hw_rix_20_40 = hw_rix;
+				hw_rix_80 = hw_rix;
+				if ((i < 2) && (j == 9)) {
+					/* Requested invalid rate:  mcs-9 for 1x1 or 2x2, use nearest. */
+					hw_rix_20_40 = 12 + (hw_nss * 2) * 8 + i * 10 + 8;
+				}
+				if ((i == 2) && (j == 6)) {
+					/* Requested invalid rate:  mcs-6 for 80Mhz, use nearest. */
+					hw_rix_80 = 12 + (hw_nss * 2) * 8 + i * 10 + 5;
+				}
+				ath10k_dbg(ar, ATH10K_DBG_MAC2,
+					   "set-enabled, vht: hw-rix-20-40: %d, hw-rix-80: %d  orig-hw-rix: %d  %d, %d  i: %d j: %d\n",
+					   hw_rix_20_40, hw_rix_80, hw_rix, hw_rix + hw_nss * 10, hw_rix + hw_nss * 2 * 10, i, j);
+				if (!(rate_bw_disable_mask & CT_DISABLE_20MHZ))
+					ath10k_set_rate_enabled(hw_rix_20_40, arg->rate_overrides, 1);
+				/* Set HT40 rateset too */
+				if (!(rate_bw_disable_mask & CT_DISABLE_40MHZ))
+					ath10k_set_rate_enabled(hw_rix_20_40 + hw_nss * 10, arg->rate_overrides, 1);
+				/* Set HT80 rateset too */
+				if (!(rate_bw_disable_mask & CT_DISABLE_80MHZ))
+					ath10k_set_rate_enabled(hw_rix_80 + hw_nss * 2 * 10, arg->rate_overrides, 1);
+				/* And for NICs that support 160Mhz, set those */
+				if (ok160 && !(rate_bw_disable_mask & CT_DISABLE_160MHZ))
+					ath10k_set_rate_enabled(hw_rix + hw_nss * 3 * 10, arg->rate_overrides, 1);
+			}
+		}
+	}
+
+	for (i = 0; i < sizeof(arg->rate_overrides); i++) {
+		if (arg->rate_overrides[i] != 0xFF) {
+			ath10k_dbg(ar, ATH10K_DBG_MAC2, "vif: %d rate-overrides[%d]: 0x%x\n",
+				   arvif->vdev_id, i, arg->rate_overrides[i]);
+		}
+	}
+}
+
+static u8 get_nss_from_chainmask(u16 chain_mask)
+{
+	if ((chain_mask & 0xf) == 0xf)
+		return 4;
+	else if ((chain_mask & 0x7) == 0x7)
+		return 3;
+	else if ((chain_mask & 0x3) == 0x3)
+		return 2;
+	return 1;
+}
+
 static void ath10k_peer_assoc_h_ht(struct ath10k *ar,
 				   struct ieee80211_vif *vif,
 				   struct ieee80211_sta *sta,
@@ -2301,6 +2736,11 @@
 	if (!ht_cap->ht_supported)
 		return;
 
+	/* TODO:  We need to have a distinction between tx bitrate
+	 * masks and advertised bitrate masks.  This code is trying
+	 * to use tx bitrate as advertised bitrate, and that causes
+	 * some problems and/or requires hack-arounds. --Ben
+	 */
 	band = def.chan->band;
 	ht_mcs_mask = arvif->bitrate_mask.control[band].ht_mcs;
 	vht_mcs_mask = arvif->bitrate_mask.control[band].vht_mcs;
@@ -2360,6 +2800,18 @@
 			arg->peer_ht_rates.rates[n++] = i;
 		}
 
+	/* User may have used 'iw' or similar to configure VHT rates
+	 * and no HT rates.  In that case, our NSS would be incorrect
+	 * without this code below.
+	 */
+	for (i = max_nss; i < NL80211_VHT_NSS_MAX; i++) {
+		ath10k_dbg(ar, ATH10K_DBG_MAC, "max-nss: %d i: %d mask: 0x%x\n",
+			   max_nss, i, vht_mcs_mask[i]);
+		if (vht_mcs_mask[i])
+			max_nss = i + 1;
+	}
+	max_nss = min(max_nss, get_nss_from_chainmask(ar->cfg_tx_chainmask));
+
 	/*
 	 * This is a workaround for HT-enabled STAs which break the spec
 	 * and have no HT capabilities RX mask (no HT RX MCS map).
@@ -2368,8 +2820,12 @@
 	 * MCS 0 through 7 are mandatory in 20MHz with 800 ns GI at all STAs.
 	 *
 	 * Firmware asserts if such situation occurs.
+	 *
+	 * CT Firmware with the RATEMASK feature flag does NOT assert and handles
+	 * this just fine, so no work-arounds for it. --Ben
 	 */
-	if (n == 0) {
+	if (n == 0 && !test_bit(ATH10K_FW_FEATURE_CT_RATEMASK,
+				ar->running_fw->fw_file.fw_features)) {
 		arg->peer_ht_rates.num_rates = 8;
 		for (i = 0; i < arg->peer_ht_rates.num_rates; i++)
 			arg->peer_ht_rates.rates[i] = i;
@@ -2453,7 +2909,7 @@
 }
 
 static u16
-ath10k_peer_assoc_h_vht_limit(u16 tx_mcs_set,
+ath10k_peer_assoc_h_vht_limit(struct ath10k *ar, u16 tx_mcs_set,
 			      const u16 vht_mcs_limit[NL80211_VHT_NSS_MAX])
 {
 	int idx_limit;
@@ -2479,6 +2935,11 @@
 		case 5: /* fall through */
 		case 6: /* fall through */
 		default:
+			if (test_bit(ATH10K_FW_FEATURE_CT_RATEMASK,
+				     ar->running_fw->fw_file.fw_features)) {
+				mcs = IEEE80211_VHT_MCS_SUPPORT_0_7;
+				break;
+			}
 			/* see ath10k_mac_can_set_bitrate_mask() */
 			WARN_ON(1);
 			/* fall through */
@@ -2574,23 +3035,46 @@
 	arg->peer_vht_rates.tx_max_rate =
 		__le16_to_cpu(vht_cap->vht_mcs.tx_highest);
 	arg->peer_vht_rates.tx_mcs_set = ath10k_peer_assoc_h_vht_limit(
-		__le16_to_cpu(vht_cap->vht_mcs.tx_mcs_map), vht_mcs_mask);
+		ar, __le16_to_cpu(vht_cap->vht_mcs.tx_mcs_map), vht_mcs_mask);
 
-	ath10k_dbg(ar, ATH10K_DBG_MAC, "mac vht peer %pM max_mpdu %d flags 0x%x\n",
-		   sta->addr, arg->peer_max_mpdu, arg->peer_flags);
+	ath10k_dbg(ar, ATH10K_DBG_MAC, "mac vht peer %pM max_mpdu %d flags 0x%x rx-max-rate: 0x%x rx-mcs: 0x%x tx-max-rate: 0x%x tx-mcs: 0x%x\n",
+		   sta->addr, arg->peer_max_mpdu, arg->peer_flags,
+		   arg->peer_vht_rates.rx_max_rate, arg->peer_vht_rates.rx_mcs_set,
+		   arg->peer_vht_rates.tx_max_rate, arg->peer_vht_rates.tx_mcs_set);
+
+	if (arg->peer_phymode == MODE_11AC_VHT80_80 ||
+	    arg->peer_phymode == MODE_11AC_VHT160) {
+		int nss160;
+		int rx = arg->peer_vht_rates.rx_max_rate;
+		/* Deal with cases where chainmask has been decreased.
+		 * All known chips that support 160Mhz can do only 1/2 of
+		 * the available chains at 160Mhz.
+		 */
+		rx = min((int)(arg->peer_num_spatial_streams * 390), rx);
 
-	if (arg->peer_vht_rates.rx_max_rate &&
-	    (sta->vht_cap.cap & IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_MASK)) {
-		switch (arg->peer_vht_rates.rx_max_rate) {
+		switch (rx) {
+			/* When a NIC shows up that can do 4x4 at 160Mhz, its
+			 * max-rate should be higher, and we can set nss160
+			 * to 4 here.
+			 */
 		case 1560:
 			/* Must be 2x2 at 160Mhz is all it can do. */
-			arg->peer_bw_rxnss_override = 2;
+			nss160 = 2;
 			break;
-		case 780:
-			/* Can only do 1x1 at 160Mhz (Long Guard Interval) */
-			arg->peer_bw_rxnss_override = 1;
+		default:
+			/* Assume we can only do 1x1 at 160Mhz */
+			nss160 = 1;
 			break;
 		}
+
+		arg->peer_bw_rxnss_override = ((nss160 - 1) | /* 160Mhz nss */
+					       ((nss160 - 1) << 3) | /* 80+80 nss */
+					       BIT(PEER_BW_RXNSS_OVERRIDE_OFFSET));
+
+		ath10k_warn(ar, "NIC rx-max-rate: %d calculated-max: %d rxnss_override: 0x%x  nss160: %d  spatial-streams: %d\n",
+			    arg->peer_vht_rates.rx_max_rate, rx,
+			    arg->peer_bw_rxnss_override, nss160,
+			    arg->peer_num_spatial_streams);
 	}
 }
 
@@ -2628,10 +3112,98 @@
 		   arvif->ar->wmi.peer_flags->qos));
 }
 
-static bool ath10k_mac_sta_has_ofdm_only(struct ieee80211_sta *sta)
+static bool ath10k_mac_vif_has_any_cck(struct ath10k *ar,
+				       struct ieee80211_vif *vif,
+				       u8 bandmask)
+{
+	struct ath10k_vif *arvif = ath10k_vif_to_arvif(vif);
+	u32 msk = 0;
+	int i;
+	for (i = 0; i < NUM_NL80211_BANDS; i++) {
+		if (bandmask & (1 << i)) {
+			msk |= arvif->bitrate_mask.control[i].legacy;
+		}
+	}
+	/* Only 2Ghz band has CCK support */
+	/* We have 12 bits of legacy rates, first 4 are /b (CCK) rates. */
+	ath10k_dbg(ar, ATH10K_DBG_MAC, "has-any-cck, arvif-legacy-24: 0x%x  mask: 0x%x\n",
+		   arvif->bitrate_mask.control[NL80211_BAND_2GHZ].legacy,
+		   msk);
+	return (msk & 0xf);
+}
+
+static bool ath10k_mac_vif_has_any_ofdm(struct ath10k *ar,
+					struct ieee80211_vif *vif,
+					int bandmask)
+{
+	struct ath10k_vif *arvif = ath10k_vif_to_arvif(vif);
+	u32 msk = 0;
+	int i;
+	for (i = 0; i < NUM_NL80211_BANDS; i++) {
+		if (bandmask & (1 << i)) {
+			msk |= arvif->bitrate_mask.control[i].legacy;
+		}
+	}
+	/* We have 12 bits of legacy rates, first 4 are /b (CCK) rates. */
+	ath10k_dbg(ar, ATH10K_DBG_MAC, "has-any-ofdm, arvif-legacy-24: 0x%x  legacy-5: 0x%x  mask: 0x%x\n",
+		   arvif->bitrate_mask.control[NL80211_BAND_2GHZ].legacy,
+		   arvif->bitrate_mask.control[NL80211_BAND_5GHZ].legacy,
+		   msk);
+	return (msk & 0xff0);
+}
+
+static bool ath10k_mac_vif_has_any_ht(struct ath10k *ar, struct ieee80211_vif *vif)
+{
+	struct ath10k_vif *arvif = ath10k_vif_to_arvif(vif);
+	int i;
+	for (i = 0; i<IEEE80211_HT_MCS_MASK_LEN; i++) {
+		if (arvif->bitrate_mask.control[NL80211_BAND_2GHZ].ht_mcs[i] ||
+		    arvif->bitrate_mask.control[NL80211_BAND_5GHZ].ht_mcs[i]) {
+			ath10k_dbg(ar, ATH10K_DBG_MAC, "has-any-ht, i: %d  2.4: 0x%x  5: 0x%x\n",
+				   i, arvif->bitrate_mask.control[NL80211_BAND_2GHZ].ht_mcs[i],
+				   arvif->bitrate_mask.control[NL80211_BAND_5GHZ].ht_mcs[i]);
+			return true;
+		}
+	}
+	ath10k_dbg(ar, ATH10K_DBG_MAC, "No HT rates enabled.\n");
+	return false;
+}
+
+static bool ath10k_mac_vif_has_any_vht(struct ath10k *ar, struct ieee80211_vif *vif)
+{
+	struct ath10k_vif *arvif = ath10k_vif_to_arvif(vif);
+	int i;
+	for (i = 0; i<ARRAY_SIZE(arvif->bitrate_mask.control[NL80211_BAND_2GHZ].vht_mcs); i++) {
+		if (arvif->bitrate_mask.control[NL80211_BAND_2GHZ].vht_mcs[i] ||
+		    arvif->bitrate_mask.control[NL80211_BAND_5GHZ].vht_mcs[i]) {
+			ath10k_dbg(ar, ATH10K_DBG_MAC, "has-any-vht, i: %d  2.4: 0x%x  5: 0x%x\n",
+				   i, arvif->bitrate_mask.control[NL80211_BAND_2GHZ].vht_mcs[i],
+				   arvif->bitrate_mask.control[NL80211_BAND_5GHZ].vht_mcs[i]);
+			return true;
+		}
+	}
+	ath10k_dbg(ar, ATH10K_DBG_MAC, "No VHT rates enabled.\n");
+	return false;
+}
+
+static bool ath10k_mac_sta_has_ofdm_only(struct ieee80211_vif *vif,
+					 struct ieee80211_sta *sta)
+{
+	struct ath10k_vif *arvif = (void *)vif->drv_priv;
+	u32 msk = arvif->bitrate_mask.control[NL80211_BAND_2GHZ].legacy &
+		sta->supp_rates[NL80211_BAND_2GHZ];
+	/* We have 12 bits of legacy rates, first 4 are /b (CCK) rates. */
+	return (msk & 0xff0) && !(msk & 0xf);
+}
+
+static bool ath10k_mac_sta_has_ofdm_and_cck(struct ieee80211_vif *vif,
+					    struct ieee80211_sta *sta)
 {
-	return sta->supp_rates[NL80211_BAND_2GHZ] >>
-	       ATH10K_MAC_FIRST_OFDM_RATE_IDX;
+	struct ath10k_vif *arvif = (void *)vif->drv_priv;
+	u32 msk = arvif->bitrate_mask.control[NL80211_BAND_2GHZ].legacy &
+		sta->supp_rates[NL80211_BAND_2GHZ];
+	/* We have 12 bits of legacy rates, first 4 are /b (CCK) rates. */
+	return ((msk & 0xf) && (msk & 0xff0));
 }
 
 static enum wmi_phy_mode ath10k_mac_get_phymode_vht(struct ath10k *ar,
@@ -2694,8 +3266,10 @@
 				phymode = MODE_11NG_HT40;
 			else
 				phymode = MODE_11NG_HT20;
-		} else if (ath10k_mac_sta_has_ofdm_only(sta)) {
+		} else if (ath10k_mac_sta_has_ofdm_and_cck(vif, sta)) {
 			phymode = MODE_11G;
+		} else if (ath10k_mac_sta_has_ofdm_only(vif, sta)) {
+			phymode = MODE_11GONLY;
 		} else {
 			phymode = MODE_11B;
 		}
@@ -2723,8 +3297,9 @@
 		break;
 	}
 
-	ath10k_dbg(ar, ATH10K_DBG_MAC, "mac peer %pM phymode %s\n",
-		   sta->addr, ath10k_wmi_phymode_str(phymode));
+	ath10k_dbg(ar, ATH10K_DBG_MAC, "mac peer %pM phymode %s  legacy-supp-rates: 0x%x  arvif-legacy-rates: 0x%x vht-supp: %d\n",
+		   sta->addr, ath10k_wmi_phymode_str(phymode), sta->supp_rates[band],
+		   arvif->bitrate_mask.control[band].legacy, sta->vht_cap.vht_supported);
 
 	arg->peer_phymode = phymode;
 	WARN_ON(phymode == MODE_UNKNOWN);
@@ -2743,9 +3318,11 @@
 	ath10k_peer_assoc_h_crypto(ar, vif, sta, arg);
 	ath10k_peer_assoc_h_rates(ar, vif, sta, arg);
 	ath10k_peer_assoc_h_ht(ar, vif, sta, arg);
+	ath10k_peer_assoc_h_phymode(ar, vif, sta, arg);
 	ath10k_peer_assoc_h_vht(ar, vif, sta, arg);
 	ath10k_peer_assoc_h_qos(ar, vif, sta, arg);
-	ath10k_peer_assoc_h_phymode(ar, vif, sta, arg);
+
+	ath10k_peer_assoc_h_rate_overrides(ar, vif, sta, arg);
 
 	return 0;
 }
@@ -2908,8 +3485,8 @@
 	}
 
 	ath10k_dbg(ar, ATH10K_DBG_MAC,
-		   "mac vdev %d up (associated) bssid %pM aid %d\n",
-		   arvif->vdev_id, bss_conf->bssid, bss_conf->aid);
+		   "mac vdev %d up (associated) bssid %pM aid %d bandwidth %d\n",
+		   arvif->vdev_id, bss_conf->bssid, bss_conf->aid, ap_sta->bandwidth);
 
 	WARN_ON(arvif->is_up);
 
@@ -2970,6 +3547,150 @@
 	cancel_delayed_work_sync(&arvif->connection_loss_work);
 }
 
+/* Convert hw_rate from ratectrl to 'rate-code' that firmware
+ * can understand.
+ */
+u8 ath10k_convert_hw_rate_to_rc(u8 hw_rate, int bitrate)
+{
+	int preamble;
+	if (ath10k_mac_bitrate_is_cck(bitrate))
+		preamble = WMI_RATE_PREAMBLE_CCK;
+	else
+		preamble = WMI_RATE_PREAMBLE_OFDM;
+
+	return (preamble << 6) | hw_rate;
+}
+
+static void ath10k_check_apply_special_rates(struct ath10k *ar,
+					     struct ath10k_vif *arvif)
+{
+	struct ieee80211_hw *hw = ar->hw;
+	const struct ieee80211_supported_band *sband;
+	struct ieee80211_vif *vif = arvif->vif;
+	struct cfg80211_chan_def def;
+	enum nl80211_band band;
+	u32 ratemask;
+	u8 mcast_rt = WMI_FIXED_RATE_NONE;
+	u8 bcast_rt = WMI_FIXED_RATE_NONE;
+	u8 mgt_rt = WMI_FIXED_RATE_NONE;
+	int i;
+	int ret;
+
+	lockdep_assert_held(&ar->conf_mutex);
+
+	if (ath10k_mac_vif_chan(vif, &def))
+		band = NL80211_BAND_2GHZ;
+	else
+		band = def.chan->band;
+
+	sband = hw->wiphy->bands[band];
+	ratemask = arvif->bitrate_mask.control[band].legacy;
+
+	/* 10.1.467 Firmware defaults:
+	   5Ghz or p2p mode: 6Mbps mgt, bcast, mcast
+	   2.4Ghz: 1Mbps for mgt, 11Mbps for bcast, mcast
+	*/
+
+	/* Check for user-specified rates. */
+	if (arvif->mcast_rate[band] != WMI_FIXED_RATE_NONE)
+		mcast_rt = arvif->mcast_rate[band];
+
+	if (arvif->bcast_rate[band] != WMI_FIXED_RATE_NONE)
+		bcast_rt = arvif->bcast_rate[band];
+
+	if (arvif->mgt_rate[band] != WMI_FIXED_RATE_NONE)
+		mgt_rt = arvif->mgt_rate[band];
+
+	/* If we don't have user-specified rates, then find rates that work within
+	 * the configured ratemask.
+	 */
+
+	/* Mgt uses lowest available rate. */
+	if (mgt_rt == WMI_FIXED_RATE_NONE) {
+		for (i = 0; i < ath10k_g_rates_size; i++) {
+			if (ratemask & (1<<i)) {
+				/* found it */
+				mgt_rt = ath10k_convert_hw_rate_to_rc(sband->bitrates[i].hw_value,
+								      sband->bitrates[i].bitrate);
+				break;
+			}
+		}
+	}
+
+	if (band == NL80211_BAND_2GHZ) {
+		/* Use 11Mbps for mcast, bcast if possible, else fall back to first available. */
+		u8 first_rt = WMI_FIXED_RATE_NONE;
+		for (i = 0; i < ath10k_g_rates_size; i++) {
+			if (ratemask & (1<<i)) {
+				if (first_rt == WMI_FIXED_RATE_NONE)
+					first_rt = ath10k_convert_hw_rate_to_rc(sband->bitrates[i].hw_value,
+										sband->bitrates[i].bitrate);
+				if (sband->bitrates[i].bitrate == 110) {
+					if (bcast_rt == WMI_FIXED_RATE_NONE)
+						bcast_rt = ath10k_convert_hw_rate_to_rc(sband->bitrates[i].hw_value,
+											sband->bitrates[i].bitrate);
+					if (mcast_rt == WMI_FIXED_RATE_NONE)
+						mcast_rt = ath10k_convert_hw_rate_to_rc(sband->bitrates[i].hw_value,
+											sband->bitrates[i].bitrate);
+					goto found_preferred24;
+				}
+			}
+		}
+
+		/* If here, we did not find preferred rate, use first found. */
+		if (bcast_rt == WMI_FIXED_RATE_NONE)
+			bcast_rt = first_rt;
+		if (mcast_rt == WMI_FIXED_RATE_NONE)
+			mcast_rt = first_rt;
+	}
+
+found_preferred24:
+	if (band == NL80211_BAND_5GHZ) {
+		for (i = 0; i < ath10k_g_rates_size; i++) {
+			if (ratemask & (1<<i)) {
+				/* found it */
+				if (bcast_rt == WMI_FIXED_RATE_NONE)
+					bcast_rt = ath10k_convert_hw_rate_to_rc(sband->bitrates[i].hw_value,
+										sband->bitrates[i].bitrate);
+				if (mcast_rt == WMI_FIXED_RATE_NONE)
+					mcast_rt = ath10k_convert_hw_rate_to_rc(sband->bitrates[i].hw_value,
+										sband->bitrates[i].bitrate);
+				break;
+			}
+		}
+	}
+
+	ath10k_dbg(ar, ATH10K_DBG_MAC, "apply-special-rates: ratemask: 0x%x mcast: 0x%x  bcast: 0x%x  mgmt: 0x%x band: %d\n",
+		   ratemask, mcast_rt, bcast_rt, mgt_rt, band);
+
+	if (mcast_rt != WMI_FIXED_RATE_NONE) {
+		ret = ath10k_wmi_vdev_set_param(ar, arvif->vdev_id,
+						ar->wmi.vdev_param->mcast_data_rate,
+						mcast_rt);
+		if (ret)
+			ath10k_warn(ar, "failed to set mcast rate param 0x%02x: %d\n",
+				    mcast_rt, ret);
+	}
+
+	if (bcast_rt != WMI_FIXED_RATE_NONE) {
+		ret = ath10k_wmi_vdev_set_param(ar, arvif->vdev_id,
+						ar->wmi.vdev_param->bcast_data_rate,
+						bcast_rt);
+		if (ret)
+			ath10k_warn(ar, "failed to set bcast rate param 0x%02x: %d\n",
+				    bcast_rt, ret);
+	}
+
+	if (mgt_rt != WMI_FIXED_RATE_NONE) {
+		ret = ath10k_wmi_vdev_set_param(ar, arvif->vdev_id,
+						ar->wmi.vdev_param->mgmt_rate,
+						mgt_rt);
+		if (ret)
+			ath10k_warn(ar, "failed to set mgt rate param 0x%02x: %d\n",
+				    mgt_rt, ret);
+	}
+}
+
 static int ath10k_station_assoc(struct ath10k *ar,
 				struct ieee80211_vif *vif,
 				struct ieee80211_sta *sta,
@@ -2988,6 +3709,8 @@
 		return ret;
 	}
 
+	ath10k_check_apply_special_rates(ar, arvif);
+
 	ret = ath10k_wmi_peer_assoc(ar, &peer_arg);
 	if (ret) {
 		ath10k_warn(ar, "failed to run peer assoc for STA %pM vdev %i: %d\n",
@@ -3145,7 +3868,8 @@
 			ch->min_power = 0;
 			ch->max_power = channel->max_power * 2;
 			ch->max_reg_power = channel->max_reg_power * 2;
-			ch->max_antenna_gain = channel->max_antenna_gain * 2;
+			ch->max_antenna_gain = ath10k_get_max_antenna_gain(ar,
+						channel->max_antenna_gain);
 			ch->reg_class_id = 0; /* FIXME */
 
 			/* FIXME: why use only legacy modes, why not any
@@ -3210,8 +3934,13 @@
 	if (IS_ENABLED(CONFIG_ATH10K_DFS_CERTIFIED) && ar->dfs_detector) {
 		nl_dfs_reg = ar->dfs_detector->region;
 		wmi_dfs_reg = ath10k_mac_get_dfs_region(nl_dfs_reg);
+		ath10k_dbg(ar, ATH10K_DBG_REGULATORY,
+			   "nl_dfs_reg: %i  wmi_dfs_reg: %i\n",
+			    nl_dfs_reg, wmi_dfs_reg);
 	} else {
 		wmi_dfs_reg = WMI_UNINIT_DFS_DOMAIN;
+		ath10k_dbg(ar, ATH10K_DBG_REGULATORY,
+			   "not DFS_CERTIFIED or no dfs_detector.\n");
 	}
 
 	/* Target allows setting up per-band regdomain but ath_common provides
@@ -3250,10 +3979,14 @@
 	struct ath10k *ar = hw->priv;
 	bool result;
 
+	/*ath10k_info(ar, "ath10k-reg-notifier, DFS-certified: %d,  dfs-detector: %p current-rd: %d  reg-addr: %p\n",
+		    IS_ENABLED(CONFIG_ATH10K_DFS_CERTIFIED), ar->dfs_detector,
+		    ar->ath_common.regulatory.current_rd, &ar->ath_common.regulatory);*/
+
 	ath_reg_notifier_apply(wiphy, request, &ar->ath_common.regulatory);
 
 	if (IS_ENABLED(CONFIG_ATH10K_DFS_CERTIFIED) && ar->dfs_detector) {
-		ath10k_dbg(ar, ATH10K_DBG_REGULATORY, "dfs region 0x%x\n",
+		ath10k_dbg(ar, ATH10K_DBG_REGULATORY, "reg-notifier: dfs region 0x%x\n",
 			   request->dfs_region);
 		result = ar->dfs_detector->set_dfs_domain(ar->dfs_detector,
 							  request->dfs_region);
@@ -3419,6 +4152,9 @@
 	spin_unlock_bh(&ar->htt.tx_lock);
 }
 
+static bool ath10k_tx_h_use_hwcrypto(struct ieee80211_vif *vif,
+				     struct sk_buff *skb);
+
 static enum ath10k_hw_txrx_mode
 ath10k_mac_tx_h_get_txmode(struct ath10k *ar,
 			   struct ieee80211_vif *vif,
@@ -3432,6 +4168,27 @@
 	if (!vif || vif->type == NL80211_IFTYPE_MONITOR)
 		return ATH10K_HW_TXRX_RAW;
 
+	/* CT Firmware with HTT-TX support sends all frames, including
+	 * management frames, over HTT in NATIVE-WIFI format.
+	 */
+	if (ar->ct_all_pkts_htt) {
+		if (ieee80211_has_protected(hdr->frame_control)) {
+			/* If data is protected, but we don't want HW to crypt it, then use raw mode. */
+			if (!(ath10k_tx_h_use_hwcrypto(vif, skb)))
+				return ATH10K_HW_TXRX_RAW;
+
+			/* If we are PMF/MFP, then packets are evidently not encrypted by the hardware
+			 * unless we are in raw mode.  Go figure.
+			 * Set to raw mode for PMF frames.
+			 */
+			if ((ieee80211_is_action(hdr->frame_control) ||
+			     ieee80211_is_deauth(hdr->frame_control) ||
+			     ieee80211_is_disassoc(hdr->frame_control)))
+				return ATH10K_HW_TXRX_RAW;
+		}
+		goto do_native_mgt_ct;
+	}
+
 	if (ieee80211_is_mgmt(fc))
 		return ATH10K_HW_TXRX_MGMT;
 
@@ -3465,6 +4222,7 @@
 	 *
 	 * FIXME: Check if raw mode works with TDLS.
 	 */
+do_native_mgt_ct:
 	if (ieee80211_is_data_present(fc) && sta && sta->tdls)
 		return ATH10K_HW_TXRX_ETHERNET;
 
@@ -3621,7 +4379,8 @@
 		ar->running_fw->fw_file.htt_op_version == ATH10K_FW_HTT_OP_VERSION_TLV);
 }
 
-static int ath10k_mac_tx_wmi_mgmt(struct ath10k *ar, struct sk_buff *skb)
+static int ath10k_mac_tx_wmi_mgmt(struct ath10k *ar,
+				  struct sk_buff *skb)
 {
 	struct sk_buff_head *q = &ar->wmi_mgmt_tx_queue;
 	int ret = 0;
@@ -3669,6 +4428,7 @@
 }
 
 static int ath10k_mac_tx_submit(struct ath10k *ar,
+				struct ieee80211_vif *vif,
 				enum ath10k_hw_txrx_mode txmode,
 				enum ath10k_mac_tx_path txpath,
 				struct sk_buff *skb)
@@ -3678,7 +4438,7 @@
 
 	switch (txpath) {
 	case ATH10K_MAC_TX_HTT:
-		ret = ath10k_htt_tx(htt, txmode, skb);
+		ret = ath10k_htt_tx(htt, vif, txmode, skb);
 		break;
 	case ATH10K_MAC_TX_HTT_MGMT:
 		ret = ath10k_htt_mgmt_tx(htt, skb);
@@ -3693,8 +4453,9 @@
 	}
 
 	if (ret) {
-		ath10k_warn(ar, "failed to transmit packet, dropping: %d\n",
-			    ret);
+		if (net_ratelimit())
+			ath10k_warn(ar, "failed to transmit packet, dropping: %d\n",
+				    ret);
 		ieee80211_free_txskb(ar->hw, skb);
 	}
 
@@ -3730,8 +4491,13 @@
 		ath10k_tx_h_8023(skb);
 		break;
 	case ATH10K_HW_TXRX_RAW:
-		if (!test_bit(ATH10K_FLAG_RAW_MODE, &ar->dev_flags) &&
-		    !(skb_cb->flags & ATH10K_SKB_F_RAW_TX)) {
+		if (!(test_bit(ATH10K_FLAG_RAW_MODE, &ar->dev_flags) ||
+		      (skb_cb->flags & ATH10K_SKB_F_RAW_TX) ||
+		      /* Any CT firmware recent enough to support rate-mask should be able to do
+		       * at least some raw-tx too.  Works on recent 10.1 firmware with non-encrypted
+		       * frames transmitted on a monitor device, at least.
+		       */
+		      test_bit(ATH10K_FW_FEATURE_CT_RATEMASK, ar->running_fw->fw_file.fw_features))) {
 			WARN_ON_ONCE(1);
 			ieee80211_free_txskb(hw, skb);
 			return -ENOTSUPP;
@@ -3749,7 +4515,7 @@
 		}
 	}
 
-	ret = ath10k_mac_tx_submit(ar, txmode, txpath, skb);
+	ret = ath10k_mac_tx_submit(ar, vif, txmode, txpath, skb);
 	if (ret) {
 		ath10k_warn(ar, "failed to submit frame: %d\n", ret);
 		return ret;
@@ -3946,6 +4712,25 @@
 	if (!txq)
 		return;
 
+#if 0
+	/* BEN:  Used to have this in 4.20, maybe no longer needed? */
+	struct ieee80211_txq *txq_tmp;
+	spin_lock_bh(&ar->txqs_lock);
+	if (!list_empty(&artxq->list))
+		list_del_init(&artxq->list);
+
+	/* Remove from ar->txqs in case it still exists there. */
+	list_for_each_entry_safe(walker, tmp, &ar->txqs, list) {
+		txq_tmp = container_of((void *)walker, struct ieee80211_txq,
+				       drv_priv);
+		if (txq_tmp == txq) {
+			list_del(&walker->list);
+			WARN_ON_ONCE(1);
+		}
+	}
+	spin_unlock_bh(&ar->txqs_lock);
+#endif
+
 	spin_lock_bh(&ar->htt.tx_lock);
 	idr_for_each_entry(&ar->htt.pending_tx, msdu, msdu_id) {
 		cb = ATH10K_SKB_CB(msdu);
@@ -3978,6 +4763,38 @@
 		return NULL;
 }
 
+void ath10k_mac_print_txq_info(struct ath10k *ar, u16 peer_id, u8 tid)
+{
+	struct ath10k_peer *peer;
+
+	lockdep_assert_held(&ar->data_lock);
+
+	peer = ar->peer_map[peer_id];
+	if (!peer) {
+		ath10k_warn(ar, "Could not find peer for peer id %d\n", peer_id);
+		return;
+	}
+
+	if (peer->removed) {
+		ath10k_warn(ar, "peer->removed is true, peer: %p id %d\n", peer, peer_id);
+		return;
+	}
+
+	if (peer->sta) {
+		if (!peer->sta->txq[tid]) {
+			ath10k_warn(ar, "peer->sta->txq[%d] is NULL, id %d\n", tid, peer_id);
+		}
+	}
+	else if (peer->vif) {
+		if (!peer->vif->txq) {
+			ath10k_warn(ar, "peer->vif->txq is NULL, id %d\n", peer_id);
+		}
+	}
+	else {
+		ath10k_warn(ar, "Both peer->sta and peer->vif are NULL, id %d\n", peer_id);
+	}
+}
+
 static bool ath10k_mac_tx_can_push(struct ieee80211_hw *hw,
 				   struct ieee80211_txq *txq)
 {
@@ -4067,7 +4884,36 @@
 	if (ret)
 		return ret;
 
+	/* Add debugging for this crash Brent saw in station reset test */
+	/* FW crashed, then kernel */
+	/*
+	Call Trace:
+ <IRQ>
+ ? dma_pte_clear_level+0x111/0x190
+ ? dma_pte_clear_level+0x111/0x190
+ ath10k_mac_tx_push_txq+0x6f/0x210 [ath10k_core]  # Decodes to the:  if (!skb) line below
+ ath10k_mac_tx_push_pending+0x154/0x1e0 [ath10k_core]
+ ath10k_htt_txrx_compl_task+0xede/0x1780 [ath10k_core]
+ ? ath10k_htc_process_trailer+0x300/0x300 [ath10k_core]
+ ? ath10k_ce_per_engine_service+0xc9/0xe0 [ath10k_pci]
+ ? ath10k_bus_pci_write32+0x3c/0xa0 [ath10k_pci]
+ ath10k_pci_napi_poll+0x44/0xe0 [ath10k_pci]
+ net_rx_action+0x250/0x3b0
+ __do_softirq+0xc2/0x2a3
+ irq_exit+0x7d/0x80
+ do_IRQ+0x45/0xc0
+ common_interrupt+0xf/0xf
+		*/
+	if (WARN_ON(((unsigned long)(txq)) < 4000))
+		return -ENOENT;
+	if (WARN_ON(((unsigned long)(hw)) < 4000))
+		return -ENOENT;
+
 	skb = ieee80211_tx_dequeue(hw, txq);
+
+	if (WARN_ON((((unsigned long)(skb)) < 4000) && (((unsigned long)(skb)) > 0)))
+		return -ENOENT;
+
 	if (!skb) {
 		spin_lock_bh(&ar->htt.tx_lock);
 		ath10k_htt_tx_dec_pending(htt);
@@ -4296,6 +5142,8 @@
 
 	lockdep_assert_held(&ar->conf_mutex);
 
+	ath10k_dbg(ar, ATH10K_DBG_MAC, "start-scan, flags: 0x%x\n",
+		   arg->scan_ctrl_flags);
 	ret = ath10k_wmi_start_scan(ar, arg);
 	if (ret)
 		return ret;
@@ -4320,12 +5168,39 @@
 	}
 	spin_unlock_bh(&ar->data_lock);
 
-	return 0;
+	return 0;
+}
+
+/**********************/
+/* mac80211 callbacks */
+/**********************/
+
+#ifdef HAS_CONSUME_BLOCK_ACK
+static int ath10k_mac_consume_block_ack(struct ieee80211_hw *hw,
+					struct ieee80211_vif *vif,
+					struct sk_buff *skb)
+{
+	struct ath10k *ar = hw->priv;
+	struct ieee80211_mgmt *mgmt = (void *)skb->data;
+	struct ath10k_vif *arvif = (void *)vif->drv_priv;
+
+	/*ath10k_warn(ar, "mac-consume-ba called.\n");*/
+	if (!(test_bit(ATH10K_FW_FEATURE_CT_RXSWCRYPT,
+		       ar->running_fw->fw_file.fw_features) &&
+	      ar->request_nohwcrypt))
+		return -EINVAL; /* Not running swcrypt, don't need this */
+
+	if (ieee80211_is_action(mgmt->frame_control) &&
+		    mgmt->u.action.category == WLAN_CATEGORY_BACK) {
+		int rv = ath10k_wmi_consume_block_ack(ar, arvif, skb);
+		if (rv) {
+			ath10k_warn(ar, "consume-block-ack failed: %d\n", rv);
+		}
+		return rv;
+	}
+	return -EINVAL;
 }
-
-/**********************/
-/* mac80211 callbacks */
-/**********************/
+#endif
 
 static void ath10k_mac_op_tx(struct ieee80211_hw *hw,
 			     struct ieee80211_tx_control *control,
@@ -4355,6 +5230,12 @@
 		  txpath == ATH10K_MAC_TX_HTT_MGMT);
 	is_mgmt = (txpath == ATH10K_MAC_TX_HTT_MGMT);
 
+	if (ar->eeprom_overrides.tx_debug & 0x1) {
+		ath10k_warn(ar, "op-tx, vif: %pM  type: %d txmode: %d  is_htt: %d  is_mgt: %d\n",
+			    vif->addr, vif->type, txmode, is_htt, is_mgmt);
+	}
+
+
 	if (is_htt) {
 		spin_lock_bh(&ar->htt.tx_lock);
 		is_presp = ieee80211_is_probe_resp(hdr->frame_control);
@@ -4667,6 +5548,9 @@
 	if (ar->phy_capability & WHAL_WLAN_11G_CAPABILITY) {
 		band = &ar->mac.sbands[NL80211_BAND_2GHZ];
 		band->ht_cap = ht_cap;
+
+		/* Enable the VHT support at 2.4 GHz */
+		band->vht_cap = vht_cap;
 	}
 	if (ar->phy_capability & WHAL_WLAN_11A_CAPABILITY) {
 		band = &ar->mac.sbands[NL80211_BAND_5GHZ];
@@ -4990,6 +5874,36 @@
 	return ret;
 }
 
+static int ath10k_config_retry_limit(struct ath10k *ar, int limit)
+{
+	struct ath10k_vif *arvif;
+	int ret = 0;
+
+	lockdep_assert_held(&ar->conf_mutex);
+
+	if (limit > 2 && !(test_bit(ATH10K_FW_FEATURE_RETRY_GT2_CT,
+				    ar->running_fw->fw_file.fw_features))) {
+		/* Stock wave-1 firmware (at least) will crash if there are > 2
+		 * retries made, due to coding issues related to rate-ctrl
+		 * logic in the firmware.  So, we can only enable this feature
+		 * if firmware specifically tells us the feature is supported.
+		 */
+		ath10k_warn(ar, "Firmware lacks feature flag indicating a retry limit of > 2 is OK, requested limit: %d\n",
+			    limit);
+		return -EINVAL;
+	}
+
+	list_for_each_entry(arvif, &ar->arvifs, list) {
+		ret = ath10k_mac_vif_config_retry_limit(arvif, limit);
+		if (ret) {
+			ath10k_warn(ar, "failed to setup retry-limit: %d\n", ret);
+			break;
+		}
+	}
+
+	return ret;
+}
+
 static int ath10k_mac_txpower_setup(struct ath10k *ar, int txpower)
 {
 	int ret;
@@ -5026,7 +5940,8 @@
 	lockdep_assert_held(&ar->conf_mutex);
 
 	list_for_each_entry(arvif, &ar->arvifs, list) {
-		if (arvif->txpower <= 0)
+		/* txpower not initialized yet? */
+		if (arvif->txpower == INT_MIN)
 			continue;
 
 		if (txpower == -1)
@@ -5066,25 +5981,18 @@
 			ath10k_warn(ar, "failed to recalc monitor: %d\n", ret);
 	}
 
+	if (changed & IEEE80211_CONF_CHANGE_RETRY_LIMITS)
+		ret = ath10k_config_retry_limit(ar, conf->long_frame_max_tx_count);
+
 	mutex_unlock(&ar->conf_mutex);
 	return ret;
 }
 
-static u32 get_nss_from_chainmask(u16 chain_mask)
-{
-	if ((chain_mask & 0xf) == 0xf)
-		return 4;
-	else if ((chain_mask & 0x7) == 0x7)
-		return 3;
-	else if ((chain_mask & 0x3) == 0x3)
-		return 2;
-	return 1;
-}
-
 static int ath10k_mac_set_txbf_conf(struct ath10k_vif *arvif)
 {
 	u32 value = 0;
 	struct ath10k *ar = arvif->ar;
+	struct ieee80211_vif *vif = arvif->vif;
 	int nsts;
 	int sound_dim;
 
@@ -5104,20 +6012,26 @@
 	if (!value)
 		return 0;
 
-	if (ar->vht_cap_info & IEEE80211_VHT_CAP_SU_BEAMFORMER_CAPABLE)
+	if ((ar->vht_cap_info & IEEE80211_VHT_CAP_SU_BEAMFORMER_CAPABLE) &&
+	    (vif->type != NL80211_IFTYPE_STATION))
 		value |= WMI_VDEV_PARAM_TXBF_SU_TX_BFER;
 
-	if (ar->vht_cap_info & IEEE80211_VHT_CAP_MU_BEAMFORMER_CAPABLE)
+	if ((ar->vht_cap_info & IEEE80211_VHT_CAP_MU_BEAMFORMER_CAPABLE) &&
+	    (vif->type != NL80211_IFTYPE_STATION))
 		value |= (WMI_VDEV_PARAM_TXBF_MU_TX_BFER |
 			  WMI_VDEV_PARAM_TXBF_SU_TX_BFER);
 
-	if (ar->vht_cap_info & IEEE80211_VHT_CAP_SU_BEAMFORMEE_CAPABLE)
+	if ((ar->vht_cap_info & IEEE80211_VHT_CAP_SU_BEAMFORMEE_CAPABLE) &&
+	    (vif->type == NL80211_IFTYPE_STATION))
 		value |= WMI_VDEV_PARAM_TXBF_SU_TX_BFEE;
 
-	if (ar->vht_cap_info & IEEE80211_VHT_CAP_MU_BEAMFORMEE_CAPABLE)
+	if ((ar->vht_cap_info & IEEE80211_VHT_CAP_MU_BEAMFORMEE_CAPABLE) &&
+		(vif->type == NL80211_IFTYPE_STATION))
 		value |= (WMI_VDEV_PARAM_TXBF_MU_TX_BFEE |
 			  WMI_VDEV_PARAM_TXBF_SU_TX_BFEE);
 
+	ath10k_dbg(ar, ATH10K_DBG_MAC, "mac set txbf conf, value: 0x%x\n",
+		   value);
 	return ath10k_wmi_vdev_set_param(ar, arvif->vdev_id,
 					 ar->wmi.vdev_param->txbf, value);
 }
@@ -5149,9 +6063,17 @@
 	memset(arvif, 0, sizeof(*arvif));
 	ath10k_mac_txq_init(vif->txq);
 
+	memset(&arvif->bcast_rate, WMI_FIXED_RATE_NONE, sizeof(arvif->bcast_rate));
+	memset(&arvif->mcast_rate, WMI_FIXED_RATE_NONE, sizeof(arvif->mcast_rate));
+	memset(&arvif->mgt_rate, WMI_FIXED_RATE_NONE, sizeof(arvif->mgt_rate));
+
 	arvif->ar = ar;
 	arvif->vif = vif;
 
+	init_completion(&arvif->beacon_tx_done);
+	/* start completed since we have not sent any beacons yet */
+	complete(&arvif->beacon_tx_done);
+
 	INIT_LIST_HEAD(&arvif->list);
 	INIT_WORK(&arvif->ap_csa_work, ath10k_mac_vif_ap_csa_work);
 	INIT_DELAYED_WORK(&arvif->connection_loss_work,
@@ -5371,6 +6293,10 @@
 		arvif->peer_id = HTT_INVALID_PEERID;
 	}
 
+	ret = ath10k_mac_set_pdev_kickout(ar);
+	if (ret)
+		goto err_peer_delete;
+
 	if (arvif->vdev_type == WMI_VDEV_TYPE_AP) {
 		ret = ath10k_mac_set_kickout(arvif);
 		if (ret) {
@@ -5510,6 +6436,16 @@
 		ath10k_warn(ar, "failed to stop spectral for vdev %i: %d\n",
 			    arvif->vdev_id, ret);
 
+	if (test_bit(ATH10K_FW_FEATURE_BEACON_TX_CB_CT,
+		      ar->running_fw->fw_file.fw_features)) {
+		int time_left;
+
+		time_left = wait_for_completion_timeout(&arvif->beacon_tx_done, (3 * HZ));
+		if (!time_left)
+			ath10k_warn(ar, "WARNING: failed to wait for beacon tx callback for vdev %i: %d\n",
+				    arvif->vdev_id, ret);
+	}
+
 	ar->free_vdev_map |= 1LL << arvif->vdev_id;
 	spin_lock_bh(&ar->data_lock);
 	list_del(&arvif->list);
@@ -5568,8 +6504,8 @@
 			continue;
 
 		if (peer->vif == vif) {
-			ath10k_warn(ar, "found vif peer %pM entry on vdev %i after it was supposedly removed\n",
-				    vif->addr, arvif->vdev_id);
+			ath10k_warn(ar, "found vif peer %pM id: %d entry on vdev %i after it was supposedly removed\n",
+				    vif->addr, i, arvif->vdev_id);
 			peer->vif = NULL;
 		}
 	}
@@ -5912,6 +6848,12 @@
 		WARN_ON_ONCE(1);
 		return;
 	}
+
+	mutex_lock(&ar->conf_mutex);
+	if (value != ar->fw_coverage.coverage_class)
+		ar->eeprom_overrides.coverage_already_set = false; /* value is being changed */
+	mutex_unlock(&ar->conf_mutex);
+
 	ar->hw_params.hw_ops->set_coverage_class(ar, value);
 }
 
@@ -5944,6 +6886,30 @@
 	return data.num_tdls_stations;
 }
 
+static u32 ath10k_calc_ct_scan_flags(struct ath10k *ar,
+				     struct ieee80211_vif *vif)
+{
+	u32 rv = 0;
+
+	if (test_bit(ATH10K_FW_FEATURE_WMI_10X_CT,
+		     ar->running_fw->fw_file.fw_features)) {
+		if (ar->running_fw->fw_file.wmi_op_version == ATH10K_FW_WMI_OP_VERSION_10_4) {
+			if (!ath10k_mac_vif_has_any_ht(ar, vif))
+				rv |= WMI_SCAN_DISABLE_HT_4;
+
+			if (!ath10k_mac_vif_has_any_vht(ar, vif))
+				rv |= WMI_SCAN_DISABLE_VHT_4;
+		} else {
+			if (!ath10k_mac_vif_has_any_ht(ar, vif))
+				rv |= WMI_SCAN_DISABLE_HT;
+
+			if (!ath10k_mac_vif_has_any_vht(ar, vif))
+				rv |= WMI_SCAN_DISABLE_VHT;
+		}
+	}
+	return rv;
+}
+
 static int ath10k_hw_scan(struct ieee80211_hw *hw,
 			  struct ieee80211_vif *vif,
 			  struct ieee80211_scan_request *hw_req)
@@ -5955,6 +6921,7 @@
 	int ret = 0;
 	int i;
 	u32 scan_timeout;
+	bool skip_legacy_rates = false;
 
 	mutex_lock(&ar->conf_mutex);
 
@@ -5964,6 +6931,9 @@
 	}
 
 	spin_lock_bh(&ar->data_lock);
+
+	ath10k_dbg(ar, ATH10K_DBG_MAC, "mac hw-scan called, scan.state: %d\n", ar->scan.state);
+
 	switch (ar->scan.state) {
 	case ATH10K_SCAN_IDLE:
 		reinit_completion(&ar->scan.started);
@@ -5977,6 +6947,7 @@
 	case ATH10K_SCAN_RUNNING:
 	case ATH10K_SCAN_ABORTING:
 		ret = -EBUSY;
+		ath10k_warn(ar, "failed to start hw scan (busy): scan-state: %d\n", ar->scan.state);
 		break;
 	}
 	spin_unlock_bh(&ar->data_lock);
@@ -5989,6 +6960,24 @@
 	arg.vdev_id = arvif->vdev_id;
 	arg.scan_id = ATH10K_SCAN_ID;
 
+	arg.scan_ctrl_flags |= ath10k_calc_ct_scan_flags(ar, vif);
+
+	if (test_bit(ATH10K_FW_FEATURE_CT_RATEMASK,
+		     ar->running_fw->fw_file.fw_features)) {
+		/* Firmware with this feature fixes a bug in firmware
+		 * that would not allow one to disable CCK and OFDM rates.
+		 * Host stack sets up the IEs, so tell firmware to leave it
+		 * alone.
+		 */
+		skip_legacy_rates = true;
+	}
+
+	if (!skip_legacy_rates) {
+		if (!req->no_cck)
+			arg.scan_ctrl_flags |= WMI_SCAN_ADD_CCK_RATES;
+		arg.scan_ctrl_flags |= WMI_SCAN_ADD_OFDM_RATES;
+	}
+
 	if (req->ie_len) {
 		arg.ie_len = req->ie_len;
 		memcpy(arg.ie, req->ie, arg.ie_len);
@@ -6053,6 +7042,8 @@
 {
 	struct ath10k *ar = hw->priv;
 
+	ath10k_dbg(ar, ATH10K_DBG_MAC, "mac cancel-hw-scan called\n");
+
 	mutex_lock(&ar->conf_mutex);
 	ath10k_scan_abort(ar);
 	mutex_unlock(&ar->conf_mutex);
@@ -6127,8 +7118,12 @@
 	if (arvif->nohwcrypt)
 		return 1;
 
-	if (key->keyidx > WMI_MAX_KEY_INDEX)
+	if (key->keyidx > WMI_MAX_KEY_INDEX) {
+		if (cmd != DISABLE_KEY)
+			ath10k_warn(ar, "failed to install key, idx out of range: %d > %d, vdev: %d\n",
+				    key->keyidx, WMI_MAX_KEY_INDEX, arvif->vdev_id);
 		return -ENOSPC;
+	}
 
 	mutex_lock(&ar->conf_mutex);
 
@@ -6369,8 +7364,8 @@
 	}
 
 	if (changed & IEEE80211_RC_SUPP_RATES_CHANGED) {
-		ath10k_dbg(ar, ATH10K_DBG_MAC, "mac update sta %pM supp rates\n",
-			   sta->addr);
+		ath10k_dbg(ar, ATH10K_DBG_MAC, "mac update sta %pM supp rates, bandwidth: %d\n",
+			   sta->addr, sta->bandwidth);
 
 		err = ath10k_station_assoc(ar, arvif->vif, sta, true);
 		if (err)
@@ -6658,8 +7653,8 @@
 		/*
 		 * New association.
 		 */
-		ath10k_dbg(ar, ATH10K_DBG_MAC, "mac sta %pM associated\n",
-			   sta->addr);
+		ath10k_dbg(ar, ATH10K_DBG_MAC, "mac sta %pM associated, bandwidth: %d\n",
+			   sta->addr, sta->bandwidth);
 
 		ret = ath10k_station_assoc(ar, vif, sta, false);
 		if (ret)
@@ -6671,8 +7666,8 @@
 		/*
 		 * Tdls station authorized.
 		 */
-		ath10k_dbg(ar, ATH10K_DBG_MAC, "mac tdls sta %pM authorized\n",
-			   sta->addr);
+		ath10k_dbg(ar, ATH10K_DBG_MAC, "mac tdls sta %pM authorized, bandwidth: %d\n",
+			   sta->addr, sta->bandwidth);
 
 		ret = ath10k_station_assoc(ar, vif, sta, false);
 		if (ret) {
@@ -6943,6 +7938,14 @@
 	arg.scan_ctrl_flags |= WMI_SCAN_FILTER_PROBE_REQ;
 	arg.burst_duration_ms = duration;
 
+	if (ath10k_mac_vif_has_any_cck(ar, vif, (1 << chan->band)))
+		arg.scan_ctrl_flags |= WMI_SCAN_ADD_CCK_RATES;
+
+	if (ath10k_mac_vif_has_any_ofdm(ar, vif, (1 << chan->band)))
+		arg.scan_ctrl_flags |= WMI_SCAN_ADD_OFDM_RATES;
+
+	arg.scan_ctrl_flags |= ath10k_calc_ct_scan_flags(ar, vif);
+
 	ret = ath10k_start_scan(ar, &arg);
 	if (ret) {
 		ath10k_warn(ar, "failed to start roc scan: %d\n", ret);
@@ -7040,19 +8043,14 @@
 {
 	bool skip;
 	long time_left;
-
-	/* mac80211 doesn't care if we really xmit queued frames or not
-	 * we'll collect those frames either way if we stop/delete vdevs
-	 */
-
-	if (ar->state == ATH10K_STATE_WEDGED)
-		return;
+	int pending_tx = 0;
 
 	time_left = wait_event_timeout(ar->htt.empty_tx_wq, ({
 			bool empty;
 
 			spin_lock_bh(&ar->htt.tx_lock);
-			empty = (ar->htt.num_pending_tx == 0);
+			pending_tx = ar->htt.num_pending_tx;
+			empty = (pending_tx == 0);
 			spin_unlock_bh(&ar->htt.tx_lock);
 
 			skip = (ar->state == ATH10K_STATE_WEDGED) ||
@@ -7063,18 +8061,74 @@
 		}), ATH10K_FLUSH_TIMEOUT_HZ);
 
 	if (time_left == 0 || skip)
-		ath10k_warn(ar, "failed to flush transmit queue (skip %i ar-state %i): %ld\n",
-			    skip, ar->state, time_left);
+		ath10k_warn(ar, "failed to flush transmit queue (skip %i ar-state %i pending-tx %d): %ld\n",
+			    skip, ar->state, pending_tx, time_left);
 }
 
 static void ath10k_flush(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 			 u32 queues, bool drop)
 {
 	struct ath10k *ar = hw->priv;
-	struct ath10k_vif *arvif;
+	struct ath10k_vif *arvif = NULL;
+	u8 peer_addr[ETH_ALEN] = {0};
 	u32 bitmap;
+	u32 vid = 0xFFFFFFFF;
 
-	if (drop) {
+	mutex_lock(&ar->conf_mutex);
+
+	if (ar->state == ATH10K_STATE_WEDGED)
+		goto skip;
+
+	if (vif) {
+		arvif = (void *)vif->drv_priv;
+		vid = arvif->vdev_id;
+		ath10k_info(ar, "mac flush vdev %d drop %d queues 0x%x ar->paused: 0x%lx  arvif->paused: 0x%lx\n",
+			    arvif->vdev_id, drop, queues, ar->tx_paused, arvif->tx_paused);
+	}
+	else {
+		ath10k_info(ar, "mac flush null vif, drop %d queues 0x%x\n",
+			    drop, queues);
+	}
+
+
+	/* NOTE:  As of Aug 10, CT firmware supports flushing a single vdev
+	 * by passing the vdev_id, and leaving peer_addr all zeros.  But the logic
+	 * below would need to be changed to check if all pkts for a particular
+	 * vdev have been flushed instead of the entire tx-q being flushed.
+	 *
+	 * In addition, this logic could be called even if 'drop' is requested.
+	 * This might make the system act more optimally.
+	 *
+	 * --Ben
+	 */
+
+	/* If we are CT firmware, ask it to flush all tids on all peers on
+	 * all vdevs.  Normal firmware will just crash if you do this.
+	 */
+	if (test_bit(ATH10K_FW_FEATURE_FLUSH_ALL_CT,
+		     ar->running_fw->fw_file.fw_features)) {
+		ath10k_wmi_peer_flush(ar, vid, peer_addr, 0xFFFFFFFF);
+		/* I am not sure the wave-2 push-tx logic works right with
+		 * flushing, so just bail out after making the proper
+		 * request to firmware.  From comment above, I guess this is just
+		 * like dropping all frames anyway.
+		 */
+		if (drop || test_bit(ATH10K_FW_FEATURE_PEER_FLOW_CONTROL,
+				     ar->running_fw->fw_file.fw_features))
+			goto skip;
+
+		/* I cannot find a good way to know if an individual vdev is flushed or
+		 * not.  So, if that is being requested, just skip the wait.
+		 */
+		if (arvif)
+			goto skip;
+
+	}
+	else if (drop) {
+		/* Upstream QCA firmware can handle this I guess...seems weird logic
+		 * though...not paying attention to specific thing to flush?
+		 * --Ben
+		 */
 		if (vif && vif->type == NL80211_IFTYPE_STATION) {
 			bitmap = ~(1 << WMI_MGMT_TID);
 			list_for_each_entry(arvif, &ar->arvifs, list) {
@@ -7083,11 +8137,13 @@
 							      arvif->bssid, bitmap);
 			}
 		}
-		return;
+		goto skip;
 	}
 
-	mutex_lock(&ar->conf_mutex);
+	/* Wait for entire tx-q to finish transmitting */
 	ath10k_mac_wait_tx_complete(ar);
+
+skip:
 	mutex_unlock(&ar->conf_mutex);
 }
 
@@ -7144,7 +8200,8 @@
 
 	ret = ath10k_wmi_pdev_bss_chan_info_request(ar, type);
 	if (ret) {
-		ath10k_warn(ar, "failed to send pdev bss chan info request\n");
+		ath10k_warn(ar, "failed to send pdev bss chan info request: %d\n",
+			    ret);
 		return;
 	}
 
@@ -7332,7 +8389,8 @@
 }
 
 static int ath10k_mac_set_fixed_rate_params(struct ath10k_vif *arvif,
-					    u8 rate, u8 nss, u8 sgi, u8 ldpc)
+					    u8 rate, u8 nss, u8 sgi, u8 ldpc,
+					    enum nl80211_band band)
 {
 	struct ath10k *ar = arvif->ar;
 	u32 vdev_param;
@@ -7344,10 +8402,11 @@
 		   arvif->vdev_id, rate, nss, sgi);
 
 	vdev_param = ar->wmi.vdev_param->fixed_rate;
+
 	ret = ath10k_wmi_vdev_set_param(ar, arvif->vdev_id, vdev_param, rate);
 	if (ret) {
-		ath10k_warn(ar, "failed to set fixed rate param 0x%02x: %d\n",
-			    rate, ret);
+		ath10k_warn(ar, "vdev %i failed to set fixed rate, param 0x%x rate 0x%02x nss %hhu sgi %hhu: %d\n",
+			    arvif->vdev_id, vdev_param, rate, nss, sgi, ret);
 		return ret;
 	}
 
@@ -7384,6 +8443,13 @@
 	int i;
 	u16 vht_mcs;
 
+	/* CT firmware has improvements that allows this to function
+	 * properly.
+	 */
+	if (test_bit(ATH10K_FW_FEATURE_CT_RATEMASK,
+		     ar->running_fw->fw_file.fw_features))
+		return true;
+
 	/* Due to firmware limitation in WMI_PEER_ASSOC_CMDID it is impossible
 	 * to express all VHT MCS rate masks. Effectively only the following
 	 * ranges can be used: none, 0-7, 0-8 and 0-9.
@@ -7467,6 +8533,27 @@
 			    sta->addr, err);
 }
 
+static void ath10k_dbg_print_bitrate_mask(struct ath10k *ar,
+					  const struct cfg80211_bitrate_mask *mask,
+					  enum nl80211_band band) {
+	ath10k_dbg(ar, ATH10K_DBG_MAC, "mask: band: %i  legacy: 0x%x  gi: %d\n",
+		   band, mask->control[band].legacy,
+		   mask->control[band].gi);
+	BUILD_BUG_ON(IEEE80211_HT_MCS_MASK_LEN != 10);
+	ath10k_dbg(ar, ATH10K_DBG_MAC, "ht_mcs: %02hx %02hx %02hx %02hx %02hx %02hx %02hx %02hx %02hx %02hx\n",
+		   mask->control[band].ht_mcs[0], mask->control[band].ht_mcs[1],
+		   mask->control[band].ht_mcs[2], mask->control[band].ht_mcs[3],
+		   mask->control[band].ht_mcs[4], mask->control[band].ht_mcs[5],
+		   mask->control[band].ht_mcs[6], mask->control[band].ht_mcs[7],
+		   mask->control[band].ht_mcs[8], mask->control[band].ht_mcs[9]);
+	BUILD_BUG_ON(NL80211_VHT_NSS_MAX != 8);
+	ath10k_dbg(ar, ATH10K_DBG_MAC, "vht_mcs: %04hx %04hx %04hx %04hx %04hx %04hx %04hx %04hx\n",
+		   mask->control[band].vht_mcs[0], mask->control[band].vht_mcs[1],
+		   mask->control[band].vht_mcs[2], mask->control[band].vht_mcs[3],
+		   mask->control[band].vht_mcs[4], mask->control[band].vht_mcs[5],
+		   mask->control[band].vht_mcs[6], mask->control[band].vht_mcs[7]);
+}
+
 static int ath10k_mac_op_set_bitrate_mask(struct ieee80211_hw *hw,
 					  struct ieee80211_vif *vif,
 					  const struct cfg80211_bitrate_mask *mask)
@@ -7487,10 +8574,22 @@
 	u8 vht_pfr;
 	bool update_bitrate_mask = true;
 
-	if (ath10k_mac_vif_chan(vif, &def))
-		return -EPERM;
+	if (ath10k_mac_vif_chan(vif, &def)) {
+		/* No channel context.  But, we want to be able to set
+		 * some rates before we send probe requests, so just
+		 * assume 2Ghz if the desired channel is not already known.
+		 */
+		band = NL80211_BAND_2GHZ;
+	}
+	else {
+		band = def.chan->band;
+	}
+
+	ath10k_dbg(ar, ATH10K_DBG_MAC, "set bitrate mask, vid: %d  band: %d\n",
+		   arvif->vdev_id, band);
+	ath10k_dbg_print_bitrate_mask(ar, mask, 0);
+	ath10k_dbg_print_bitrate_mask(ar, mask, 1);
 
-	band = def.chan->band;
 	ht_mcs_mask = mask->control[band].ht_mcs;
 	vht_mcs_mask = mask->control[band].vht_mcs;
 	ldpc = !!(ar->ht_cap_info & WMI_HT_CAP_LDPC);
@@ -7519,10 +8618,12 @@
 				    arvif->vdev_id, ret);
 			return ret;
 		}
+		arvif->bitrate_mask = *mask;
 	} else if (ath10k_mac_bitrate_mask_get_single_nss(ar, band, mask,
 							  &single_nss)) {
 		rate = WMI_FIXED_RATE_NONE;
 		nss = single_nss;
+		arvif->bitrate_mask = *mask;
 	} else {
 		rate = WMI_FIXED_RATE_NONE;
 		nss = min(ar->num_rf_chains,
@@ -7564,13 +8665,19 @@
 
 	mutex_lock(&ar->conf_mutex);
 
-	ret = ath10k_mac_set_fixed_rate_params(arvif, rate, nss, sgi, ldpc);
+	ret = ath10k_mac_set_fixed_rate_params(arvif, rate, nss, sgi, ldpc, band);
 	if (ret) {
 		ath10k_warn(ar, "failed to set fixed rate params on vdev %i: %d\n",
 			    arvif->vdev_id, ret);
 		goto exit;
 	}
 
+	/* Setting the usable ratemask may have invalidated previous default
+	 * settings for the special rates (bcast, mcast, mgmt), so re-apply
+	 * them now.
+	 */
+	ath10k_check_apply_special_rates(ar, arvif);
+
 exit:
 	mutex_unlock(&ar->conf_mutex);
 
@@ -7663,6 +8770,49 @@
 	ieee80211_queue_work(hw, &arsta->update_wk);
 }
 
+
+static u64 ath10k_get_tsf(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
+{
+	u64 rv = 0;
+
+#ifdef CONFIG_ATH10K_DEBUGFS
+	struct ath10k *ar = hw->priv;
+	struct ath10k_vif *arvif = ath10k_vif_to_arvif(vif);
+	const struct ath10k_fw_stats_vdev *vdev;
+	int ret;
+
+	mutex_lock(&ar->conf_mutex);
+
+	/* Only CT firmware has the feature to get tsf, and even then only
+	 * recent 10.1 fw.  This check will at least keep us from bothering stock
+	 * fw for something it cannot provide.  (Aug 21, 2018). --Ben
+	 */
+	if (!test_bit(ATH10K_FW_FEATURE_CT_RATEMASK,
+		     ar->running_fw->fw_file.fw_features))
+		goto unlock;
+
+	if (ar->state != ATH10K_STATE_ON) {
+		goto unlock;
+	}
+
+	ret = ath10k_debug_fw_stats_request(ar);
+	if (ret)
+		goto unlock;
+
+	list_for_each_entry(vdev, &ar->debug.fw_stats.vdevs, list) {
+		if (vdev->vdev_id == arvif->vdev_id) {
+			rv = vdev->tsf64;
+			break;
+		}
+	}
+
+unlock:
+	mutex_unlock(&ar->conf_mutex);
+#endif
+
+	return rv;
+}
+
 static void ath10k_offset_tsf(struct ieee80211_hw *hw,
 			      struct ieee80211_vif *vif, s64 tsf_offset)
 {
@@ -8166,6 +9316,15 @@
 	sinfo->rx_duration = arsta->rx_duration;
 	sinfo->filled |= BIT_ULL(NL80211_STA_INFO_RX_DURATION);
 
+	/* CT firmware has it's own per-packet tx status logic, don't bother using
+	 * this peer-stats stuff.
+	 */
+	if ((test_bit(ATH10K_FW_FEATURE_TXRATE_CT,
+		      ar->running_fw->fw_file.fw_features)) ||
+	    (test_bit(ATH10K_FW_FEATURE_TXRATE2_CT,
+		      ar->running_fw->fw_file.fw_features)))
+		return;
+
 	if (!arsta->txrate.legacy && !arsta->txrate.nss)
 		return;
 
@@ -8211,9 +9370,13 @@
 	.set_bitrate_mask		= ath10k_mac_op_set_bitrate_mask,
 	.sta_rc_update			= ath10k_sta_rc_update,
 	.offset_tsf			= ath10k_offset_tsf,
+	.get_tsf			= ath10k_get_tsf,
 	.ampdu_action			= ath10k_ampdu_action,
 	.get_et_sset_count		= ath10k_debug_get_et_sset_count,
 	.get_et_stats			= ath10k_debug_get_et_stats,
+#ifdef MAC80211_HAS_ET_STATS2
+	.get_et_stats2			= ath10k_debug_get_et_stats2,
+#endif
 	.get_et_strings			= ath10k_debug_get_et_strings,
 	.add_chanctx			= ath10k_mac_op_add_chanctx,
 	.remove_chanctx			= ath10k_mac_op_remove_chanctx,
@@ -8234,6 +9397,9 @@
 #ifdef CONFIG_MAC80211_DEBUGFS
 	.sta_add_debugfs		= ath10k_sta_add_debugfs,
 #endif
+#ifdef HAS_CONSUME_BLOCK_ACK
+	.consume_block_ack		= ath10k_mac_consume_block_ack,
+#endif
 };
 
 #define CHAN2G(_channel, _freq, _flags) { \
@@ -8371,7 +9537,27 @@
 	},
 };
 
-static const struct ieee80211_iface_combination ath10k_if_comb[] = {
+static struct ieee80211_iface_limit ath10k_10x_ct_if_limits[] = {
+	{
+	.max	= DEF_TARGET_10X_NUM_VDEVS_CT,
+	.types	= BIT(NL80211_IFTYPE_STATION)
+		| BIT(NL80211_IFTYPE_P2P_CLIENT)
+	},
+	{
+	.max	= 3,
+	.types	= BIT(NL80211_IFTYPE_P2P_GO)
+	},
+	{
+	.max	= 7,
+	.types	= BIT(NL80211_IFTYPE_AP)
+	},
+	{
+	.max	= 1,
+	.types	= BIT(NL80211_IFTYPE_ADHOC)
+	},
+};
+
+static struct ieee80211_iface_combination ath10k_if_comb[] = {
 	{
 		.limits = ath10k_if_limits,
 		.n_limits = ARRAY_SIZE(ath10k_if_limits),
@@ -8381,7 +9567,7 @@
 	},
 };
 
-static const struct ieee80211_iface_combination ath10k_10x_if_comb[] = {
+static struct ieee80211_iface_combination ath10k_10x_if_comb[] = {
 	{
 		.limits = ath10k_10x_if_limits,
 		.n_limits = ARRAY_SIZE(ath10k_10x_if_limits),
@@ -8452,6 +9638,23 @@
 	},
 };
 
+static struct ieee80211_iface_combination ath10k_10x_ct_if_comb[] = {
+	{
+		.limits = ath10k_10x_ct_if_limits,
+		.n_limits = ARRAY_SIZE(ath10k_10x_ct_if_limits),
+		.max_interfaces = DEF_TARGET_10X_NUM_VDEVS_CT,
+		.num_different_channels = 1,
+		.beacon_int_infra_match = true,
+		.beacon_int_min_gcd = 1,
+#ifdef CONFIG_ATH10K_DFS_CERTIFIED
+		.radar_detect_widths =	BIT(NL80211_CHAN_WIDTH_20_NOHT) |
+					BIT(NL80211_CHAN_WIDTH_20) |
+					BIT(NL80211_CHAN_WIDTH_40) |
+					BIT(NL80211_CHAN_WIDTH_80),
+#endif
+	},
+};
+
 /* FIXME: This is not thouroughly tested. These combinations may over- or
  * underestimate hw/fw capabilities.
  */
@@ -8517,6 +9720,8 @@
 		.radar_detect_widths =	BIT(NL80211_CHAN_WIDTH_20_NOHT) |
 					BIT(NL80211_CHAN_WIDTH_20) |
 					BIT(NL80211_CHAN_WIDTH_40) |
+					BIT(NL80211_CHAN_WIDTH_80P80) | /* TODO:  Verify --Ben */
+					BIT(NL80211_CHAN_WIDTH_160) | /* TODO:  Verify --Ben */
 					BIT(NL80211_CHAN_WIDTH_80),
 #endif
 	},
@@ -8535,6 +9740,44 @@
 		.radar_detect_widths =  BIT(NL80211_CHAN_WIDTH_20_NOHT) |
 					BIT(NL80211_CHAN_WIDTH_20) |
 					BIT(NL80211_CHAN_WIDTH_40) |
+					BIT(NL80211_CHAN_WIDTH_80P80) | /* TODO:  Verify --Ben */
+					BIT(NL80211_CHAN_WIDTH_160) | /* TODO:  Verify --Ben */
+					BIT(NL80211_CHAN_WIDTH_80),
+#endif
+	},
+};
+
+static struct ieee80211_iface_limit ath10k_10_4_ct_if_limits[] = {
+	{
+		.max = 1,
+		.types = BIT(NL80211_IFTYPE_STATION),
+	},
+	{
+		.max	= 16,
+		.types	= BIT(NL80211_IFTYPE_AP)
+#ifdef CONFIG_MAC80211_MESH
+			| BIT(NL80211_IFTYPE_MESH_POINT)
+#endif
+	},
+	{
+	.max	= 1,
+	.types	= BIT(NL80211_IFTYPE_ADHOC)
+	},
+};
+
+static struct ieee80211_iface_combination ath10k_10_4_ct_if_comb[] = {
+	{
+		.limits = ath10k_10_4_ct_if_limits,
+		.n_limits = ARRAY_SIZE(ath10k_10_4_ct_if_limits),
+		.max_interfaces = 16,
+		.num_different_channels = 1,
+		.beacon_int_infra_match = true,
+#ifdef CONFIG_ATH10K_DFS_CERTIFIED
+		.radar_detect_widths =	BIT(NL80211_CHAN_WIDTH_20_NOHT) |
+					BIT(NL80211_CHAN_WIDTH_20) |
+					BIT(NL80211_CHAN_WIDTH_40) |
+					BIT(NL80211_CHAN_WIDTH_80P80) | /* TODO:  Verify --Ben */
+					BIT(NL80211_CHAN_WIDTH_160) | /* TODO:  Verify --Ben */
 					BIT(NL80211_CHAN_WIDTH_80),
 #endif
 	},
@@ -8669,10 +9912,72 @@
 		rd = ar->hw_eeprom_rd;
 	}
 
-	ar->ath_common.regulatory.current_rd = rd;
+	if ((ar->eeprom_regdom != -1) &&
+	    (ar->eeprom_regdom != rd)) {
+		if (!ar->eeprom_regdom_warned) {
+			ath10k_err(ar, "DANGER! You're overriding EEPROM-defined regulatory domain\n");
+			ath10k_err(ar, "from: 0x%x to 0x%x (mac-init-rd)\n",
+				   rd, ar->eeprom_regdom);
+			ath10k_err(ar, "Your card was not certified to operate in the domain you chose.\n");
+			ath10k_err(ar, "This might result in a violation of your local regulatory rules.\n");
+			ath10k_err(ar, "Do not ever do this unless you really know what you are doing!\n");
+			ar->eeprom_regdom_warned = 1;
+		}
+		ar->ath_common.regulatory.current_rd = ar->eeprom_regdom | COUNTRY_ERD_FLAG;
+	}
+	else {
+		ar->ath_common.regulatory.current_rd = rd;
+	}
+	return 0;
+}
+
+/* Force over-ride const logic in core so we don't have to patch core. */
+#define ATH_ASSIGN_CONST_U16(a,b)                   \
+   do {                                             \
+      u16* __val_p = (u16*)(&(a));                  \
+      *__val_p = b;                                 \
+   } while (0)
+
+
+int ath10k_copy_comb(struct ath10k* ar,
+		     const struct ieee80211_iface_combination* comb,
+		     int array_len)
+{
+	int i;
+	int ln;
+
+	/* Clean out any existing combinations. */
+	ath10k_core_free_limits(ar);
+
+	memcpy(&ar->if_comb, comb, sizeof(*comb) * array_len);
+	for (i = 0; i<array_len; i++) {
+		ln = comb[i].n_limits * sizeof(*(comb[i].limits));
+		ar->if_comb[i].limits = kzalloc(ln, GFP_KERNEL);
+		if (!ar->if_comb[i].limits)
+			return -ENOMEM;
+		memcpy((void*)(ar->if_comb[i].limits), comb[i].limits, ln);
+	}
+
+	ar->hw->wiphy->iface_combinations = ar->if_comb;
+	ar->hw->wiphy->n_iface_combinations = array_len;
 	return 0;
 }
 
+#ifdef CPTCFG_MAC80211_LEDS
+static const struct ieee80211_tpt_blink ath10k_tpt_blink[] = {
+	{ .throughput = 0 * 1024, .blink_time = 334 },
+	{ .throughput = 1 * 1024, .blink_time = 260 },
+	{ .throughput = 2 * 1024, .blink_time = 220 },
+	{ .throughput = 5 * 1024, .blink_time = 190 },
+	{ .throughput = 10 * 1024, .blink_time = 170 },
+	{ .throughput = 25 * 1024, .blink_time = 150 },
+	{ .throughput = 54 * 1024, .blink_time = 130 },
+	{ .throughput = 120 * 1024, .blink_time = 110 },
+	{ .throughput = 265 * 1024, .blink_time = 80 },
+	{ .throughput = 586 * 1024, .blink_time = 50 },
+};
+#endif
+
 int ath10k_mac_register(struct ath10k *ar)
 {
 	static const u32 cipher_suites[] = {
@@ -8785,7 +10090,8 @@
 	ieee80211_hw_set(ar->hw, AP_LINK_PS);
 	ieee80211_hw_set(ar->hw, SPECTRUM_MGMT);
 	ieee80211_hw_set(ar->hw, SUPPORT_FAST_XMIT);
-	ieee80211_hw_set(ar->hw, CONNECTION_MONITOR);
+	if (ar->bmiss_offload_max_vdev > 0)
+		ieee80211_hw_set(ar->hw, CONNECTION_MONITOR);
 	ieee80211_hw_set(ar->hw, SUPPORTS_PER_STA_GTK);
 	ieee80211_hw_set(ar->hw, WANT_MONITOR_VIF);
 	ieee80211_hw_set(ar->hw, CHANCTX_STA_CSA);
@@ -8902,41 +10208,108 @@
 
 	switch (ar->running_fw->fw_file.wmi_op_version) {
 	case ATH10K_FW_WMI_OP_VERSION_MAIN:
-		ar->hw->wiphy->iface_combinations = ath10k_if_comb;
-		ar->hw->wiphy->n_iface_combinations =
-			ARRAY_SIZE(ath10k_if_comb);
+		ret = ath10k_copy_comb(ar, ath10k_if_comb, ARRAY_SIZE(ath10k_if_comb));
 		ar->hw->wiphy->interface_modes |= BIT(NL80211_IFTYPE_ADHOC);
 		break;
 	case ATH10K_FW_WMI_OP_VERSION_TLV:
 		if (test_bit(WMI_SERVICE_ADAPTIVE_OCS, ar->wmi.svc_map)) {
-			ar->hw->wiphy->iface_combinations =
-				ath10k_tlv_qcs_if_comb;
-			ar->hw->wiphy->n_iface_combinations =
-				ARRAY_SIZE(ath10k_tlv_qcs_if_comb);
+			ret = ath10k_copy_comb(ar, ath10k_tlv_qcs_if_comb,
+					       ARRAY_SIZE(ath10k_tlv_qcs_if_comb));
 		} else {
-			ar->hw->wiphy->iface_combinations = ath10k_tlv_if_comb;
-			ar->hw->wiphy->n_iface_combinations =
-				ARRAY_SIZE(ath10k_tlv_if_comb);
+			ret = ath10k_copy_comb(ar, ath10k_tlv_if_comb,
+					       ARRAY_SIZE(ath10k_tlv_if_comb));
 		}
 		ar->hw->wiphy->interface_modes |= BIT(NL80211_IFTYPE_ADHOC);
 		break;
 	case ATH10K_FW_WMI_OP_VERSION_10_1:
+		if (test_bit(ATH10K_FW_FEATURE_WMI_10X_CT,
+			     ar->normal_mode_fw.fw_file.fw_features)) {
+			ret = ath10k_copy_comb(ar, ath10k_10x_ct_if_comb,
+					       ARRAY_SIZE(ath10k_10x_ct_if_comb));
+			if (ret != 0)
+				goto err_free;
+
+			ATH_ASSIGN_CONST_U16(ar->if_comb[0].limits[0].max, ar->max_num_vdevs);
+			ATH_ASSIGN_CONST_U16(ar->if_comb[0].limits[2].max, min(ar->max_num_vdevs, 24)); /* vap limits */
+			ar->if_comb[0].max_interfaces = ar->max_num_vdevs;
+			ar->hw->wiphy->interface_modes |= BIT(NL80211_IFTYPE_ADHOC);
+
+			/* CT firmware can do tx-sw-crypt if properly configured */
+			if ((!(test_bit(ATH10K_FW_FEATURE_CT_STA,
+					ar->running_fw->fw_file.fw_features) &&
+			       ar->request_ct_sta)) &&
+			    (test_bit(ATH10K_FW_FEATURE_CT_RXSWCRYPT,
+				      ar->running_fw->fw_file.fw_features) &&
+			     ar->request_nohwcrypt))
+				__clear_bit(IEEE80211_HW_SW_CRYPTO_CONTROL, ar->hw->flags);
+		} else {
+			ret = ath10k_copy_comb(ar, ath10k_10x_if_comb,
+					       ARRAY_SIZE(ath10k_10x_if_comb));
+		}
+		break;
 	case ATH10K_FW_WMI_OP_VERSION_10_2:
 	case ATH10K_FW_WMI_OP_VERSION_10_2_4:
-		ar->hw->wiphy->iface_combinations = ath10k_10x_if_comb;
-		ar->hw->wiphy->n_iface_combinations =
-			ARRAY_SIZE(ath10k_10x_if_comb);
+		if (test_bit(ATH10K_FW_FEATURE_WMI_10X_CT,
+			     ar->running_fw->fw_file.fw_features)) {
+			ret = ath10k_copy_comb(ar, ath10k_10x_ct_if_comb,
+					       ARRAY_SIZE(ath10k_10x_ct_if_comb));
+			if (ret != 0)
+				goto err_free;
+
+			ATH_ASSIGN_CONST_U16(ar->if_comb[0].limits[0].max, ar->max_num_vdevs);
+			ar->if_comb[0].max_interfaces = ar->max_num_vdevs;
+
+			ar->hw->wiphy->interface_modes |= BIT(NL80211_IFTYPE_ADHOC);
+
+			/* CT firmware can do tx-sw-crypt if properly configured */
+			if (test_bit(ATH10K_FW_FEATURE_CT_RXSWCRYPT,
+				     ar->running_fw->fw_file.fw_features) &&
+			    ath10k_modparam_nohwcrypt)
+				__clear_bit(IEEE80211_HW_SW_CRYPTO_CONTROL, ar->hw->flags);
+		} else {
+			ret = ath10k_copy_comb(ar, ath10k_10x_if_comb,
+					       ARRAY_SIZE(ath10k_10x_if_comb));
+		}
 		break;
 	case ATH10K_FW_WMI_OP_VERSION_10_4:
-		ar->hw->wiphy->iface_combinations = ath10k_10_4_if_comb;
-		ar->hw->wiphy->n_iface_combinations =
-			ARRAY_SIZE(ath10k_10_4_if_comb);
-		if (test_bit(WMI_SERVICE_VDEV_DIFFERENT_BEACON_INTERVAL_SUPPORT,
+		if (test_bit(ATH10K_FW_FEATURE_WMI_10X_CT,
+			     ar->running_fw->fw_file.fw_features)) {
+			ret = ath10k_copy_comb(ar, ath10k_10_4_ct_if_comb,
+					       ARRAY_SIZE(ath10k_10_4_ct_if_comb));
+			if (ret != 0)
+				goto err_free;
+
+			ATH_ASSIGN_CONST_U16(ar->if_comb[0].limits[0].max, ar->max_num_vdevs);
+			ar->if_comb[0].max_interfaces = ar->max_num_vdevs;
+
+			ATH_ASSIGN_CONST_U16(ar->if_comb[0].limits[1].max, min(ar->max_num_vdevs, 24)); /* vap limits */
+
+			ar->hw->wiphy->interface_modes |= BIT(NL80211_IFTYPE_ADHOC);
+
+			if (test_bit(WMI_SERVICE_VDEV_DIFFERENT_BEACON_INTERVAL_SUPPORT,
+				     ar->wmi.svc_map)) {
+				ar->if_comb[0].beacon_int_min_gcd = 100;
+			}
+			else {
+				ar->if_comb[0].beacon_int_min_gcd = 1;
+			}
+
+			/* CT firmware can do tx-sw-crypt if properly configured */
+			if (test_bit(ATH10K_FW_FEATURE_CT_RXSWCRYPT,
+				     ar->running_fw->fw_file.fw_features) &&
+			    ath10k_modparam_nohwcrypt)
+				__clear_bit(IEEE80211_HW_SW_CRYPTO_CONTROL, ar->hw->flags);
+
+		} else {
+			if (test_bit(WMI_SERVICE_VDEV_DIFFERENT_BEACON_INTERVAL_SUPPORT,
 			     ar->wmi.svc_map)) {
-			ar->hw->wiphy->iface_combinations =
-				ath10k_10_4_bcn_int_if_comb;
-			ar->hw->wiphy->n_iface_combinations =
-				ARRAY_SIZE(ath10k_10_4_bcn_int_if_comb);
+				ret = ath10k_copy_comb(ar, ath10k_10_4_bcn_int_if_comb,
+						       ARRAY_SIZE(ath10k_10_4_bcn_int_if_comb));
+			}
+			else {
+				ret = ath10k_copy_comb(ar, ath10k_10_4_if_comb,
+						       ARRAY_SIZE(ath10k_10_4_if_comb));
+			}
 		}
 		break;
 	case ATH10K_FW_WMI_OP_VERSION_UNSET:
@@ -8946,6 +10319,9 @@
 		goto err_free;
 	}
 
+	if (ret != 0)
+		goto err_free;
+
 	if (!test_bit(ATH10K_FLAG_RAW_MODE, &ar->dev_flags))
 		ar->hw->netdev_features = NETIF_F_HW_CSUM;
 
@@ -8969,6 +10345,7 @@
 	if (!ar->hw_params.hw_ops->set_coverage_class)
 		ar->ops->set_coverage_class = NULL;
 
+	/*ath10k_err(ar, "Calling ath_regd_init, current-rd: %d\n", ar->ath_common.regulatory.current_rd);*/
 	ret = ath_regd_init(&ar->ath_common.regulatory, ar->hw->wiphy,
 			    ath10k_reg_notifier);
 	if (ret) {
@@ -8999,13 +10376,22 @@
 
 	ar->hw->weight_multiplier = ATH10K_AIRTIME_WEIGHT_MULTIPLIER;
 
+#ifdef CPTCFG_MAC80211_LEDS
+	ieee80211_create_tpt_led_trigger(ar->hw,
+		IEEE80211_TPT_LEDTRIG_FL_RADIO, ath10k_tpt_blink,
+		ARRAY_SIZE(ath10k_tpt_blink));
+#endif
+
 	ret = ieee80211_register_hw(ar->hw);
 	if (ret) {
 		ath10k_err(ar, "failed to register ieee80211: %d\n", ret);
 		goto err_dfs_detector_exit;
 	}
 
-	if (test_bit(WMI_SERVICE_PER_PACKET_SW_ENCRYPT, ar->wmi.svc_map)) {
+	if (test_bit(WMI_SERVICE_PER_PACKET_SW_ENCRYPT, ar->wmi.svc_map) ||
+	    test_bit(ATH10K_FW_FEATURE_CONSUME_BLOCK_ACK_CT, ar->normal_mode_fw.fw_file.fw_features)) {
+			/* assume enough raw tx support for VLAN if a recent CT
+			firmware is detected. */
 		ar->hw->wiphy->interface_modes |= BIT(NL80211_IFTYPE_AP_VLAN);
 		ar->hw->wiphy->software_iftypes |= BIT(NL80211_IFTYPE_AP_VLAN);
 	}
diff -Nur linux-5.4.39/drivers/net/wireless/ath/ath10k/mac.h linux-5.4.39-ct/drivers/net/wireless/ath/ath10k/mac.h
--- linux-5.4.39/drivers/net/wireless/ath/ath10k/mac.h	2020-05-06 07:15:17.000000000 +0100
+++ linux-5.4.39-ct/drivers/net/wireless/ath/ath10k/mac.h	2020-05-12 23:23:34.000000000 +0100
@@ -15,6 +15,15 @@
 enum wmi_tlv_tx_pause_id;
 enum wmi_tlv_tx_pause_action;
 
+extern int ath10k_modparam_ct_sta;
+extern int ath10k_modparam_nohwcrypt;
+extern int ath10k_modparam_nobeamform_mu;
+extern int ath10k_modparam_nobeamform_su;
+extern int ath10k_modparam_target_num_vdevs_ct;
+extern int ath10k_modparam_target_num_peers_ct;
+extern int ath10k_modparam_target_num_msdu_desc_ct;
+extern int ath10k_modparam_target_num_rate_ctrl_objs_ct;
+
 struct ath10k_generic_iter {
 	struct ath10k *ar;
 	int ret;
@@ -54,10 +63,14 @@
 				     enum wmi_tlv_tx_pause_id pause_id,
 				     enum wmi_tlv_tx_pause_action action);
 
+bool ath10k_mac_bitrate_is_cck(int bitrate);
+u8 ath10k_convert_hw_rate_to_rc(u8 hw_rate, int bitrate);
 u8 ath10k_mac_hw_rate_to_idx(const struct ieee80211_supported_band *sband,
 			     u8 hw_rate, bool cck);
 u8 ath10k_mac_bitrate_to_idx(const struct ieee80211_supported_band *sband,
 			     u32 bitrate);
+u32 ath10k_convert_hw_rate_to_rate_info(u8 tpc, u8 mcs, u8 sgi, u8 nss, u8 pream_type,
+					u8 num_retries, u8 bw, u8 dyn_bw);
 
 void ath10k_mac_tx_lock(struct ath10k *ar, int reason);
 void ath10k_mac_tx_unlock(struct ath10k *ar, int reason);
@@ -70,8 +83,10 @@
 struct ieee80211_txq *ath10k_mac_txq_lookup(struct ath10k *ar,
 					    u16 peer_id,
 					    u8 tid);
+void ath10k_mac_print_txq_info(struct ath10k *ar, u16 peer_id, u8 tid);
 int ath10k_mac_ext_resource_config(struct ath10k *ar, u32 val);
 void ath10k_mac_wait_tx_complete(struct ath10k *ar);
+void ath10k_dump_peer_info(struct ath10k *ar);
 
 static inline void ath10k_tx_h_seq_no(struct ieee80211_vif *vif,
 				      struct sk_buff *skb)
@@ -91,4 +106,6 @@
 	}
 }
 
+int ath10k_mac_set_pdev_kickout(struct ath10k *ar);
+
 #endif /* _MAC_H_ */
diff -Nur linux-5.4.39/drivers/net/wireless/ath/ath10k/pci.c linux-5.4.39-ct/drivers/net/wireless/ath/ath10k/pci.c
--- linux-5.4.39/drivers/net/wireless/ath/ath10k/pci.c	2020-05-06 07:15:17.000000000 +0100
+++ linux-5.4.39-ct/drivers/net/wireless/ath/ath10k/pci.c	2020-05-12 23:23:34.000000000 +0100
@@ -1016,6 +1016,22 @@
 	return ret;
 }
 
+static int __ath10k_pci_diag_read_hi_addr(struct ath10k *ar, __le32 *dest,
+					  u32 src)
+{
+	u32 host_addr;
+	int ret;
+
+	host_addr = host_interest_item_address(src);
+
+	ret = ath10k_pci_diag_read32(ar, host_addr, dest);
+	if (ret != 0) {
+		ath10k_warn(ar, "failed to get memcpy hi address for firmware address %d: %d\n",
+			    src, ret);
+	}
+	return ret;
+}
+
 static int __ath10k_pci_diag_read_hi(struct ath10k *ar, void *dest,
 				     u32 src, u32 len)
 {
@@ -1044,6 +1060,9 @@
 #define ath10k_pci_diag_read_hi(ar, dest, src, len)		\
 	__ath10k_pci_diag_read_hi(ar, dest, HI_ITEM(src), len)
 
+#define ath10k_pci_diag_read_hi_addr(ar, dest, src)		\
+	__ath10k_pci_diag_read_hi_addr(ar, dest, HI_ITEM(src))
+
 int ath10k_pci_diag_write_mem(struct ath10k *ar, u32 address,
 			      const void *data, int nbytes)
 {
@@ -1431,6 +1450,139 @@
 	return ath10k_ce_num_free_src_entries(ar_pci->pipe_info[pipe].ce_hdl);
 }
 
+static void ath10k_pci_dump_bss_ram(struct ath10k *ar,
+				    struct ath10k_fw_crash_data *crash_data)
+{
+	int ret;
+
+	if (!crash_data)
+		return;
+
+	lockdep_assert_held(&ar->dump_mutex);
+
+	if (!(ar->running_fw && ar->running_fw->fw_file.ram_bss_addr))
+		return;
+
+	if (!ar->running_fw->fw_file.ram_bss_len)
+		return;
+
+	ret = ath10k_pci_diag_read_mem(ar, ar->running_fw->fw_file.ram_bss_addr,
+				       crash_data->ram_bss_buf,
+				       ar->running_fw->fw_file.ram_bss_len);
+	if (ret)
+		ath10k_warn(ar,
+			    "failed to read firmware RAM BSS memory from %d (%d B): %d\n",
+			    ar->running_fw->fw_file.ram_bss_addr, ar->running_fw->fw_file.ram_bss_len, ret);
+}
+
+static void ath10k_pci_dump_bss_rom(struct ath10k *ar,
+				    struct ath10k_fw_crash_data *crash_data)
+{
+	int ret;
+
+	if (!crash_data)
+		return;
+
+	lockdep_assert_held(&ar->dump_mutex);
+
+	if (!(ar->running_fw && ar->running_fw->fw_file.rom_bss_addr))
+		return;
+
+	if (!ar->running_fw->fw_file.rom_bss_len)
+		return;
+
+	ret = ath10k_pci_diag_read_mem(ar, ar->running_fw->fw_file.rom_bss_addr,
+				       crash_data->rom_bss_buf,
+				       ar->running_fw->fw_file.rom_bss_len);
+	if (ret)
+		ath10k_warn(ar,
+			    "failed to read firmware ROM BSS memory from %d (%d B): %d\n",
+			    ar->running_fw->fw_file.rom_bss_addr, ar->running_fw->fw_file.rom_bss_len, ret);
+}
+
+/* Save the main firmware stack */
+static void ath10k_pci_dump_stack(struct ath10k *ar,
+				  struct ath10k_fw_crash_data *crash_data)
+{
+	if (!crash_data)
+		return;
+
+	lockdep_assert_held(&ar->dump_mutex);
+	BUILD_BUG_ON(ATH10K_FW_STACK_SIZE % 4);
+
+	ath10k_pci_diag_read_hi(ar, crash_data->stack_buf,
+				hi_stack, ATH10K_FW_STACK_SIZE);
+	ath10k_pci_diag_read_hi_addr(ar, &crash_data->stack_addr, hi_stack);
+}
+
+/* Save the exception firmware stack */
+static void ath10k_pci_dump_exc_stack(struct ath10k *ar,
+				      struct ath10k_fw_crash_data *crash_data)
+{
+	if (!crash_data)
+		return;
+
+	lockdep_assert_held(&ar->dump_mutex);
+
+	ath10k_pci_diag_read_hi(ar, crash_data->exc_stack_buf,
+				hi_err_stack, ATH10K_FW_STACK_SIZE);
+
+	ath10k_pci_diag_read_hi_addr(ar, &crash_data->exc_stack_addr,
+				     hi_err_stack);
+}
+
+/* Only CT firmware can do this.  Attempt to read crash dump over pci
+ * registers since normal CE transport is not working.
+ */
+static int ath10k_ct_fw_crash_regs_harder(struct ath10k *ar,
+					  __le32 *reg_dump_values,
+					  int len)
+{
+	u32 val;
+	int i;
+	int q;
+#define MAX_SPIN_TRIES 1000000
+
+	if (!test_bit(ATH10K_FW_FEATURE_PINGPONG_READ_CT,
+		      ar->running_fw->fw_file.fw_features)) {
+		return -EINVAL;
+	}
+
+	ath10k_warn(ar, "in crash-regs-harder\n");
+
+	for (i = 0; i<MAX_SPIN_TRIES; i++) {
+		val = ath10k_pci_read32(ar, FW_INDICATOR_ADDRESS);
+		if (val & FW_IND_SCRATCH2_WR)
+			goto pingpong;
+	}
+
+	ath10k_warn(ar, "in crash-regs-harder, firmware did not provide indicator: 0x%x\n", val);
+	return -EBUSY;
+
+pingpong:
+	ath10k_warn(ar, "Trying to read crash dump over pingpong registers, len %d\n", len);
+	/* Firmware is trying to send us info it seems. */
+	for (q = 0; q<len; q++) {
+		reg_dump_values[q] = ath10k_pci_read32(ar, SOC_CORE_BASE_ADDRESS + SCRATCH_2_ADDRESS);
+		val = ath10k_pci_read32(ar, FW_INDICATOR_ADDRESS);
+		val |= FW_IND_SCRATCH2_RD; /* tell firmware we read it */
+		val &= ~FW_IND_SCRATCH2_WR; /* clear firmware's write flag */
+		ath10k_pci_write32(ar, FW_INDICATOR_ADDRESS, val);
+
+		for (i = 0; i<MAX_SPIN_TRIES; i++) {
+			val = ath10k_pci_read32(ar, FW_INDICATOR_ADDRESS);
+			if (val & FW_IND_SCRATCH2_WR)
+				break;
+		}
+		if (!(val & FW_IND_SCRATCH2_WR)) {
+			ath10k_err(ar, "failed to read reg %i via pingpong method.\n",
+				   q);
+			return 0; // partial read is better than nothing I guess
+		}
+	}
+	return 0;
+}
+
 static void ath10k_pci_dump_registers(struct ath10k *ar,
 				      struct ath10k_fw_crash_data *crash_data)
 {
@@ -1443,8 +1595,62 @@
 				      hi_failure_state,
 				      REG_DUMP_COUNT_QCA988X * sizeof(__le32));
 	if (ret) {
+		__le32 *buffer;
+		int len = 1500; /* length in bytes for firmware dbglog buffer */
+		struct ath10k_fw_dbglog_buf dbuf;
+
 		ath10k_err(ar, "failed to read firmware dump area: %d\n", ret);
-		return;
+
+		/* Try to read this directly over registers...only works on new
+		 * CT firmware.
+		 */
+		ret = ath10k_ct_fw_crash_regs_harder(ar, reg_dump_values, REG_DUMP_COUNT_QCA988X);
+		if (ret)
+			return;
+
+		/* Try to read the debug-log buffers as well. */
+		buffer = kzalloc(len, GFP_ATOMIC);
+
+		if (!buffer)
+			goto free_and_cont;
+
+		if (ath10k_ct_fw_crash_regs_harder(ar, (__le32 *)(&dbuf), sizeof(dbuf)/4))
+			goto free_and_cont;
+
+		/* wow, it worked! */
+		len = le32_to_cpu(dbuf.length);
+		if (len > 1500) {
+			ath10k_err(ar, "dbuf length is greater than 1500: %d\n", len);
+			len = 1500;
+		}
+		if (ath10k_ct_fw_crash_regs_harder(ar, buffer, len/4))
+			goto free_and_cont;
+
+		spin_lock_bh(&ar->data_lock);
+		ath10k_dbg_save_fw_dbg_buffer(ar, buffer, len/4);
+		spin_unlock_bh(&ar->data_lock);
+		ath10k_dbg_print_fw_dbg_buffer(ar, buffer, len/4, KERN_ERR);
+
+		/* See if the second one is available */
+		if (ath10k_ct_fw_crash_regs_harder(ar, (__le32 *)(&dbuf), sizeof(dbuf)/4))
+			goto free_and_cont;
+
+		len = le32_to_cpu(dbuf.length);
+		if (len > 1500) {
+			ath10k_err(ar, "dbuf[2] length is greater than 1500: %d\n", len);
+			len = 1500;
+		}
+
+		if (ath10k_ct_fw_crash_regs_harder(ar, buffer, len/4))
+			goto free_and_cont;
+
+		spin_lock_bh(&ar->data_lock);
+		ath10k_dbg_save_fw_dbg_buffer(ar, buffer, len/4);
+		spin_unlock_bh(&ar->data_lock);
+		ath10k_dbg_print_fw_dbg_buffer(ar, buffer, len/4, KERN_ERR);
+
+	free_and_cont:
+		kfree(buffer);
 	}
 
 	BUILD_BUG_ON(REG_DUMP_COUNT_QCA988X % 4);
@@ -1745,6 +1951,105 @@
 	}
 }
 
+/**
+ * Read any not-yet-delivered debug-log buffers on the target
+ * and save them to storage in the host driver.  Typically
+ * only done on crash, as firmware will normally deliver
+ * logs periodically on its own if it is functioning
+ * properly.
+ */
+static void ath10k_pci_dump_dbglog(struct ath10k *ar)
+{
+	struct ath10k_fw_dbglog_hdr dbg_hdr;
+	u32 dbufp; /* pointer in target memory space */
+	struct ath10k_fw_dbglog_buf dbuf;
+	u8 *buffer;
+	int ret;
+	int i;
+	int len;
+
+	ret = ath10k_pci_diag_read_hi(ar, &dbg_hdr, hi_dbglog_hdr,
+				      sizeof(dbg_hdr));
+	if (ret != 0) {
+		ath10k_err(ar, "failed to dump debug log area: %d\n", ret);
+		return;
+	}
+
+	ath10k_warn(ar, "debug log header, dbuf: 0x%x  dropped: %i\n",
+		    le32_to_cpu(dbg_hdr.dbuf), le32_to_cpu(dbg_hdr.dropped));
+	dbufp = le32_to_cpu(dbg_hdr.dbuf);
+
+	/* i is for logging purposes and sanity check in case firmware buffers
+	 * are corrupted and will not properly terminate the list.
+	 * In standard firmware, it appears there are no more than 2
+	 * buffers, so 10 should be safe upper limit even if firmware
+	 * changes quite a bit.
+	 */
+	i = 0;
+	while (dbufp && i < 10) {
+		ret = ath10k_pci_diag_read_mem(ar, dbufp, &dbuf, sizeof(dbuf));
+		if (ret != 0) {
+			ath10k_err(ar, "failed to read debug log area: %d (addr 0x%x)\n",
+				   ret, dbufp);
+			return;
+		}
+
+		len = le32_to_cpu(dbuf.length);
+
+		ath10k_warn(ar, "[%i] next: 0x%x buf: 0x%x sz: %i len: %i count: %i free: %i\n",
+			    i, le32_to_cpu(dbuf.next), le32_to_cpu(dbuf.buffer),
+			    le32_to_cpu(dbuf.bufsize), len,
+			    le32_to_cpu(dbuf.count), le32_to_cpu(dbuf.free));
+		if (dbuf.buffer == 0 || len == 0)
+			goto next;
+
+		/* Pick arbitrary upper bound in case firmware is corrupted for
+		 * whatever reason.
+		 */
+		if (len > 4096) {
+			ath10k_err(ar,
+				   "debuglog buf length is out of bounds: %d\n",
+				   len);
+			/* Do not trust the next pointer either... */
+			return;
+		}
+
+		buffer = kmalloc(len, GFP_ATOMIC);
+
+		if (!buffer)
+			goto next;
+
+		ret = ath10k_pci_diag_read_mem(ar, le32_to_cpu(dbuf.buffer),
+					       buffer, len);
+		if (ret != 0) {
+			ath10k_err(ar, "failed to read debug log buffer: %d (addr 0x%x)\n",
+				   ret, le32_to_cpu(dbuf.buffer));
+			kfree(buffer);
+			return;
+		}
+
+		WARN_ON(len & 0x3);
+
+		spin_lock_bh(&ar->data_lock);
+		ath10k_dbg_save_fw_dbg_buffer(ar, (__le32 *)(buffer), len >> 2);
+		spin_unlock_bh(&ar->data_lock);
+		ath10k_dbg_print_fw_dbg_buffer(ar, (__le32 *)(buffer),
+					       len / sizeof(__le32),
+					       KERN_ERR);
+		kfree(buffer);
+
+next:
+		dbufp = le32_to_cpu(dbuf.next);
+		if (dbufp == le32_to_cpu(dbg_hdr.dbuf)) {
+			/* It is a circular buffer it seems, bail if next
+			 * is head
+			 */
+			break;
+		}
+		i++;
+	} /* While we have a debug buffer to read */
+}
+
 static void ath10k_pci_fw_dump_work(struct work_struct *work)
 {
 	struct ath10k_pci *ar_pci = container_of(work, struct ath10k_pci,
@@ -1771,6 +2076,11 @@
 	ath10k_pci_dump_registers(ar, crash_data);
 	ath10k_ce_dump_registers(ar, crash_data);
 	ath10k_pci_dump_memory(ar, crash_data);
+	ath10k_pci_dump_dbglog(ar);
+	ath10k_pci_dump_stack(ar, crash_data);
+	ath10k_pci_dump_exc_stack(ar, crash_data);
+	ath10k_pci_dump_bss_ram(ar, crash_data);
+	ath10k_pci_dump_bss_rom(ar, crash_data);
 
 	mutex_unlock(&ar->dump_mutex);
 
@@ -1956,6 +2266,7 @@
 	ath10k_dbg(ar, ATH10K_DBG_BOOT, "boot hif start\n");
 
 	napi_enable(&ar->napi);
+	ar->napi_enabled = true;
 
 	ath10k_pci_irq_enable(ar);
 	ath10k_pci_rx_post(ar);
@@ -2072,8 +2383,28 @@
 
 	ath10k_pci_irq_disable(ar);
 	ath10k_pci_irq_sync(ar);
-	napi_synchronize(&ar->napi);
-	napi_disable(&ar->napi);
+
+	/* Calling napi_disable twice in a row (w/out starting it and/or without
+	 * having NAPI active leads to deadlock because napi_disable sets
+	 * NAPI_STATE_SCHED and NAPI_STATE_NPSVC when it returns, as far as I
+	 * can tell.  So, guard this call to napi_disable.  I believe the
+	 * failure case is something like this:
+	 * rmmod ath10k_pci ath10k_core
+	 *   Firmware crashes before hif_stop is called by the rmmod path
+	 *   The crash handling logic calls hif_stop
+         *   Then rmmod gets around to calling hif_stop, but spins endlessly
+	 *   in napi_synchronize.
+	 *
+	 *  I think one way this could happen is that ath10k_stop checks
+	 *  for state != ATH10K_STATE_OFF, but STATE_RESTARTING is also
+	 *  a possibility.  That might be how we can have hif_stop called twice
+	 *  without a hif_start in between. --Ben
+	 */
+	if (ar->napi_enabled) {
+		napi_synchronize(&ar->napi);
+		napi_disable(&ar->napi);
+		ar->napi_enabled = false;
+	}
 
 	/* Most likely the device has HTT Rx ring configured. The only way to
 	 * prevent the device from accessing (and possible corrupting) host
@@ -2811,14 +3142,25 @@
 				   enum ath10k_firmware_mode fw_mode)
 {
 	struct ath10k_pci *ar_pci = ath10k_pci_priv(ar);
+	struct pci_dev *pdev = ar_pci->pdev;
 	int ret;
+	u32 val;
 
 	ath10k_dbg(ar, ATH10K_DBG_BOOT, "boot hif power up\n");
 
-	pcie_capability_read_word(ar_pci->pdev, PCI_EXP_LNKCTL,
+	if (ar->dev_id == QCA988X_2_0_DEVICE_ID) {
+		pci_read_config_dword(pdev, 0x70c, &val);
+		if ((val & 0xff000000) == 0x17000000) {
+			val &= 0x00ffffff;
+			val |= 0x27000000;
+			pci_write_config_dword(pdev, 0x570c, val);
+		}
+	} else {
+		pcie_capability_read_word(ar_pci->pdev, PCI_EXP_LNKCTL,
 				  &ar_pci->link_ctl);
-	pcie_capability_write_word(ar_pci->pdev, PCI_EXP_LNKCTL,
+		pcie_capability_write_word(ar_pci->pdev, PCI_EXP_LNKCTL,
 				   ar_pci->link_ctl & ~PCI_EXP_LNKCTL_ASPMC);
+	}
 
 	/*
 	 * Bring the target up cleanly.
@@ -2834,6 +3176,8 @@
 	if (ret) {
 		if (ath10k_pci_has_fw_crashed(ar)) {
 			ath10k_warn(ar, "firmware crashed during chip reset\n");
+			set_bit(ATH10K_FLAG_CRASH_FLUSH, &ar->dev_flags);
+			wake_up(&ar->wmi.tx_credits_wq);
 			ath10k_pci_fw_crashed_clear(ar);
 			ath10k_pci_fw_crashed_dump(ar);
 		}
@@ -2860,10 +3204,13 @@
 		goto err_ce;
 	}
 
+	ar->fw_powerup_failed = false;
+
 	return 0;
 
 err_ce:
 	ath10k_pci_ce_deinit(ar);
+	ar->fw_powerup_failed = true;
 
 err_sleep:
 	return ret;
@@ -3080,6 +3427,7 @@
 	.power_down		= ath10k_pci_hif_power_down,
 	.read32			= ath10k_pci_read32,
 	.write32		= ath10k_pci_write32,
+	.fw_crashed_dump        = ath10k_pci_fw_crashed_dump,
 	.suspend		= ath10k_pci_hif_suspend,
 	.resume			= ath10k_pci_hif_resume,
 	.fetch_cal_eeprom	= ath10k_pci_hif_fetch_cal_eeprom,
@@ -3099,6 +3447,9 @@
 	if (ath10k_pci_has_device_gone(ar))
 		return IRQ_NONE;
 
+	if (!ar->hif_running)
+		return IRQ_NONE;
+
 	ret = ath10k_pci_force_wake(ar);
 	if (ret) {
 		ath10k_warn(ar, "failed to wake device up on irq: %d\n", ret);
@@ -3122,6 +3473,8 @@
 	int done = 0;
 
 	if (ath10k_pci_has_fw_crashed(ar)) {
+		set_bit(ATH10K_FLAG_CRASH_FLUSH, &ar->dev_flags);
+		wake_up(&ar->wmi.tx_credits_wq);
 		ath10k_pci_fw_crashed_clear(ar);
 		ath10k_pci_fw_crashed_dump(ar);
 		napi_complete(ctx);
@@ -3497,8 +3850,8 @@
 	.get_num_banks	= ath10k_pci_get_num_banks,
 };
 
-static int ath10k_pci_probe(struct pci_dev *pdev,
-			    const struct pci_device_id *pci_dev)
+static int __ath10k_pci_probe(struct pci_dev *pdev,
+			      const struct pci_device_id *pci_dev)
 {
 	int ret = 0;
 	struct ath10k *ar;
@@ -3510,6 +3863,9 @@
 	int (*pci_hard_reset)(struct ath10k *ar);
 	u32 (*targ_cpu_to_ce_addr)(struct ath10k *ar, u32 addr);
 
+	printk(KERN_INFO "ath10k 5.1 driver, optimized for CT firmware, probing pci device: 0x%x.\n",
+	       pci_dev->device);
+
 	switch (pci_dev->device) {
 	case QCA988X_2_0_DEVICE_ID_UBNT:
 	case QCA988X_2_0_DEVICE_ID:
@@ -3696,6 +4052,22 @@
 	return ret;
 }
 
+static int ath10k_pci_probe(struct pci_dev *pdev,
+			    const struct pci_device_id *pci_dev)
+{
+	int cnt = 0;
+	int rv;
+	do {
+		rv = __ath10k_pci_probe(pdev, pci_dev);
+		if (rv == 0)
+			return rv;
+		pr_err("ath10k: failed to probe PCI : %d, retry-count: %d\n", rv, cnt);
+		mdelay(10); /* let the ath10k firmware gerbil take a small break */
+	} while (cnt++ < 10);
+	return rv;
+}
+
+
 static void ath10k_pci_remove(struct pci_dev *pdev)
 {
 	struct ath10k *ar = pci_get_drvdata(pdev);
diff -Nur linux-5.4.39/drivers/net/wireless/ath/ath10k/rx_desc.h linux-5.4.39-ct/drivers/net/wireless/ath/ath10k/rx_desc.h
--- linux-5.4.39/drivers/net/wireless/ath/ath10k/rx_desc.h	2020-05-06 07:15:17.000000000 +0100
+++ linux-5.4.39-ct/drivers/net/wireless/ath/ath10k/rx_desc.h	2020-05-12 23:23:34.000000000 +0100
@@ -726,7 +726,8 @@
 		u8 ext80_mhz;
 	} rssi_chains[4];
 	u8 rssi_comb;
-	__le16 rsvd0;
+	u8 rsvd0; /* wave-2: first two bits are bandwidth, other 6 reserved */
+	u8 rssi_comb_ht; /* wave-2 only, wave-1 sets to zero */
 	u8 info0; /* %RX_PPDU_START_INFO0_ */
 	__le32 info1; /* %RX_PPDU_START_INFO1_ */
 	__le32 info2; /* %RX_PPDU_START_INFO2_ */
diff -Nur linux-5.4.39/drivers/net/wireless/ath/ath10k/targaddrs.h linux-5.4.39-ct/drivers/net/wireless/ath/ath10k/targaddrs.h
--- linux-5.4.39/drivers/net/wireless/ath/ath10k/targaddrs.h	2020-05-06 07:15:17.000000000 +0100
+++ linux-5.4.39-ct/drivers/net/wireless/ath/ath10k/targaddrs.h	2020-05-12 23:23:34.000000000 +0100
@@ -98,6 +98,12 @@
 	u32 hi_desired_baud_rate;			/* 0x60 */
 	u32 hi_dbglog_config;				/* 0x64 */
 	u32 hi_end_ram_reserve_sz;			/* 0x68 */
+	/* This controls the HTC pipe init setup.
+	 * 0x0F0000 ( x >> 16 & 0xf) is mask of ctrl-buffers-allocated.
+	 * 0xF00000 ( x >> 20 & 0xf) is mask of max-ep-pending-credit-rpts.
+	 * 0xFF000000 (x >> 24 & 0xff) is tx-credits in CT firmware only.
+	 * The rest appears un-used.
+	 */
 	u32 hi_mbox_io_block_sz;			/* 0x6c */
 
 	u32 hi_num_bpatch_streams;			/* 0x70 -- unused */
diff -Nur linux-5.4.39/drivers/net/wireless/ath/ath10k/txrx.c linux-5.4.39-ct/drivers/net/wireless/ath/ath10k/txrx.c
--- linux-5.4.39/drivers/net/wireless/ath/ath10k/txrx.c	2020-05-06 07:15:17.000000000 +0100
+++ linux-5.4.39-ct/drivers/net/wireless/ath/ath10k/txrx.c	2020-05-12 23:23:34.000000000 +0100
@@ -40,6 +40,122 @@
 	spin_unlock_bh(&ar->data_lock);
 }
 
+static u8 cck_rateidx[] = {
+	3, 2 , 1, 0
+};
+#define cck_rateidx_size (ARRAY_SIZE(cck_rateidx))
+
+static u8 ofdm_rateidx[] = {
+	10, 8 , 6, 4, 11, 9, 7, 5
+};
+#define ofdm_rateidx_size (ARRAY_SIZE(ofdm_rateidx))
+
+static void ath10k_set_tx_rate_status(struct ath10k *ar,
+				      struct ieee80211_tx_rate *rate,
+				      const struct htt_tx_done *tx_done)
+{
+	struct ieee80211_channel *ch = ar->scan_channel;
+	u8 nss = (tx_done->tx_rate_code >> 4) & 0x3;
+	u8 hw_rate = tx_done->tx_rate_code & 0xF;
+
+	if (!ch)
+		ch = ar->rx_channel;
+
+	if (tx_done->mpdus_failed) {
+		if (tx_done->status == HTT_TX_COMPL_STATE_ACK) {
+			/* We failed some, but then succeeded (+1) */
+			rate->count = tx_done->mpdus_failed + 1;
+		}
+		else {
+			/* We failed all of them */
+			rate->count = tx_done->mpdus_failed;
+		}
+	}
+	else {
+		rate->count = 1;
+	}
+	rate->idx = -1; /* Will set it properly below if rate-code is sane. */
+
+	/* NOTE:  We see reports of '24Mbps 40Mhz' tx rates often reported when we force
+	 * OFDM (24Mbps, etc) legacy tx rate when station is configured for (V)HT 40 on channel
+	 * 11.  One possibility is that the rate-flags are not reported correctly,
+	 * but also maybe it is a real issue on the air somehow?  Evidently, it is
+	 * possible to transmit an OFDM frame at 40Mhz when RTS/CTS is being used.
+	 */
+
+	switch ((tx_done->tx_rate_code >> 6) & 0x3) {
+	case WMI_RATE_PREAMBLE_CCK:
+		if (likely(hw_rate < cck_rateidx_size))
+			rate->idx = cck_rateidx[hw_rate];
+		else
+			rate->idx = cck_rateidx[0];
+
+		if (ch && (ch->band == NL80211_BAND_5GHZ)) {
+			/* Not expecting CCK rates here at all, and rate->idx will be related
+			 * to OFDM, so print warning and continue.  At least kernel logs will show
+			 * indication of true rate.
+			 */
+			static unsigned long next_jiffies = 0;
+			if (next_jiffies == 0 || time_after(jiffies, next_jiffies)) {
+				ath10k_warn(ar, "CCK rate reported on 5Ghz, hw_rate: %d  rate-idx: %d  Speed: %s\n",
+					    hw_rate, rate->idx, cck_speed_by_idx[rate->idx]);
+				next_jiffies = jiffies + HZ;
+			}
+		}
+		break;
+
+        case WMI_RATE_PREAMBLE_OFDM:
+		if (likely(hw_rate < ofdm_rateidx_size))
+			rate->idx = ofdm_rateidx[hw_rate];
+		else
+			rate->idx = ofdm_rateidx[4];
+
+		/* If we are on 5Ghz, then idx must be decreased by
+		 * 4 since the CCK rates are not available on 5Ghz.
+		 */
+		if (ch && (ch->band == NL80211_BAND_5GHZ))
+			rate->idx -= 4;
+		break;
+	}/* switch OFDM/CCK */
+
+	if ((tx_done->tx_rate_code & 0xcc) == 0x44)
+		rate->flags |= IEEE80211_TX_RC_USE_SHORT_PREAMBLE;
+
+	if ((tx_done->tx_rate_code & 0xc0) == 0x80) {
+		rate->flags |= IEEE80211_TX_RC_MCS;
+		rate->idx = hw_rate + (nss * 8);
+	}
+
+	if ((tx_done->tx_rate_code & 0xc0) == 0xc0) {
+		rate->flags |= IEEE80211_TX_RC_VHT_MCS;
+		/* TODO-BEN:  Not sure this is correct. */
+		rate->idx = (nss << 4) | hw_rate;
+		WARN_ONCE(((hw_rate > 9) || (nss > 3)), "Invalid VHT rate, nss: %d  hw_rate: %d ratecode: %d\n",
+			  nss, hw_rate, tx_done->tx_rate_code);
+	}
+
+	if (tx_done->tx_rate_flags & ATH10K_RC_FLAG_40MHZ)
+		rate->flags |= IEEE80211_TX_RC_40_MHZ_WIDTH;
+	if (tx_done->tx_rate_flags & ATH10K_RC_FLAG_80MHZ)
+		rate->flags |= IEEE80211_TX_RC_80_MHZ_WIDTH;
+	if (tx_done->tx_rate_flags & ATH10K_RC_FLAG_160MHZ)
+		rate->flags |= IEEE80211_TX_RC_160_MHZ_WIDTH;
+	if (tx_done->tx_rate_flags & ATH10K_RC_FLAG_SGI)
+		rate->flags |= IEEE80211_TX_RC_SHORT_GI;
+}
+
+#if 0
+static const char* tx_done_state_str(int i) {
+	switch (i) {
+	case HTT_TX_COMPL_STATE_NONE: return "NONE";
+	case HTT_TX_COMPL_STATE_ACK: return "ACK";
+	case HTT_TX_COMPL_STATE_NOACK: return "NOACK";
+	case HTT_TX_COMPL_STATE_DISCARD: return "DISCARD";
+	default: return "UNKNOWN";
+	}
+}
+#endif
+
 int ath10k_txrx_tx_unref(struct ath10k_htt *htt,
 			 const struct htt_tx_done *tx_done)
 {
@@ -50,6 +166,7 @@
 	struct ath10k_skb_cb *skb_cb;
 	struct ath10k_txq *artxq;
 	struct sk_buff *msdu;
+	bool tx_failed = false;
 
 	ath10k_dbg(ar, ATH10K_DBG_HTT,
 		   "htt tx completion msdu_id %u status %d\n",
@@ -70,6 +187,17 @@
 		return -ENOENT;
 	}
 
+	/*ath10k_warn(ar,
+		    "tx_unref, msdu_id: %d len: %d  tx-rate-code: 0x%x tx-rate-flags: 0x%x  tried: %d  failed: %d ack-rssi: %d status: %d (%s)\n",
+		    tx_done->msdu_id,
+		    msdu->len,
+		    tx_done->tx_rate_code,
+		    tx_done->tx_rate_flags,
+		    tx_done->mpdus_tried,
+		    tx_done->mpdus_failed,
+		    tx_done->ack_rssi,
+		    tx_done->status, tx_done_state_str(tx_done->status));*/
+
 	skb_cb = ATH10K_SKB_CB(msdu);
 	txq = skb_cb->txq;
 
@@ -99,11 +227,23 @@
 
 	trace_ath10k_txrx_tx_unref(ar, tx_done->msdu_id);
 
+	if (tx_done->status == HTT_TX_COMPL_STATE_DISCARD) {
+#ifdef CONFIG_ATH10K_DEBUG
+		ar->debug.tx_discard++;
+		ar->debug.tx_discard_bytes += msdu->len;
+#endif
+		ieee80211_free_txskb(htt->ar->hw, msdu);
+		return 0;
+	}
+
+	info->status.ack_signal = tx_done->ack_rssi;
+	/* TODO:  Need info->status.is_valid_ack_signal set for CT FW? */
+
 	if (!(info->flags & IEEE80211_TX_CTL_NO_ACK))
 		info->flags |= IEEE80211_TX_STAT_ACK;
 
 	if (tx_done->status == HTT_TX_COMPL_STATE_NOACK)
-		info->flags &= ~IEEE80211_TX_STAT_ACK;
+		tx_failed = true;
 
 	if ((tx_done->status == HTT_TX_COMPL_STATE_ACK) &&
 	    (info->flags & IEEE80211_TX_CTL_NO_ACK))
@@ -118,11 +258,67 @@
 
 	if (tx_done->status == HTT_TX_COMPL_STATE_ACK &&
 	    tx_done->ack_rssi != ATH10K_INVALID_RSSI) {
-		info->status.ack_signal = ATH10K_DEFAULT_NOISE_FLOOR +
-						tx_done->ack_rssi;
+		int nf = ATH10K_DEFAULT_NOISE_FLOOR;
+#ifdef CONFIG_ATH10K_DEBUGFS
+		if (ar->debug.nf_sum[0] != 0x80)
+			nf = ar->debug.nf_sum[0];
+#endif
+		info->status.ack_signal = nf + tx_done->ack_rssi;
 		info->status.is_valid_ack_signal = true;
 	}
 
+	if (tx_done->tx_rate_code || tx_done->tx_rate_flags || ar->ok_tx_rate_status) {
+		/* rate-code for 48Mbps is 0, with no flags, so we need to remember
+		 * any other valid rates we might have seen and use that to know if
+		 * firmware is sending tx rates.
+		 */
+
+		/* We have a better check for this in wave-1 firmware now */
+		if ((!tx_done->mpdus_tried) && (!tx_done->tx_rate_code) && (!tx_done->tx_rate_flags)) {
+			if (likely(test_bit(ATH10K_FW_FEATURE_TXRATE2_CT,
+					    ar->running_fw->fw_file.fw_features))) {
+				/* This firmware does not report rates for other than the first frame of
+				 * an ampdu chain, so this check allows us to skip those (which previously
+				 * resulting in a rate of 48Mbps reported.
+				 */
+				goto skip_reporting;
+			}
+		}
+
+		ar->ok_tx_rate_status = true;
+		ath10k_set_tx_rate_status(ar, &info->status.rates[0], tx_done);
+
+		/* Only in version 14 and higher of CT firmware */
+		if (test_bit(ATH10K_FW_FEATURE_HAS_TXSTATUS_NOACK,
+			     ar->running_fw->fw_file.fw_features)) {
+			/* Deal with tx-completion status */
+			if ((tx_done->tx_rate_flags & 0x3) == ATH10K_RC_FLAG_XRETRY) {
+#ifdef CONFIG_ATH10K_DEBUG
+				ar->debug.tx_noack++;
+				ar->debug.tx_noack_bytes += msdu->len;
+#endif
+				tx_failed = true;
+			}
+			/* TODO:  Report drops differently. */
+			if ((tx_done->tx_rate_flags & 0x3) == ATH10K_RC_FLAG_DROP)
+				tx_failed = true;
+		}
+	} else {
+	skip_reporting:
+		info->status.rates[0].idx = -1;
+	}
+
+
+	if (tx_failed) {
+		info->flags &= ~IEEE80211_TX_STAT_ACK;
+	}
+#ifdef CONFIG_ATH10K_DEBUG
+	else {
+		ar->debug.tx_ok++;
+		ar->debug.tx_ok_bytes += msdu->len;
+	}
+#endif
+
 	ieee80211_tx_status(htt->ar->hw, msdu);
 	/* we do not own the msdu anymore */
 
@@ -178,7 +374,7 @@
 
 			(mapped == expect_mapped ||
 			 test_bit(ATH10K_FLAG_CRASH_FLUSH, &ar->dev_flags));
-		}), 3 * HZ);
+		}), 1 * HZ);
 
 	if (time_left == 0)
 		return -ETIMEDOUT;
@@ -250,10 +446,11 @@
 	if (!peer) {
 		ath10k_warn(ar, "peer-unmap-event: unknown peer id %d\n",
 			    ev->peer_id);
+		/* ath10k_dump_peer_info(ar); */
 		goto exit;
 	}
 
-	ath10k_dbg(ar, ATH10K_DBG_HTT, "htt peer unmap vdev %d peer %pM id %d\n",
+	ath10k_dbg(ar, ATH10K_DBG_HTT, "removing peer, htt peer unmap vdev %d peer %pM id %d\n",
 		   peer->vdev_id, peer->addr, ev->peer_id);
 
 	ar->peer_map[ev->peer_id] = NULL;
diff -Nur linux-5.4.39/drivers/net/wireless/ath/ath10k/wmi-ops.h linux-5.4.39-ct/drivers/net/wireless/ath/ath10k/wmi-ops.h
--- linux-5.4.39/drivers/net/wireless/ath/ath10k/wmi-ops.h	2020-05-06 07:15:17.000000000 +0100
+++ linux-5.4.39-ct/drivers/net/wireless/ath/ath10k/wmi-ops.h	2020-05-12 23:23:34.000000000 +0100
@@ -65,6 +65,8 @@
 					   enum wmi_dfs_region dfs_reg);
 	struct sk_buff *(*gen_pdev_set_param)(struct ath10k *ar, u32 id,
 					      u32 value);
+	struct sk_buff *(*gen_pdev_set_fwtest)(struct ath10k *ar, u32 id,
+					       u32 value);
 	struct sk_buff *(*gen_init)(struct ath10k *ar);
 	struct sk_buff *(*gen_start_scan)(struct ath10k *ar,
 					  const struct wmi_start_scan_arg *arg);
@@ -125,7 +127,7 @@
 					  bool deliver_cab);
 	struct sk_buff *(*gen_pdev_set_wmm)(struct ath10k *ar,
 					    const struct wmi_wmm_params_all_arg *arg);
-	struct sk_buff *(*gen_request_stats)(struct ath10k *ar, u32 stats_mask);
+	struct sk_buff *(*gen_request_stats)(struct ath10k *ar, u32 stats_mask, u32 specifier);
 	struct sk_buff *(*gen_force_fw_hang)(struct ath10k *ar,
 					     enum wmi_force_fw_hang_type type,
 					     u32 delay_ms);
@@ -572,6 +574,21 @@
 }
 
 static inline int
+ath10k_wmi_pdev_set_fwtest(struct ath10k *ar, u32 id, u32 value)
+{
+	struct sk_buff *skb;
+
+	if (!ar->wmi.ops->gen_pdev_set_fwtest)
+		return -EOPNOTSUPP;
+
+	skb = ar->wmi.ops->gen_pdev_set_fwtest(ar, id, value);
+	if (IS_ERR(skb))
+		return PTR_ERR(skb);
+
+	return ath10k_wmi_cmd_send(ar, skb, ar->wmi.cmd->fwtest_cmdid);
+}
+
+static inline int
 ath10k_wmi_cmd_init(struct ath10k *ar)
 {
 	struct sk_buff *skb;
@@ -1006,25 +1023,33 @@
 }
 
 static inline int
-ath10k_wmi_beacon_send_ref_nowait(struct ath10k *ar, u32 vdev_id,
+ath10k_wmi_beacon_send_ref_nowait(struct ath10k_vif *arvif,
 				  const void *bcn, size_t bcn_len,
 				  u32 bcn_paddr, bool dtim_zero,
 				  bool deliver_cab)
 {
 	struct sk_buff *skb;
 	int ret;
+	struct ath10k *ar = arvif->ar;
 
 	if (!ar->wmi.ops->gen_beacon_dma)
 		return -EOPNOTSUPP;
 
-	skb = ar->wmi.ops->gen_beacon_dma(ar, vdev_id, bcn, bcn_len, bcn_paddr,
+	skb = ar->wmi.ops->gen_beacon_dma(ar, arvif->vdev_id, bcn, bcn_len, bcn_paddr,
 					  dtim_zero, deliver_cab);
 	if (IS_ERR(skb))
 		return PTR_ERR(skb);
 
+	spin_lock_bh(&ar->data_lock);
+	reinit_completion(&arvif->beacon_tx_done);
+	spin_unlock_bh(&ar->data_lock);
+
 	ret = ath10k_wmi_cmd_send_nowait(ar, skb,
 					 ar->wmi.cmd->pdev_send_bcn_cmdid);
 	if (ret) {
+		spin_lock_bh(&ar->data_lock);
+		complete(&arvif->beacon_tx_done);
+		spin_unlock_bh(&ar->data_lock);
 		dev_kfree_skb(skb);
 		return ret;
 	}
@@ -1050,14 +1075,14 @@
 }
 
 static inline int
-ath10k_wmi_request_stats(struct ath10k *ar, u32 stats_mask)
+ath10k_wmi_request_stats(struct ath10k *ar, u32 stats_mask, u32 specifier)
 {
 	struct sk_buff *skb;
 
 	if (!ar->wmi.ops->gen_request_stats)
 		return -EOPNOTSUPP;
 
-	skb = ar->wmi.ops->gen_request_stats(ar, stats_mask);
+	skb = ar->wmi.ops->gen_request_stats(ar, stats_mask, specifier);
 	if (IS_ERR(skb))
 		return PTR_ERR(skb);
 
diff -Nur linux-5.4.39/drivers/net/wireless/ath/ath10k/wmi-tlv.c linux-5.4.39-ct/drivers/net/wireless/ath/ath10k/wmi-tlv.c
--- linux-5.4.39/drivers/net/wireless/ath/ath10k/wmi-tlv.c	2020-05-06 07:15:17.000000000 +0100
+++ linux-5.4.39-ct/drivers/net/wireless/ath/ath10k/wmi-tlv.c	2020-05-12 23:23:34.000000000 +0100
@@ -2063,7 +2063,7 @@
 	tlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_CHANNEL);
 	tlv->len = __cpu_to_le16(sizeof(*ch));
 	ch = (void *)tlv->value;
-	ath10k_wmi_put_wmi_channel(ch, &arg->channel);
+	ath10k_wmi_put_wmi_channel(ar, ch, &arg->channel, arg->vdev_id);
 
 	ptr += sizeof(*tlv);
 	ptr += sizeof(*ch);
@@ -2703,7 +2703,7 @@
 		tlv->len = __cpu_to_le16(sizeof(*ci));
 		ci = (void *)tlv->value;
 
-		ath10k_wmi_put_wmi_channel(ci, ch);
+		ath10k_wmi_put_wmi_channel(ar, ci, ch, 0xFFFFFFFF);
 
 		chans += sizeof(*tlv);
 		chans += sizeof(*ci);
@@ -2817,7 +2817,7 @@
 }
 
 static struct sk_buff *
-ath10k_wmi_tlv_op_gen_request_stats(struct ath10k *ar, u32 stats_mask)
+ath10k_wmi_tlv_op_gen_request_stats(struct ath10k *ar, u32 stats_mask, u32 specifier)
 {
 	struct wmi_request_stats_cmd *cmd;
 	struct wmi_tlv *tlv;
@@ -3390,7 +3390,7 @@
 		tlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_CHANNEL);
 		tlv->len = __cpu_to_le16(sizeof(*chan));
 		chan = (void *)tlv->value;
-		ath10k_wmi_put_wmi_channel(chan, &chan_arg[i]);
+		ath10k_wmi_put_wmi_channel(ar, chan, &chan_arg[i], arg->vdev_id);
 
 		ptr += sizeof(*tlv);
 		ptr += sizeof(*chan);
diff -Nur linux-5.4.39/drivers/net/wireless/ath/ath10k/wmi.c linux-5.4.39-ct/drivers/net/wireless/ath/ath10k/wmi.c
--- linux-5.4.39/drivers/net/wireless/ath/ath10k/wmi.c	2020-05-06 07:15:17.000000000 +0100
+++ linux-5.4.39-ct/drivers/net/wireless/ath/ath10k/wmi.c	2020-05-12 23:23:34.000000000 +0100
@@ -7,6 +7,7 @@
 
 #include <linux/skbuff.h>
 #include <linux/ctype.h>
+#include <linux/module.h>
 
 #include "core.h"
 #include "htc.h"
@@ -25,6 +26,8 @@
 #define ATH10K_WMI_BARRIER_TIMEOUT_HZ (3 * HZ)
 #define ATH10K_WMI_DFS_CONF_TIMEOUT_HZ (HZ / 6)
 
+const char* cck_speed_by_idx[] = {"1Mbps", "2Mbps", "5.5Mbps", "11Mbps" };
+
 /* MAIN WMI cmd track */
 static struct wmi_cmd_map wmi_cmd_map = {
 	.init_cmdid = WMI_INIT_CMDID,
@@ -305,6 +308,7 @@
 	.sta_keepalive_cmd = WMI_CMD_UNSUPPORTED,
 	.echo_cmdid = WMI_10X_ECHO_CMDID,
 	.pdev_utf_cmdid = WMI_10X_PDEV_UTF_CMDID,
+	.pdev_consume_block_ack_cmdid = WMI_PDEV_CONSUME_BLOCK_ACK_CMDID_CT,
 	.dbglog_cfg_cmdid = WMI_10X_DBGLOG_CFG_CMDID,
 	.pdev_qvit_cmdid = WMI_10X_PDEV_QVIT_CMDID,
 	.pdev_ftm_intg_cmdid = WMI_CMD_UNSUPPORTED,
@@ -313,8 +317,8 @@
 	.force_fw_hang_cmdid = WMI_CMD_UNSUPPORTED,
 	.gpio_config_cmdid = WMI_10X_GPIO_CONFIG_CMDID,
 	.gpio_output_cmdid = WMI_10X_GPIO_OUTPUT_CMDID,
-	.pdev_get_temperature_cmdid = WMI_CMD_UNSUPPORTED,
-	.pdev_enable_adaptive_cca_cmdid = WMI_CMD_UNSUPPORTED,
+	.pdev_get_temperature_cmdid = WMI_10X_PDEV_GET_TEMPERATURE_CMDID,
+	.pdev_enable_adaptive_cca_cmdid = WMI_10X_SET_CCA_PARAMS_CMDID, /* CT only */
 	.scan_update_request_cmdid = WMI_CMD_UNSUPPORTED,
 	.vdev_standby_response_cmdid = WMI_CMD_UNSUPPORTED,
 	.vdev_resume_response_cmdid = WMI_CMD_UNSUPPORTED,
@@ -335,9 +339,9 @@
 	.peer_smart_ant_set_train_info_cmdid = WMI_CMD_UNSUPPORTED,
 	.peer_smart_ant_set_node_config_ops_cmdid = WMI_CMD_UNSUPPORTED,
 	.pdev_set_antenna_switch_table_cmdid = WMI_CMD_UNSUPPORTED,
-	.pdev_set_ctl_table_cmdid = WMI_CMD_UNSUPPORTED,
-	.pdev_set_mimogain_table_cmdid = WMI_CMD_UNSUPPORTED,
-	.pdev_ratepwr_table_cmdid = WMI_CMD_UNSUPPORTED,
+	.pdev_set_ctl_table_cmdid = WMI_10X_PDEV_SET_CTL_TABLE_CMDID, /* CT only */
+	.pdev_set_mimogain_table_cmdid = WMI_10X_PDEV_SET_MIMOGAIN_TABLE_CMDID, /* CT only */
+	.pdev_ratepwr_table_cmdid = WMI_10X_PDEV_RATEPWR_TABLE_CMDID, /* CT only */
 	.pdev_ratepwr_chainmsk_table_cmdid = WMI_CMD_UNSUPPORTED,
 	.pdev_fips_cmdid = WMI_CMD_UNSUPPORTED,
 	.tt_set_conf_cmdid = WMI_CMD_UNSUPPORTED,
@@ -356,7 +360,8 @@
 	.vdev_filter_neighbor_rx_packets_cmdid = WMI_CMD_UNSUPPORTED,
 	.mu_cal_start_cmdid = WMI_CMD_UNSUPPORTED,
 	.set_cca_params_cmdid = WMI_CMD_UNSUPPORTED,
-	.pdev_bss_chan_info_request_cmdid = WMI_CMD_UNSUPPORTED,
+	.pdev_bss_chan_info_request_cmdid =
+		WMI_10_2_PDEV_BSS_CHAN_INFO_REQUEST_CMDID,
 	.pdev_get_tpc_table_cmdid = WMI_CMD_UNSUPPORTED,
 	.radar_found_cmdid = WMI_CMD_UNSUPPORTED,
 };
@@ -644,6 +649,7 @@
 	.sta_keepalive_cmd = WMI_CMD_UNSUPPORTED,
 	.echo_cmdid = WMI_10_4_ECHO_CMDID,
 	.pdev_utf_cmdid = WMI_10_4_PDEV_UTF_CMDID,
+	.pdev_consume_block_ack_cmdid = WMI_10_4_PDEV_CONSUME_BLOCK_ACK_CMDID_CT,
 	.dbglog_cfg_cmdid = WMI_10_4_DBGLOG_CFG_CMDID,
 	.pdev_qvit_cmdid = WMI_10_4_PDEV_QVIT_CMDID,
 	.pdev_ftm_intg_cmdid = WMI_CMD_UNSUPPORTED,
@@ -876,7 +882,7 @@
 	.tx_encap_type = WMI_VDEV_PARAM_UNSUPPORTED,
 	.ap_detect_out_of_sync_sleeping_sta_time_secs =
 		WMI_10X_VDEV_PARAM_AP_DETECT_OUT_OF_SYNC_SLEEPING_STA_TIME_SECS,
-	.rc_num_retries = WMI_VDEV_PARAM_UNSUPPORTED,
+	.rc_num_retries = WMI_10X_VDEV_PARAM_RC_NUM_RETRIES,
 	.cabq_maxdur = WMI_VDEV_PARAM_UNSUPPORTED,
 	.mfptest_set = WMI_VDEV_PARAM_UNSUPPORTED,
 	.rts_fixed_rate = WMI_VDEV_PARAM_UNSUPPORTED,
@@ -1658,6 +1664,7 @@
 	.spatial_mux = WMI_10X_PEER_SPATIAL_MUX,
 	.vht = WMI_10X_PEER_VHT,
 	.bw80 = WMI_10X_PEER_80MHZ,
+	.pmf = WMI_10X_PEER_PMF, /* CT only */
 	.bw160 = WMI_10X_PEER_160MHZ,
 };
 
@@ -1681,8 +1688,72 @@
 	.bw160 = WMI_10_2_PEER_160MHZ,
 };
 
-void ath10k_wmi_put_wmi_channel(struct wmi_channel *ch,
-				const struct wmi_channel_arg *arg)
+int ath10k_wmi_consume_block_ack(struct ath10k *ar, struct ath10k_vif *arvif, struct sk_buff *ba_skb)
+{
+	struct wmi_pdev_consume_block_ack *cmd;
+	int cmd_id = ar->wmi.cmd->pdev_consume_block_ack_cmdid;
+	struct sk_buff *wskb;
+	int ba_skb_len = ba_skb->len;
+	if (ba_skb_len > 200)
+		ba_skb_len = 200;
+
+	/*ath10k_warn(ar, "wmi consume block ack, vdev: %d  peer: %d  ba_skb->len: %d (%d)\n",
+		   arvif->vdev_id, arvif->peer_id, ba_skb->len, ba_skb_len);*/
+
+	if ((cmd_id == WMI_CMD_UNSUPPORTED) ||
+	    (! test_bit(ATH10K_FW_FEATURE_CONSUME_BLOCK_ACK_CT,
+			ar->running_fw->fw_file.fw_features)))
+		return -EOPNOTSUPP;
+
+	wskb = ath10k_wmi_alloc_skb(ar, sizeof(*cmd) + round_up(ba_skb_len, 4));
+	if (!wskb)
+		return -ENOMEM;
+
+	cmd = (struct wmi_pdev_consume_block_ack *)wskb->data;
+	cmd->vdev_id = __cpu_to_le32(arvif->vdev_id);
+	cmd->skb_len = __cpu_to_le16(ba_skb_len);
+	cmd->flags = __cpu_to_le16(0);
+
+	memcpy(cmd->skb_data, ba_skb->data, ba_skb_len);
+
+	ath10k_dbg(ar, ATH10K_DBG_WMI, "wmi consume block ack, vdev: %d  peer: %d  ba_skb->len: %d (%d)\n",
+		   arvif->vdev_id, arvif->peer_id, ba_skb->len, ba_skb_len);
+
+	return ath10k_wmi_cmd_send(ar, wskb, cmd_id);
+}
+
+static bool ath10k_ok_skip_ch_reservation(struct ath10k *ar, u32 vdev_id)
+{
+	struct ath10k_vif *arvif;
+	bool rv = false;
+
+	if (! test_bit(ATH10K_FW_FEATURE_SKIP_CH_RES_CT,
+		       ar->running_fw->fw_file.fw_features))
+		return rv;
+
+	list_for_each_entry(arvif, &ar->arvifs, list) {
+		if (!arvif->is_up)
+			continue;
+
+		if (arvif->vdev_id == vdev_id) {
+			if (arvif->vdev_type != WMI_VDEV_TYPE_STA)
+				return false;
+			continue;
+		}
+
+		/* If there is another station up, then assume
+		 * requested station must use same channel.
+		 */
+		if (arvif->vdev_type == WMI_VDEV_TYPE_STA)
+			rv = true;
+	}
+	return rv;
+}
+
+void ath10k_wmi_put_wmi_channel(struct ath10k *ar,
+				struct wmi_channel *ch,
+				const struct wmi_channel_arg *arg,
+				u32 vdev_id)
 {
 	u32 flags = 0;
 
@@ -1701,6 +1772,10 @@
 	if (arg->chan_radar)
 		flags |= WMI_CHAN_FLAG_DFS;
 
+	if (ath10k_ok_skip_ch_reservation(ar, vdev_id))
+		/* Disable having firmware request on-channel reservation */
+		flags |= WMI_CHAN_FLAG_NO_RESERVE_CH;
+
 	ch->mhz = __cpu_to_le32(arg->freq);
 	ch->band_center_freq1 = __cpu_to_le32(arg->band_center_freq1);
 	if (arg->mode == MODE_11AC_VHT80_80)
@@ -1822,12 +1897,14 @@
 
 		dtim_zero = !!(cb->flags & ATH10K_SKB_F_DTIM_ZERO);
 		deliver_cab = !!(cb->flags & ATH10K_SKB_F_DELIVER_CAB);
-		ret = ath10k_wmi_beacon_send_ref_nowait(arvif->ar,
-							arvif->vdev_id,
+		ret = ath10k_wmi_beacon_send_ref_nowait(arvif,
 							bcn->data, bcn->len,
 							cb->paddr,
 							dtim_zero,
 							deliver_cab);
+		ath10k_dbg(ar, ATH10K_DBG_BEACON,
+			   "wmi event beacon send, vdev-id: %u  rv: %d\n",
+			   arvif->vdev_id, ret);
 
 		spin_lock_bh(&ar->data_lock);
 
@@ -1868,18 +1945,28 @@
 int ath10k_wmi_cmd_send(struct ath10k *ar, struct sk_buff *skb, u32 cmd_id)
 {
 	int ret = -EOPNOTSUPP;
+	int loops = 0;
 
 	might_sleep();
 
 	if (cmd_id == WMI_CMD_UNSUPPORTED) {
 		ath10k_warn(ar, "wmi command %d is not supported by firmware\n",
 			    cmd_id);
+		dev_kfree_skb_any(skb);
 		return ret;
 	}
 
+	ar->last_wmi_cmds[ar->last_wmi_cmd_idx % 4] = cmd_id;
+	ar->last_wmi_jiffies[ar->last_wmi_cmd_idx % 4] = jiffies;
+	ar->last_wmi_cmd_idx++;
+
 	wait_event_timeout(ar->wmi.tx_credits_wq, ({
-		/* try to send pending beacons first. they take priority */
-		ath10k_wmi_tx_beacons_nowait(ar);
+		if (loops++ == 0) {
+			/* try to send pending beacons first. they take priority.  But, only
+			 * the first time through this loop. --Ben
+			 */
+			ath10k_wmi_tx_beacons_nowait(ar);
+		}
 
 		ret = ath10k_wmi_cmd_send_nowait(ar, skb, cmd_id);
 
@@ -1893,9 +1980,14 @@
 		dev_kfree_skb_any(skb);
 
 	if (ret == -EAGAIN) {
-		ath10k_warn(ar, "wmi command %d timeout, restarting hardware\n",
-			    cmd_id);
-		queue_work(ar->workqueue, &ar->restart_work);
+		ath10k_err(ar, "Cannot communicate with firmware, previous wmi cmds: %d:%d %d:%d %d:%d %d:%d, jiffies: %ld, attempting to fake crash and restart firmware, dev-flags: 0x%lx\n",
+			   ar->last_wmi_cmds[(ar->last_wmi_cmd_idx - 1) % 4], ar->last_wmi_jiffies[(ar->last_wmi_cmd_idx - 1) % 4],
+			   ar->last_wmi_cmds[(ar->last_wmi_cmd_idx - 2) % 4], ar->last_wmi_jiffies[(ar->last_wmi_cmd_idx - 2) % 4],
+			   ar->last_wmi_cmds[(ar->last_wmi_cmd_idx - 3) % 4], ar->last_wmi_jiffies[(ar->last_wmi_cmd_idx - 3) % 4],
+			   ar->last_wmi_cmds[(ar->last_wmi_cmd_idx - 4) % 4], ar->last_wmi_jiffies[(ar->last_wmi_cmd_idx - 4) % 4],
+			   jiffies, ar->dev_flags);
+		ath10k_hif_fw_crashed_dump(ar);
+		set_bit(ATH10K_FLAG_CRASH_FLUSH, &ar->dev_flags);
 	}
 
 	return ret;
@@ -1985,7 +2077,29 @@
 	}
 }
 
-static void ath10k_wmi_event_scan_start_failed(struct ath10k *ar)
+void ath10k_wmi_stop_scan_work(struct work_struct *work)
+{
+	struct ath10k *ar = container_of(work, struct ath10k,
+					 stop_scan_work);
+	/* Kick firmware to get us back in sync */
+	struct wmi_stop_scan_arg arg = {
+		.req_id = 1, /* FIXME */
+		.req_type = WMI_SCAN_STOP_ONE,
+		.u.scan_id = ATH10K_SCAN_ID,
+	};
+	int ret;
+
+	ath10k_warn(ar, "calling wmi-stop-scan from wmi-stop-scan-work\n");
+
+	mutex_lock(&ar->conf_mutex);
+	ret = ath10k_wmi_stop_scan(ar, &arg);
+	if (ret)
+		ath10k_warn(ar, "stop-scan-work: failed to stop wmi scan: %d\n", ret);
+	mutex_unlock(&ar->conf_mutex);
+}
+
+static void ath10k_wmi_event_scan_start_failed(struct ath10k *ar,
+					       enum wmi_scan_completion_reason reason)
 {
 	lockdep_assert_held(&ar->data_lock);
 
@@ -2000,6 +2114,13 @@
 	case ATH10K_SCAN_STARTING:
 		complete(&ar->scan.started);
 		__ath10k_scan_finish(ar);
+		if (reason == WMI_SCAN_REASON_BUSY) {
+			/* Cannot make WMI calls directly here, we are under data_lock and at
+			 * least sometimes in IRQ context.
+			 */
+			ath10k_warn(ar, "received scan start failed event in scan-starting state, will request stop-scan-work\n");
+			queue_work(ar->workqueue, &ar->stop_scan_work);
+		}
 		break;
 	}
 }
@@ -2088,6 +2209,8 @@
 			return "completed [timedout]";
 		case WMI_SCAN_REASON_INTERNAL_FAILURE:
 			return "completed [internal err]";
+		case WMI_SCAN_REASON_BUSY:
+			return "completed [failed, busy]";
 		case WMI_SCAN_REASON_MAX:
 			break;
 		}
@@ -2176,8 +2299,11 @@
 		ath10k_wmi_event_scan_foreign_chan(ar, freq);
 		break;
 	case WMI_SCAN_EVENT_START_FAILED:
-		ath10k_warn(ar, "received scan start failure event\n");
-		ath10k_wmi_event_scan_start_failed(ar);
+		ath10k_warn(ar, "scan-start-failed event %s type %d reason %d freq %d req_id %d scan_id %d vdev_id %d state %s (%d)\n",
+			    ath10k_wmi_event_scan_type_str(event_type, reason),
+			    event_type, reason, freq, req_id, scan_id, vdev_id,
+			    ath10k_scan_state_str(ar->scan.state), ar->scan.state);
+		ath10k_wmi_event_scan_start_failed(ar, reason);
 		break;
 	case WMI_SCAN_EVENT_DEQUEUED:
 	case WMI_SCAN_EVENT_PREEMPTED:
@@ -2229,12 +2355,15 @@
 					 struct wmi_mgmt_rx_ev_arg *arg)
 {
 	struct wmi_mgmt_rx_event_v1 *ev_v1;
-	struct wmi_mgmt_rx_event_v2 *ev_v2;
+	struct wmi_mgmt_rx_event_v2 *ev_v2 = NULL;
 	struct wmi_mgmt_rx_hdr_v1 *ev_hdr;
 	struct wmi_mgmt_rx_ext_info *ext_info;
 	size_t pull_len;
 	u32 msdu_len;
 	u32 len;
+	int i;
+	u32 snr;
+	u32 channel;
 
 	if (test_bit(ATH10K_FW_FEATURE_EXT_WMI_MGMT_RX,
 		     ar->running_fw->fw_file.fw_features)) {
@@ -2257,6 +2386,27 @@
 	arg->snr = ev_hdr->snr;
 	arg->phy_mode = ev_hdr->phy_mode;
 	arg->rate = ev_hdr->rate;
+	if (ev_v2)
+		for (i = 0; i<4; i++)
+			arg->rssi_ctl[i] = ev_v2->hdr.rssi_ctl[i];
+
+	snr = __le32_to_cpu(arg->snr);
+	channel = __le32_to_cpu(arg->channel);
+
+	/* Recent CT wave-1 firmware can report per-chain values if properly requested... */
+	if ((snr & 0xFFFFFF00) || (channel & 0xFF000000)) {
+		/* pri20_mhz signal */
+		arg->rssi_ctl[0] = snr >> 8;
+		arg->rssi_ctl[1] = snr >> 16;
+		arg->rssi_ctl[2] = snr >> 24;
+		snr = snr & 0xFF;
+
+		arg->rssi_ctl[3] = channel >> 24;
+		channel = channel & 0xFFFFFF;
+
+		arg->snr = __cpu_to_le32(snr);
+		arg->channel = __cpu_to_le32(channel);
+	}
 
 	msdu_len = __le32_to_cpu(arg->buf_len);
 	if (skb->len < msdu_len)
@@ -2286,6 +2436,7 @@
 	u32 msdu_len;
 	struct wmi_mgmt_rx_ext_info *ext_info;
 	u32 len;
+	int i;
 
 	ev = (struct wmi_10_4_mgmt_rx_event *)skb->data;
 	ev_hdr = &ev->hdr;
@@ -2301,6 +2452,8 @@
 	arg->snr = ev_hdr->snr;
 	arg->phy_mode = ev_hdr->phy_mode;
 	arg->rate = ev_hdr->rate;
+	for (i = 0; i<4; i++)
+		arg->rssi_ctl[i] = ev_hdr->rssi_ctl[i];
 
 	msdu_len = __le32_to_cpu(arg->buf_len);
 	if (skb->len < msdu_len)
@@ -2322,6 +2475,12 @@
 static bool ath10k_wmi_rx_is_decrypted(struct ath10k *ar,
 				       struct ieee80211_hdr *hdr)
 {
+	/* If using rx-sw-crypt, it is not decrypted */
+	if (test_bit(ATH10K_FW_FEATURE_CT_RXSWCRYPT,
+		     ar->running_fw->fw_file.fw_features) &&
+	    ar->request_nohwcrypt)
+		return false;
+
 	if (!ieee80211_has_protected(hdr->frame_control))
 		return false;
 
@@ -2454,6 +2613,13 @@
 	u32 rate;
 	u16 fc;
 	int ret;
+	int i;
+
+	/* Initialize the rssi to 'ignore-me' value, stock wave-1
+	 * firmware doesn't support it.
+	 */
+	for (i = 0; i<4; i++)
+		arg.rssi_ctl[i] = 0x80;
 
 	ret = ath10k_wmi_pull_mgmt_rx(ar, skb, &arg);
 	if (ret) {
@@ -2512,6 +2678,12 @@
 
 	status->freq = ieee80211_channel_to_frequency(channel, status->band);
 	status->signal = snr + ATH10K_DEFAULT_NOISE_FLOOR;
+	for (i = 0; i<4; i++) {
+		if (arg.rssi_ctl[i] != 0x80) {
+			status->chains |= BIT(i);
+			status->chain_signal[i] = ATH10K_DEFAULT_NOISE_FLOOR + arg.rssi_ctl[i];
+		}
+	}
 	status->rate_idx = ath10k_mac_bitrate_to_idx(sband, rate / 100);
 
 	hdr = (struct ieee80211_hdr *)skb->data;
@@ -2542,13 +2714,16 @@
 		ath10k_mac_handle_beacon(ar, skb);
 
 	ath10k_dbg(ar, ATH10K_DBG_MGMT,
-		   "event mgmt rx skb %pK len %d ftype %02x stype %02x\n",
+		   "event mgmt rx skb %pK len %d ftype %02x stype %02x decrypted: %d\n",
 		   skb, skb->len,
-		   fc & IEEE80211_FCTL_FTYPE, fc & IEEE80211_FCTL_STYPE);
+		   fc & IEEE80211_FCTL_FTYPE, fc & IEEE80211_FCTL_STYPE, ath10k_wmi_rx_is_decrypted(ar, hdr));
 
 	ath10k_dbg(ar, ATH10K_DBG_MGMT,
-		   "event mgmt rx freq %d band %d snr %d, rate_idx %d\n",
+		   "event mgmt rx freq %d band %d snr %d chains: 0x%x(%d %d %d %d), rate_idx %d\n",
 		   status->freq, status->band, status->signal,
+		   status->chains,
+		   status->chain_signal[0], status->chain_signal[1],
+		   status->chain_signal[2], status->chain_signal[3],
 		   status->rate_idx);
 
 	ieee80211_rx_ni(ar->hw, skb);
@@ -2764,14 +2939,170 @@
 
 int ath10k_wmi_event_debug_mesg(struct ath10k *ar, struct sk_buff *skb)
 {
+	struct ath10k_fw_dbglog_report *ev;
+
 	ath10k_dbg(ar, ATH10K_DBG_WMI, "wmi event debug mesg len %d\n",
 		   skb->len);
 
 	trace_ath10k_wmi_dbglog(ar, skb->data, skb->len);
+	ev = (struct ath10k_fw_dbglog_report *)skb->data;
+
+	/* First 4 bytes are a messages-dropped-due-to-overflow counter,
+	 * and should not be recorded in the dbglog buffer, so we skip
+	 * them.
+	 */
+	WARN_ON(skb->len & 0x3);
+	spin_lock_bh(&ar->data_lock);
+	ath10k_dbg_save_fw_dbg_buffer(ar, ev->messages,
+				      (skb->len - 4)/sizeof(__le32));
+	spin_unlock_bh(&ar->data_lock);
+
+	if (ath10k_debug_mask & ATH10K_DBG_NO_DBGLOG) {
+		static bool done_once = false;
+		if (!done_once) {
+			ath10k_info(ar, "NOTE:  Firmware DBGLOG output disabled in debug_mask: 0x%x\n",
+				    ath10k_debug_mask);
+			done_once = true;
+		}
+		return 0;
+	}
+
+	if (ev->dropped_count)
+		ath10k_warn(ar, "WARNING: Dropped dbglog buffers: %d\n", __le32_to_cpu(ev->dropped_count));
+
+	if (ath10k_debug_mask & ATH10K_DBG_FW)
+		ath10k_dbg_print_fw_dbg_buffer(ar, ev->messages,
+					       (skb->len - 4)/sizeof(__le32),
+					       KERN_INFO);
+	else
+		ath10k_dbg_print_fw_dbg_buffer(ar, ev->messages,
+					       (skb->len - 4)/sizeof(__le32),
+					       KERN_DEBUG);
 
 	return 0;
 }
 
+int ath10k_wmi_event_csi_mesg(struct ath10k *ar, struct sk_buff *skb)
+{
+	__le32 *ibuf;
+	int q = 0;
+	int len;
+	const char* lvl = KERN_INFO;
+
+	ath10k_dbg(ar, ATH10K_DBG_WMI, "wmi event csi mesg len %d\n",
+		   skb->len);
+
+	ibuf = (__le32*)(skb->data);
+	len = skb->len / 4;
+
+	/* Add to accumulator */
+	if (ar->csi_data_len + skb->len < sizeof(ar->csi_data)) {
+		memcpy(ar->csi_data + ar->csi_data_len, skb->data, skb->len);
+		ar->csi_data_len += skb->len;
+	}
+	else {
+		ath10k_err(ar, "CSI accumulator overflow, csi-data-len: %d  skb->len: %d\n",
+			   ar->csi_data_len, skb->len);
+		goto printme;
+	}
+
+	if (ibuf[len - 1] != 0x444E4544) {
+		// Wait for next one, this one is not the 'DNED'
+		ath10k_dbg(ar, ATH10K_DBG_WMI,
+			   "CSI last: 0x%x, will look for another one, accum-len: %d\n",
+			   ibuf[len - 1], ar->csi_data_len);
+		return 0;
+	}
+
+printme:
+	ibuf = (__le32*)(ar->csi_data);
+	len = ar->csi_data_len / 4;
+
+	/* This is quite noisy, need a better way to get this to user-space. */
+	/* This is the CFR data, channel-frequency-response */
+	dev_printk(lvl, ar->dev, "ath10k_pci ATH10K_CSI_BUFFER:\n");
+	while (q < len) {
+		if (q + 8 <= len) {
+			printk("%sath10k: [%04d]: %08X %08X %08X %08X %08X %08X %08X %08X\n",
+			       lvl, q,
+			       ibuf[q], ibuf[q+1], ibuf[q+2], ibuf[q+3],
+			       ibuf[q+4], ibuf[q+5], ibuf[q+6], ibuf[q+7]);
+			q += 8;
+		}
+		else if (q + 7 <= len) {
+			printk("%sath10k: [%04d]: %08X %08X %08X %08X %08X %08X %08X\n",
+			       lvl, q,
+			       ibuf[q], ibuf[q+1], ibuf[q+2], ibuf[q+3],
+			       ibuf[q+4], ibuf[q+5], ibuf[q+6]);
+			q += 7;
+		}
+		else if (q + 6 <= len) {
+			printk("%sath10k: [%04d]: %08X %08X %08X %08X %08X %08X\n",
+			       lvl, q,
+			       ibuf[q], ibuf[q+1], ibuf[q+2], ibuf[q+3],
+			       ibuf[q+4], ibuf[q+5]);
+			q += 6;
+		}
+		else if (q + 5 <= len) {
+			printk("%sath10k: [%04d]: %08X %08X %08X %08X %08X\n",
+			       lvl, q,
+			       ibuf[q], ibuf[q+1], ibuf[q+2], ibuf[q+3],
+			       ibuf[q+4]);
+			q += 5;
+		}
+		else if (q + 4 <= len) {
+			printk("%sath10k: [%04d]: %08X %08X %08X %08X\n",
+			       lvl, q,
+			       ibuf[q], ibuf[q+1], ibuf[q+2], ibuf[q+3]);
+			q += 4;
+		}
+		else if (q + 3 <= len) {
+			printk("%sath10k: [%04d]: %08X %08X %08X\n",
+			       lvl, q,
+			       ibuf[q], ibuf[q+1], ibuf[q+2]);
+			q += 3;
+		}
+		else if (q + 2 <= len) {
+			printk("%sath10k: [%04d]: %08X %08X\n",
+			       lvl, q,
+			       ibuf[q], ibuf[q+1]);
+			q += 2;
+		}
+		else if (q + 1 <= len) {
+			printk("%sath10k: [%04d]: %08X\n",
+			       lvl, q,
+			       ibuf[q]);
+			q += 1;
+		}
+		else {
+			break;
+		}
+	}/* while */
+
+	ar->csi_data_len = 0; /* reset accumulator */
+	dev_printk(lvl, ar->dev, "ATH10K_END\n");
+	return 0;
+}
+
+int ath10k_wmi_event_txbf_cv_mesg(struct ath10k *ar, struct sk_buff *skb)
+{
+	struct wmi_txbf_cv_event *ev;
+
+	trace_ath10k_wmi_dbglog(ar, skb->data, skb->len);
+	ev = (struct wmi_txbf_cv_event *)skb->data;
+
+	/* NOTE:  cv-pool-idx is zero-based and is specific to the txbf logic.  In current
+	 * 10.4 firmware, this will translate to memory pool 1 since the ratectrl logic grabs the first
+	 * pool-id.
+	 */
+	ath10k_warn(ar, /*ATH10K_DBG_WMI,*/ "wmi event txbf_cv mesg len %d,  vdev: %d peer: %pM cv-pool-idx: %d cv-record-size: %d cv-record-idx: %d type: %d mu-mimo: %d Nc: %d BW: %d Nr: %d cv_size: %d state: %d\n",
+		    skb->len, ev->vdev_id, ev->peer_macaddr.addr, ev->pool_idx,
+		    ev->cv_record_size, ev->cv_record_idx, ev->cv_type,
+		    ev->mu_mimo, ev->Nc, ev->BW, ev->Nr, ev->cv_size,
+		    ev->state);
+	return 0;
+}
+
 void ath10k_wmi_pull_pdev_stats_base(const struct wmi_pdev_stats_base *src,
 				     struct ath10k_fw_stats_pdev *dst)
 {
@@ -2898,6 +3229,14 @@
 	dst->peer_rssi = __le32_to_cpu(src->peer_rssi);
 	dst->peer_tx_rate = __le32_to_cpu(src->peer_tx_rate);
 	dst->peer_rx_rate = __le32_to_cpu(src->peer_rx_rate);
+	/* Firmware stores these internally as 16 bits.  CT firmware may pack
+	 * peer's TX PN into top 16 bits if the user has previously set the
+	 * PN when setting a key or used the ct-special API to enable reporting PN.
+	 */
+	dst->pn = __le32_to_cpu(src->num_pkt_loss_excess_retry[2]) >> 16;
+	dst->pn <<= 32;
+	dst->pn |= (__le32_to_cpu(src->num_pkt_loss_excess_retry[1]) & 0xFFFF0000);
+	dst->pn |= __le32_to_cpu(src->num_pkt_loss_excess_retry[0]) >> 16;
 }
 
 static void
@@ -2981,13 +3320,14 @@
 					   struct ath10k_fw_stats *stats)
 {
 	const struct wmi_stats_event *ev = (void *)skb->data;
-	u32 num_pdev_stats, num_peer_stats;
+	u32 num_pdev_stats, num_vdev_stats, num_peer_stats;
 	int i;
 
 	if (!skb_pull(skb, sizeof(*ev)))
 		return -EPROTO;
 
 	num_pdev_stats = __le32_to_cpu(ev->num_pdev_stats);
+	num_vdev_stats = __le32_to_cpu(ev->num_vdev_stats);
 	num_peer_stats = __le32_to_cpu(ev->num_peer_stats);
 
 	for (i = 0; i < num_pdev_stats; i++) {
@@ -3010,14 +3350,47 @@
 		list_add_tail(&dst->list, &stats->pdevs);
 	}
 
-	/* fw doesn't implement vdev stats */
+	/* (stock) fw doesn't implement vdev stats */
+	for (i = 0; i < num_vdev_stats; i++) {
+		const struct wmi_vdev_stats_ct *src = (void *)(skb->data);
+		struct ath10k_fw_stats_vdev *dst;
+		int sz;
+
+		if (!skb_pull(skb, sizeof(*src)))
+			return -EPROTO;
+
+		/* Look for any existing vdev */
+		dst = kzalloc(sizeof(*dst), GFP_ATOMIC);
+		if (!dst)
+			continue;
+
+		sz = __le32_to_cpu(src->size);
+		dst->vdev_id = src->vdev_id;
+		dst->tsf64 = __le32_to_cpu(src->tsf_hi);
+		dst->tsf64 <<= 32;
+		dst->tsf64 |= __le32_to_cpu(src->tsf_lo);
+
+		list_add_tail(&dst->list, &stats->vdevs);
+
+		if (sz > sizeof(*src)) {
+			/* Discard any extra for forwards-compat */
+			if (!skb_pull(skb, sz - sizeof(*src)))
+				return -EPROTO;
+		}
+	}
 
 	for (i = 0; i < num_peer_stats; i++) {
 		const struct wmi_10x_peer_stats *src;
 		struct ath10k_fw_stats_peer *dst;
+		int stats_len;
+
+		if (test_bit(WMI_SERVICE_PEER_STATS, ar->wmi.svc_map))
+			stats_len = sizeof(struct wmi_10x_peer_stats_ct_ext);
+		else
+			stats_len = sizeof(*src);
 
 		src = (void *)skb->data;
-		if (!skb_pull(skb, sizeof(*src)))
+		if (!skb_pull(skb, stats_len))
 			return -EPROTO;
 
 		dst = kzalloc(sizeof(*dst), GFP_ATOMIC);
@@ -3028,6 +3401,11 @@
 
 		dst->peer_rx_rate = __le32_to_cpu(src->peer_rx_rate);
 
+		if (ath10k_peer_stats_enabled(ar)) {
+			struct wmi_10x_peer_stats_ct_ext *src2 = (void*)(src);
+			dst->rx_duration = __le32_to_cpu(src2->rx_duration);
+		}
+
 		list_add_tail(&dst->list, &stats->peers);
 	}
 
@@ -3066,6 +3444,9 @@
 		ath10k_wmi_pull_pdev_stats_base(&src->base, dst);
 		ath10k_wmi_pull_pdev_stats_tx(&src->tx, dst);
 		ath10k_wmi_pull_pdev_stats_rx(&src->rx, dst);
+		dst->rx_timeout_errs = __le32_to_cpu(src->pdev_rx_timeout);
+		dst->dram_free = __le32_to_cpu(src->mem.dram_free);
+		dst->iram_free = __le32_to_cpu(src->mem.iram_free);
 		ath10k_wmi_pull_pdev_stats_extra(&src->extra, dst);
 		/* FIXME: expose 10.2 specific values */
 
@@ -3235,7 +3616,11 @@
 		ath10k_wmi_pull_pdev_stats_base(&src->base, dst);
 		ath10k_wmi_10_4_pull_pdev_stats_tx(&src->tx, dst);
 		ath10k_wmi_pull_pdev_stats_rx(&src->rx, dst);
+		dst->rx_timeout_errs = __le32_to_cpu(src->pdev_rx_timeout);
 		dst->rx_ovfl_errs = __le32_to_cpu(src->rx_ovfl_errs);
+		dst->dram_free = __le32_to_cpu(src->mem.dram_free);
+		dst->iram_free = __le32_to_cpu(src->mem.iram_free);
+		dst->sram_free = __le32_to_cpu(src->mem.sram_free);
 		ath10k_wmi_pull_pdev_stats_extra(&src->extra, dst);
 
 		list_add_tail(&dst->list, &stats->pdevs);
@@ -3412,6 +3797,9 @@
 	skb_pull(skb, sizeof(*ev));
 	arg->mac_addr = ev->peer_macaddr.addr;
 
+	/* CT Firmware may sneak in some info in the un-used space. */
+	arg->unused_hi = __le32_to_cpu(ev->peer_macaddr.word1) >> 16;
+
 	return 0;
 }
 
@@ -3817,7 +4205,8 @@
 
 		bcn = ieee80211_beacon_get(ar->hw, arvif->vif);
 		if (!bcn) {
-			ath10k_warn(ar, "could not get mac80211 beacon\n");
+			ath10k_warn(ar, "could not get mac80211 beacon, vdev_id: %i addr: %pM\n",
+				    arvif->vdev_id, arvif->vif->addr);
 			continue;
 		}
 
@@ -3885,6 +4274,8 @@
 	ath10k_dbg(ar, ATH10K_DBG_WMI, "WMI_TBTTOFFSET_UPDATE_EVENTID\n");
 }
 
+
+
 static void ath10k_radar_detected(struct ath10k *ar)
 {
 	ath10k_dbg(ar, ATH10K_DBG_REGULATORY, "dfs radar detected\n");
@@ -3960,6 +4351,10 @@
 	u8 rssi, width;
 	struct ath10k_radar_found_info *radar_info;
 
+#ifdef ATH_HAVE_PULSE_EVENT_MSG
+	pe.msg[0] = 0;
+#endif
+
 	reg0 = __le32_to_cpu(rr->reg0);
 	reg1 = __le32_to_cpu(rr->reg1);
 
@@ -3977,9 +4372,9 @@
 		   MS(reg1, RADAR_REPORT_REG1_PULSE_AGC_MB_GAIN),
 		   MS(reg1, RADAR_REPORT_REG1_PULSE_SUBCHAN_MASK));
 	ath10k_dbg(ar, ATH10K_DBG_REGULATORY,
-		   "wmi phyerr radar report pulse_tsf_offset 0x%X pulse_dur: %d\n",
+		   "wmi phyerr radar report pulse_tsf_offset 0x%X pulse_dur: %d dfs-detector: %p\n",
 		   MS(reg1, RADAR_REPORT_REG1_PULSE_TSF_OFFSET),
-		   MS(reg1, RADAR_REPORT_REG1_PULSE_DUR));
+		   MS(reg1, RADAR_REPORT_REG1_PULSE_DUR), ar->dfs_detector);
 
 	if (!ar->dfs_detector)
 		return;
@@ -4018,8 +4413,8 @@
 	pe.rssi = rssi;
 	pe.chirp = (MS(reg0, RADAR_REPORT_REG0_PULSE_IS_CHIRP) != 0);
 	ath10k_dbg(ar, ATH10K_DBG_REGULATORY,
-		   "dfs add pulse freq: %d, width: %d, rssi %d, tsf: %llX\n",
-		   pe.freq, pe.width, pe.rssi, pe.ts);
+		   "dfs add pulse freq: %d, width: %d, rssi %d, tsf: %llX chirp: %d\n",
+		   pe.freq, pe.width, pe.rssi, pe.ts, pe.chirp);
 
 	ATH10K_DFS_STAT_INC(ar, pulses_detected);
 
@@ -4062,6 +4457,17 @@
 	}
 
 radar_detected:
+
+/* so we can compile out-of-tree easier */
+#if defined(ATH_HAVE_PULSE_EVENT_MSG) && defined(CONFIG_ATH10K_DEBUGFS)
+	if (pe.msg[0]) {
+		strncpy(ar->debug.dfs_last_msg, pe.msg,
+			sizeof(ar->debug.dfs_last_msg));
+		/* ensure null term */
+		ar->debug.dfs_last_msg[sizeof(ar->debug.dfs_last_msg) - 1] = 0;
+	}
+#endif
+
 	ath10k_radar_detected(ar);
 }
 
@@ -4501,7 +4907,7 @@
 
 void ath10k_wmi_event_debug_print(struct ath10k *ar, struct sk_buff *skb)
 {
-	char buf[101], c;
+	char buf[WMI_MAX_DEBUG_MESG + 1], c;
 	int i;
 
 	for (i = 0; i < sizeof(buf) - 1; i++) {
@@ -4529,7 +4935,7 @@
 	/* the last byte is always reserved for the null character */
 	buf[i] = '\0';
 
-	ath10k_dbg(ar, ATH10K_DBG_WMI_PRINT, "wmi print '%s'\n", buf);
+	ath10k_info(ar, "wmi print '%s'\n", buf);
 }
 
 void ath10k_wmi_event_pdev_qvit(struct ath10k *ar, struct sk_buff *skb)
@@ -5447,6 +5853,19 @@
 	ath10k_dbg_dump(ar, ATH10K_DBG_WMI, NULL, "wmi svc: ",
 			arg.service_map, arg.service_map_len);
 
+	// RX Sw Crypt mode, which uses raw receive and disables some HW rx logic,
+	// appears to break receiving MU-MIMO properly, so tweak that here.
+	if (test_bit(ATH10K_FW_FEATURE_CT_RXSWCRYPT,
+		     ar->running_fw->fw_file.fw_features) &&
+	    ar->request_nohwcrypt)
+		ar->vht_cap_info &= ~IEEE80211_VHT_CAP_MU_BEAMFORMEE_CAPABLE;
+
+	if (ar->request_nobeamform_mu)
+		ar->vht_cap_info &= ~(IEEE80211_VHT_CAP_MU_BEAMFORMEE_CAPABLE | IEEE80211_VHT_CAP_MU_BEAMFORMER_CAPABLE);
+
+	if (ar->request_nobeamform_su)
+		ar->vht_cap_info &= ~(IEEE80211_VHT_CAP_SU_BEAMFORMEE_CAPABLE | IEEE80211_VHT_CAP_SU_BEAMFORMER_CAPABLE);
+
 	if (ar->num_rf_chains > ar->max_spatial_stream) {
 		ath10k_warn(ar, "hardware advertises support for more spatial streams than it should (%d > %d)\n",
 			    ar->num_rf_chains, ar->max_spatial_stream);
@@ -5468,6 +5887,20 @@
 			 ar->fw_version_build);
 	}
 
+	if ((ar->eeprom_regdom != -1) &&
+	    (ar->eeprom_regdom != ar->ath_common.regulatory.current_rd)) {
+		if (!ar->eeprom_regdom_warned) {
+			ath10k_err(ar, "DANGER! You're overriding EEPROM-defined regulatory domain\n");
+			ath10k_err(ar, "from: 0x%x to 0x%x (svc-ready-work)\n",
+				   ar->ath_common.regulatory.current_rd, ar->eeprom_regdom);
+			ath10k_err(ar, "Your card was not certified to operate in the domain you chose.\n");
+			ath10k_err(ar, "This might result in a violation of your local regulatory rules.\n");
+			ath10k_err(ar, "Do not ever do this unless you really know what you are doing!\n");
+			ar->eeprom_regdom_warned = 1;
+		}
+		ar->ath_common.regulatory.current_rd = ar->eeprom_regdom | COUNTRY_ERD_FLAG;
+	}
+
 	num_mem_reqs = __le32_to_cpu(arg.num_mem_reqs);
 	if (num_mem_reqs > WMI_MAX_MEM_REQS) {
 		ath10k_warn(ar, "requested memory chunks number (%d) exceeds the limit\n",
@@ -5476,18 +5909,28 @@
 	}
 
 	if (test_bit(WMI_SERVICE_PEER_CACHING, ar->wmi.svc_map)) {
-		if (test_bit(ATH10K_FW_FEATURE_PEER_FLOW_CONTROL,
-			     ar->running_fw->fw_file.fw_features))
-			ar->num_active_peers = TARGET_10_4_QCACHE_ACTIVE_PEERS_PFC +
-					       ar->max_num_vdevs;
-		else
-			ar->num_active_peers = TARGET_10_4_QCACHE_ACTIVE_PEERS +
-					       ar->max_num_vdevs;
 
-		ar->max_num_peers = TARGET_10_4_NUM_QCACHE_PEERS_MAX +
-				    ar->max_num_vdevs;
-		ar->num_tids = ar->num_active_peers * 2;
-		ar->max_num_stations = TARGET_10_4_NUM_QCACHE_PEERS_MAX;
+		/* Don't over-ride user-specified config here, but otherwise,
+		 * adjust in case we are using PEER caching.
+		 */
+		if (!(ar->fwcfg.flags & ATH10K_FWCFG_ACTIVE_PEERS)) {
+			if (test_bit(ATH10K_FW_FEATURE_PEER_FLOW_CONTROL,
+				     ar->running_fw->fw_file.fw_features))
+				ar->num_active_peers = TARGET_10_4_QCACHE_ACTIVE_PEERS_PFC +
+					ar->max_num_vdevs;
+			else
+				ar->num_active_peers = TARGET_10_4_QCACHE_ACTIVE_PEERS +
+					ar->max_num_vdevs;
+		}
+
+		if (!(ar->fwcfg.flags & ATH10K_FWCFG_PEERS))
+			ar->max_num_peers = TARGET_10_4_NUM_QCACHE_PEERS_MAX +
+				ar->max_num_vdevs;
+
+		if (!(ar->fwcfg.flags & ATH10K_FWCFG_NUM_TIDS))
+			ar->num_tids = ar->num_active_peers * 2;
+		if (!(ar->fwcfg.flags & ATH10K_FWCFG_STATIONS))
+			ar->max_num_stations = TARGET_10_4_NUM_QCACHE_PEERS_MAX;
 	}
 
 	/* TODO: Adjust max peer count for cases like WMI_SERVICE_RATECTRL_CACHE
@@ -5528,6 +5971,15 @@
 			num_units = ar->max_num_vdevs + 1;
 		}
 
+		/* NOTE:  For 10.4 firmware, req-id appears to be this (grep MEM_REQ_ID in firmware src):
+		   1:  rate-ctrl
+		   2:  txbf-cv-pool0  (log-size 8)
+		   3:  txbf-cv-pool1  (log-size 10)
+		   4:  txbf-cv-pool2  (log-size 12)
+		   5:  peer-cache
+		   6:  scan-channel CAL data
+		   7:  home-channel CAL data
+		*/
 		ath10k_dbg(ar, ATH10K_DBG_WMI,
 			   "wmi mem_req_id %d num_units %d num_unit_info %d unit size %d actual units %d\n",
 			   req_id,
@@ -5655,6 +6107,7 @@
 	const struct wmi_pdev_temperature_event *ev;
 
 	ev = (struct wmi_pdev_temperature_event *)skb->data;
+
 	if (WARN_ON(skb->len < sizeof(*ev)))
 		return -EPROTO;
 
@@ -5662,6 +6115,132 @@
 	return 0;
 }
 
+
+static void ath10k_wmi_process_generic_buffer(struct ath10k* ar, const struct wmi_generic_buffer_event *ev,
+					      u32 len, u8 *buf)
+{
+	u32 type = __le32_to_cpu(ev->buf_type);
+	switch (type) {
+	case WMI_BUFFER_TYPE_RATEPWR_TABLE:
+#ifdef CONFIG_ATH10K_DEBUGFS
+		if (len > sizeof(ar->debug.ratepwr_tbl)) {
+			ath10k_err(ar, "wmi-generic, len: %u > ratepwr-table length: %d\n",
+				   len, (int)(sizeof(ar->debug.ratepwr_tbl)));
+		}
+		else {
+			memcpy(&ar->debug.ratepwr_tbl, buf, len);
+			ar->debug.ratepwr_tbl_len = len;
+			complete(&ar->debug.ratepwr_tbl_complete);
+		}
+		break;
+#endif
+	case WMI_BUFFER_TYPE_CTL_TABLE:
+#ifdef CONFIG_ATH10K_DEBUGFS
+		if (len > sizeof(ar->debug.powerctl_tbl)) {
+			ath10k_err(ar, "wmi-generic, len: %u > powerctl-table length: %d\n",
+				   len, (int)(sizeof(ar->debug.powerctl_tbl)));
+		}
+		else {
+			memcpy(&ar->debug.powerctl_tbl, buf, len);
+			ar->debug.powerctl_tbl_len = len;
+			complete(&ar->debug.powerctl_tbl_complete);
+		}
+		break;
+#endif
+	default:
+		ath10k_dbg(ar, ATH10K_DBG_WMI,
+			   "wmi generic event type: %d is not currently handled.\n",
+			   type);
+	}
+}
+
+static void ath10k_wmi_generic_buffer_eventid(struct ath10k *ar, struct sk_buff *skb)
+{
+	const struct wmi_generic_buffer_event *ev;
+	u32 len;
+	u32 more_frag;
+
+	ev = (struct wmi_generic_buffer_event *)skb->data;
+
+	if (WARN_ON_ONCE(skb->len < sizeof(*ev)))
+		return;
+
+	len = __le32_to_cpu(ev->buf_len);
+	more_frag = __le32_to_cpu(ev->more_frag);
+
+	ath10k_info(ar, "wmi event generic-buffer, type: %d  frag-id: %d more-frag: %d  buf-len: %d\n",
+		    __le32_to_cpu(ev->buf_type), __le32_to_cpu(ev->frag_id), more_frag, len);
+
+	/* Firmware can send us chunked messages, store them up until we have last message */
+	/* Firmware can also run out of buffers and send us incomplete series, deal with that. */
+	if (ar->wmi.gen_buf_len && ar->wmi.last_generic_event.buf_type != ev->buf_type) {
+		ath10k_info(ar, "wmi event generic-buffer, type: %d  frag-id: %d more-frag: %d  buf-len: %d, cur-len: %d  last-generic-type: %d\n",
+			    __le32_to_cpu(ev->buf_type), __le32_to_cpu(ev->frag_id), more_frag, len,
+			    ar->wmi.gen_buf_len, __le32_to_cpu(ar->wmi.last_generic_event.buf_type));
+		ar->wmi.gen_buf_len = 0; /* Start over, something was weird */
+	}
+
+	if (ar->wmi.gen_buf_len + len > sizeof(ar->wmi.gen_buffer)) {
+		ath10k_info(ar, "wmi event generic-buffer, type: %d  frag-id: %d more-frag: %d  buf-len: %d, cur-len: %d, max-allowed: %d (MESSAGE_TOO_LONG)\n",
+			    __le32_to_cpu(ev->buf_type), __le32_to_cpu(ev->frag_id), more_frag, len,
+			    ar->wmi.gen_buf_len, (int)(sizeof(ar->wmi.gen_buffer)));
+		ar->wmi.gen_buf_len = 0; /* Start over, something was weird */
+	}
+
+	memcpy(ar->wmi.gen_buffer + ar->wmi.gen_buf_len, ev->buf_info, len);
+	ar->wmi.gen_buf_len += len;
+
+	if (!more_frag) {
+		ath10k_wmi_process_generic_buffer(ar, ev, ar->wmi.gen_buf_len, ar->wmi.gen_buffer);
+		ar->wmi.gen_buf_len = 0;
+	}
+	else {
+		memcpy(&ar->wmi.last_generic_event, ev, sizeof(*ev));
+	}
+}
+
+static void ath10k_wmi_event_beacon_tx(struct ath10k *ar, struct sk_buff *skb)
+{
+	struct ath10k_vif *arvif;
+	struct wmi_beacon_tx_event *ev;
+	u32 vdev_id;
+	u32 status;
+
+	spin_lock_bh(&ar->data_lock);
+
+	ev = (struct wmi_beacon_tx_event *)skb->data;
+
+	if (WARN_ON_ONCE(skb->len < sizeof(*ev)))
+		goto exit;
+
+	vdev_id = __le32_to_cpu(ev->vdev_id);
+	status = __le32_to_cpu(ev->tx_status);
+
+	ath10k_dbg(ar, ATH10K_DBG_BEACON,
+		   "wmi event beacon-tx-complete, vdev-id: %u  completion-status: 0x%x (%s) tried: %d failed: %d ratecode: 0x%x rateflags: 0x%x  tsFlags: 0x%x\n",
+		   vdev_id, status,
+		   status == 0 ? "OK" : (status == 1 ? "XRETRY" : (status == 2 ? "DROP" : "UNKNOWN")),
+		   ev->mpdus_tried, ev->mpdus_failed, ev->tx_rate_code, ev->tx_rate_flags, ev->tsFlags);
+
+	/* workaround for possibly firmware bug */
+	if (unlikely(ev->tx_rate_code == ATH10K_CT_TX_BEACON_INVALID_RATE_CODE)) {
+		dev_warn_once(ar->dev, "wmi: fixing invalid VHT TX rate code 0xff\n");
+		ev->tx_rate_code = 0;
+	}
+
+	arvif = ath10k_get_arvif(ar, vdev_id);
+	if (!arvif) {
+		ath10k_warn(ar, "wmi-event-beacon-tx, could not find vdev for id: %u\n",
+			    vdev_id);
+		goto exit;
+	}
+
+	complete(&arvif->beacon_tx_done);
+
+exit:
+	spin_unlock_bh(&ar->data_lock);
+}
+
 static int ath10k_wmi_event_pdev_bss_chan_info(struct ath10k *ar,
 					       struct sk_buff *skb)
 {
@@ -5725,7 +6304,11 @@
 		 * coverage class has a non-zero value.
 		 */
 		if (ar->fw_coverage.coverage_class)
-			queue_work(ar->workqueue, &ar->set_coverage_class_work);
+			if (!(test_bit(ATH10K_FW_FEATURE_SET_SPECIAL_CT,
+				       ar->running_fw->fw_file.fw_features) &&
+			      ar->eeprom_overrides.coverage_already_set))
+
+				queue_work(ar->workqueue, &ar->set_coverage_class_work);
 
 		spin_unlock_bh(&ar->data_lock);
 	}
@@ -5850,7 +6433,7 @@
 		ath10k_wmi_event_service_available(ar, skb);
 		break;
 	default:
-		ath10k_warn(ar, "Unknown eventid: %d\n", id);
+		ath10k_warn(ar, "Unknown (main) eventid: %d\n", id);
 		break;
 	}
 
@@ -5980,8 +6563,20 @@
 	case WMI_10X_PDEV_UTF_EVENTID:
 		/* ignore utf events */
 		break;
+	case WMI_10_1_PDEV_TEMPERATURE_EVENTID: /* Newer CT firmware supports this */
+		ath10k_wmi_event_temperature(ar, skb);
+		break;
+	case WMI_10_1_PDEV_BSS_CHAN_INFO_EVENTID: /* Newer CT firmware supports this */
+		ath10k_wmi_event_pdev_bss_chan_info(ar, skb);
+		break;
+	case WMI_10_1_BEACON_TX_EVENTID: /* Feb 28, 2019 CT firmware supports this */
+		ath10k_wmi_event_beacon_tx(ar, skb);
+		break;
+	case WMI_10_1_GENERIC_BUFFER_EVENTID: /* April 2, 2019 CT firmware supports this */
+		ath10k_wmi_generic_buffer_eventid(ar, skb);
+		break;
 	default:
-		ath10k_warn(ar, "Unknown eventid: %d\n", id);
+		ath10k_warn(ar, "Unknown (10.1) eventid: %d\n", id);
 		break;
 	}
 
@@ -6130,7 +6725,7 @@
 		ath10k_wmi_event_peer_sta_ps_state_chg(ar, skb);
 		break;
 	default:
-		ath10k_warn(ar, "Unknown eventid: %d\n", id);
+		ath10k_warn(ar, "Unknown (10.2) eventid: %d\n", id);
 		break;
 	}
 
@@ -6240,6 +6835,12 @@
 	case WMI_10_4_TDLS_PEER_EVENTID:
 		ath10k_wmi_handle_tdls_peer_event(ar, skb);
 		break;
+	case WMI_10_4_TXBF_CV_MESG_EVENTID:
+		ath10k_wmi_event_txbf_cv_mesg(ar, skb);
+		break;
+	case WMI_10_4_BEACON_TX_EVENTID: /* Feb 28, 2019 CT firmware supports this */
+		ath10k_wmi_event_beacon_tx(ar, skb);
+		break;
 	case WMI_10_4_PDEV_TPC_TABLE_EVENTID:
 		ath10k_wmi_event_tpc_final_table(ar, skb);
 		break;
@@ -6249,8 +6850,11 @@
 	case WMI_10_4_PEER_STA_PS_STATECHG_EVENTID:
 		ath10k_wmi_event_peer_sta_ps_state_chg(ar, skb);
 		break;
+	case WMI_10_4_CSI_MESG_EVENTID:
+		ath10k_wmi_event_csi_mesg(ar, skb);
+		break;
 	default:
-		ath10k_warn(ar, "Unknown eventid: %d\n", id);
+		ath10k_warn(ar, "Unknown (10.4) eventid: %d\n", id);
 		break;
 	}
 
@@ -6316,6 +6920,91 @@
 	return skb;
 }
 
+int ath10k_wmi_request_ratepwr_tbl(struct ath10k *ar)
+{
+	struct qca9880_pdev_ratepwr_table_cmd *cmd;
+	struct sk_buff *skb;
+
+	skb = ath10k_wmi_alloc_skb(ar, sizeof(*cmd));
+	if (!skb)
+		return ENOMEM;
+
+	cmd = (struct qca9880_pdev_ratepwr_table_cmd *)skb->data;
+
+	cmd->op = __cpu_to_le32(RATEPWR_TABLE_OPS_GET);
+
+	return ath10k_wmi_cmd_send(ar, skb, ar->wmi.cmd->pdev_ratepwr_table_cmdid);
+}
+
+int ath10k_wmi_request_powerctl_tbl(struct ath10k *ar)
+{
+	struct qca9880_pdev_ratepwr_table_cmd *cmd;
+	struct sk_buff *skb;
+
+	skb = ath10k_wmi_alloc_skb(ar, sizeof(*cmd));
+	if (!skb)
+		return ENOMEM;
+
+	cmd = (struct qca9880_pdev_ratepwr_table_cmd *)skb->data;
+
+	cmd->op = __cpu_to_le32(RATEPWR_TABLE_OPS_GET_CTL); /* CT FW only */
+
+	return ath10k_wmi_cmd_send(ar, skb, ar->wmi.cmd->pdev_ratepwr_table_cmdid);
+}
+
+/* This is for 988x wave-1 firmware.  Probably wave-2 is different WMI API */
+int ath10k_wmi_set_power_ctrl_tbl(struct ath10k *ar, int len, u8* data)
+{
+	struct qca9880_set_ctl_table_cmd *cmd;
+	struct sk_buff *skb;
+
+	if (len != sizeof(struct qca9880_power_ctrl))
+		return EINVAL;
+
+	skb = ath10k_wmi_alloc_skb(ar, 4 + sizeof(struct qca9880_power_ctrl));
+	if (!skb)
+		return ENOMEM;
+
+	cmd = (struct qca9880_set_ctl_table_cmd *)skb->data;
+
+	cmd->ctl_len = __cpu_to_le32(len);
+	memcpy(cmd->ctl_info, data, len);
+
+	return ath10k_wmi_cmd_send(ar, skb, ar->wmi.cmd->pdev_set_ctl_table_cmdid);
+}
+
+int ath10k_wmi_check_apply_board_power_ctl_table(struct ath10k *ar)
+{
+	if (ar->eeprom_overrides.apply_board_power_ctl_table) {
+		if (ar->hw_params.id == QCA988X_HW_2_0_VERSION) {
+			int offset2g = 806;
+			int offset5g = 1572;
+			int len;
+			u8* buf;
+			int ret;
+
+			len = sizeof(struct qca9880_power_ctrl);
+			buf = kmalloc(len, GFP_KERNEL);
+			memcpy(buf, ((u8*)(ar->normal_mode_fw.board_data)) + offset2g, 72 + 72);
+			memcpy(buf + 72 + 72, ((u8*)(ar->normal_mode_fw.board_data)) + offset5g, 144 + 144);
+			if (WARN_ON(len != (72 + 72 + 144 + 144)))
+				return EINVAL;
+			ret = ath10k_wmi_set_power_ctrl_tbl(ar, len, buf);
+			if (ret != 0) {
+				ath10k_warn(ar, "Failed to set power ctrl table, len: %d rv: %d\n",
+					    len, ret);
+			}
+			return ret;
+		}
+		else {
+			ath10k_info(ar, "board_power_ctl_table override not supported for board-id: %d\n",
+				    ar->hw_params.id);
+			return EINVAL;
+		}
+	}
+	return 0;
+}
+
 static struct sk_buff *
 ath10k_wmi_op_gen_pdev_set_rd(struct ath10k *ar, u16 rd, u16 rd2g, u16 rd5g,
 			      u16 ctl2g, u16 ctl5g,
@@ -6420,6 +7109,31 @@
 	return skb;
 }
 
+static struct sk_buff *
+ath10k_wmi_op_gen_pdev_set_fwtest(struct ath10k *ar, u32 id, u32 value)
+{
+	struct wmi_fwtest_set_param_cmd *cmd;
+	struct sk_buff *skb;
+
+	if (id == WMI_PDEV_PARAM_UNSUPPORTED) {
+		ath10k_warn(ar, "fwtest param %d not supported by firmware\n",
+			    id);
+		return ERR_PTR(-EOPNOTSUPP);
+	}
+
+	skb = ath10k_wmi_alloc_skb(ar, sizeof(*cmd));
+	if (!skb)
+		return ERR_PTR(-ENOMEM);
+
+	cmd = (struct wmi_fwtest_set_param_cmd *)skb->data;
+	cmd->param_id    = __cpu_to_le32(id);
+	cmd->param_value = __cpu_to_le32(value);
+
+	ath10k_dbg(ar, ATH10K_DBG_WMI, "wmi fwtest set param %d value %d\n",
+		   id, value);
+	return skb;
+}
+
 void ath10k_wmi_put_host_mem_chunks(struct ath10k *ar,
 				    struct wmi_host_mem_chunks *chunks)
 {
@@ -6449,8 +7163,8 @@
 	struct wmi_resource_config config = {};
 	u32 len, val;
 
-	config.num_vdevs = __cpu_to_le32(TARGET_NUM_VDEVS);
-	config.num_peers = __cpu_to_le32(TARGET_NUM_PEERS);
+	config.num_vdevs = __cpu_to_le32(ar->max_num_vdevs);
+	config.num_peers = __cpu_to_le32(ar->max_num_peers);
 	config.num_offload_peers = __cpu_to_le32(TARGET_NUM_OFFLOAD_PEERS);
 
 	config.num_offload_reorder_bufs =
@@ -6458,7 +7172,7 @@
 
 	config.num_peer_keys = __cpu_to_le32(TARGET_NUM_PEER_KEYS);
 	config.num_tids = __cpu_to_le32(TARGET_NUM_TIDS);
-	config.ast_skid_limit = __cpu_to_le32(TARGET_AST_SKID_LIMIT);
+	config.ast_skid_limit = __cpu_to_le32(ar->skid_limit);
 	config.tx_chain_mask = __cpu_to_le32(TARGET_TX_CHAIN_MASK);
 	config.rx_chain_mask = __cpu_to_le32(TARGET_RX_CHAIN_MASK);
 	config.rx_timeout_pri_vo = __cpu_to_le32(TARGET_RX_TIMEOUT_LO_PRI);
@@ -6469,8 +7183,7 @@
 	config.scan_max_pending_reqs =
 		__cpu_to_le32(TARGET_SCAN_MAX_PENDING_REQS);
 
-	config.bmiss_offload_max_vdev =
-		__cpu_to_le32(TARGET_BMISS_OFFLOAD_MAX_VDEV);
+	config.bmiss_offload_max_vdev = __cpu_to_le32(ar->bmiss_offload_max_vdev);
 
 	config.roam_offload_max_vdev =
 		__cpu_to_le32(TARGET_ROAM_OFFLOAD_MAX_VDEV);
@@ -6522,29 +7235,98 @@
 	struct wmi_resource_config_10x config = {};
 	u32 len, val;
 
-	config.num_vdevs = __cpu_to_le32(TARGET_10X_NUM_VDEVS);
-	config.num_peers = __cpu_to_le32(TARGET_10X_NUM_PEERS);
-	config.num_peer_keys = __cpu_to_le32(TARGET_10X_NUM_PEER_KEYS);
-	config.num_tids = __cpu_to_le32(TARGET_10X_NUM_TIDS);
-	config.ast_skid_limit = __cpu_to_le32(TARGET_10X_AST_SKID_LIMIT);
-	config.tx_chain_mask = __cpu_to_le32(TARGET_10X_TX_CHAIN_MASK);
-	config.rx_chain_mask = __cpu_to_le32(TARGET_10X_RX_CHAIN_MASK);
-	config.rx_timeout_pri_vo = __cpu_to_le32(TARGET_10X_RX_TIMEOUT_LO_PRI);
-	config.rx_timeout_pri_vi = __cpu_to_le32(TARGET_10X_RX_TIMEOUT_LO_PRI);
-	config.rx_timeout_pri_be = __cpu_to_le32(TARGET_10X_RX_TIMEOUT_LO_PRI);
-	config.rx_timeout_pri_bk = __cpu_to_le32(TARGET_10X_RX_TIMEOUT_HI_PRI);
 	config.rx_decap_mode = __cpu_to_le32(ar->wmi.rx_decap_mode);
-	config.scan_max_pending_reqs =
-		__cpu_to_le32(TARGET_10X_SCAN_MAX_PENDING_REQS);
+	config.num_vdevs = __cpu_to_le32(ar->max_num_vdevs);
+	config.num_peers = __cpu_to_le32(ar->max_num_peers);
 
-	config.bmiss_offload_max_vdev =
-		__cpu_to_le32(TARGET_10X_BMISS_OFFLOAD_MAX_VDEV);
+	ath10k_warn(ar, "10.1 wmi init: vdevs: %d  peers: %d  tid: %d\n",
+		    ar->max_num_vdevs, ar->max_num_peers, ar->num_tids);
+
+	config.tx_chain_mask = __cpu_to_le32(TARGET_10X_TX_CHAIN_MASK);
 
 	config.roam_offload_max_vdev =
 		__cpu_to_le32(TARGET_10X_ROAM_OFFLOAD_MAX_VDEV);
 
 	config.roam_offload_max_ap_profiles =
 		__cpu_to_le32(TARGET_10X_ROAM_OFFLOAD_MAX_AP_PROFILES);
+	config.num_peer_keys = __cpu_to_le32(TARGET_10X_NUM_PEER_KEYS);
+
+	config.bmiss_offload_max_vdev = __cpu_to_le32(ar->bmiss_offload_max_vdev);
+
+	if (test_bit(ATH10K_FW_FEATURE_WMI_10X_CT,
+		     ar->running_fw->fw_file.fw_features)) {
+		u32 features = 0;
+
+		if (test_bit(ATH10K_FW_FEATURE_CT_STA,
+			     ar->running_fw->fw_file.fw_features) &&
+		    ar->request_ct_sta) {
+			config.rx_decap_mode = __cpu_to_le32(ATH10K_HW_TXRX_NATIVE_WIFI |
+							     ATH10k_VDEV_CT_STA_MODE);
+			ath10k_info(ar, "using CT-STA mode\n");
+		}
+		else if (test_bit(ATH10K_FW_FEATURE_CT_RXSWCRYPT,
+			     ar->running_fw->fw_file.fw_features) &&
+		    ar->request_nohwcrypt) {
+			/* This will disable rx decryption in hardware, enable raw
+			 * rx mode, and native-wifi tx mode.  Requires 'CT' firmware.
+			 */
+			config.rx_decap_mode = __cpu_to_le32(ATH10K_HW_TXRX_RAW |
+							     ATH10k_USE_SW_RX_CRYPT);
+			ar->use_swcrypt = true;
+			ath10k_info(ar, "using rx swcrypt\n");
+		}
+		else if (ar->request_nohwcrypt) {
+			ath10k_err(ar, "nohwcrypt requested, but firmware does not support this feature.  Disabling swcrypt.\n");
+		}
+		config.rx_decap_mode |= __cpu_to_le32(ATH10k_USE_TXCOMPL_TXRATE | ATH10k_MGT_CHAIN_RSSI_OK
+						      | ATH10k_VDEV_CT_STATS_OK);
+
+		if (test_bit(ATH10K_FW_FEATURE_TXRATE2_CT,
+			     ar->running_fw->fw_file.fw_features))
+			config.rx_decap_mode |= __cpu_to_le32(ATH10k_USE_TXCOMPL_TXRATE2);
+
+		/* Disable WoW in firmware, could make this module option perhaps? */
+		config.rx_decap_mode |= __cpu_to_le32(ATH10k_DISABLE_WOW);
+		config.roam_offload_max_vdev = 0; /* disable roaming */
+		config.roam_offload_max_ap_profiles = 0; /* disable roaming */
+
+		config.num_peer_keys = __cpu_to_le32(TARGET_10X_NUM_PEER_KEYS_CT);
+
+		if (ar->num_ratectrl_objs) {
+			ath10k_info(ar, "using %d firmware rate-ctrl objects\n",
+				    ar->num_ratectrl_objs);
+			config.tx_chain_mask |= __cpu_to_le32(ar->num_ratectrl_objs << 24);
+		}
+
+		if (test_bit(ATH10K_FLAG_BTCOEX, &ar->dev_flags) &&
+		    test_bit(WMI_SERVICE_COEX_GPIO, ar->wmi.svc_map))
+			features |= WMI_10_2_COEX_GPIO;
+
+		if (ath10k_peer_stats_enabled(ar))
+			features |= WMI_10_2_PEER_STATS;
+
+		if (test_bit(WMI_SERVICE_BSS_CHANNEL_INFO_64, ar->wmi.svc_map))
+			features |= WMI_10_2_BSS_CHAN_INFO;
+
+		config.rx_decap_mode |= __cpu_to_le32(features << 24);
+	}
+	config.num_msdu_desc = __cpu_to_le32(ar->htt.max_num_pending_tx);
+	config.ast_skid_limit = __cpu_to_le32(ar->skid_limit);
+
+	/* Firmware will crash if this is not even multiple of 8 */
+	if (WARN_ON(ar->htt.max_num_pending_tx & 0x7)) {
+		ath10k_err(ar, "tx-descriptors must be multiple of 8: %d\n",
+			   ar->htt.max_num_pending_tx);
+	}
+
+	config.num_tids = __cpu_to_le32(ar->num_tids);
+	config.rx_chain_mask = __cpu_to_le32(TARGET_10X_RX_CHAIN_MASK);
+	config.rx_timeout_pri_vo = __cpu_to_le32(TARGET_10X_RX_TIMEOUT_LO_PRI);
+	config.rx_timeout_pri_vi = __cpu_to_le32(TARGET_10X_RX_TIMEOUT_LO_PRI);
+	config.rx_timeout_pri_be = __cpu_to_le32(TARGET_10X_RX_TIMEOUT_LO_PRI);
+	config.rx_timeout_pri_bk = __cpu_to_le32(TARGET_10X_RX_TIMEOUT_HI_PRI);
+	config.scan_max_pending_reqs =
+		__cpu_to_le32(TARGET_10X_SCAN_MAX_PENDING_REQS);
 
 	config.num_mcast_groups = __cpu_to_le32(TARGET_10X_NUM_MCAST_GROUPS);
 	config.num_mcast_table_elems =
@@ -6561,7 +7343,6 @@
 
 	config.vow_config = __cpu_to_le32(TARGET_10X_VOW_CONFIG);
 
-	config.num_msdu_desc = __cpu_to_le32(TARGET_10X_NUM_MSDU_DESC);
 	config.max_frag_entries = __cpu_to_le32(TARGET_10X_MAX_FRAG_ENTRIES);
 
 	len = sizeof(*cmd) +
@@ -6587,38 +7368,81 @@
 	struct wmi_resource_config_10x config = {};
 	u32 len, val, features;
 
-	config.num_vdevs = __cpu_to_le32(TARGET_10X_NUM_VDEVS);
+	config.rx_decap_mode = __cpu_to_le32(ar->wmi.rx_decap_mode);
+
+	config.num_vdevs = __cpu_to_le32(ar->max_num_vdevs);
+	config.num_peers = __cpu_to_le32(ar->max_num_peers);
+	config.tx_chain_mask = __cpu_to_le32(TARGET_10X_TX_CHAIN_MASK);
+
+	config.roam_offload_max_vdev =
+		__cpu_to_le32(TARGET_10X_ROAM_OFFLOAD_MAX_VDEV);
+
+	config.roam_offload_max_ap_profiles =
+		__cpu_to_le32(TARGET_10X_ROAM_OFFLOAD_MAX_AP_PROFILES);
 	config.num_peer_keys = __cpu_to_le32(TARGET_10X_NUM_PEER_KEYS);
+	config.bmiss_offload_max_vdev = __cpu_to_le32(ar->bmiss_offload_max_vdev);
 
 	if (ath10k_peer_stats_enabled(ar)) {
 		config.num_peers = __cpu_to_le32(TARGET_10X_TX_STATS_NUM_PEERS);
-		config.num_tids = __cpu_to_le32(TARGET_10X_TX_STATS_NUM_TIDS);
 	} else {
 		config.num_peers = __cpu_to_le32(TARGET_10X_NUM_PEERS);
-		config.num_tids = __cpu_to_le32(TARGET_10X_NUM_TIDS);
 	}
+	config.num_tids = __cpu_to_le32(ar->num_tids);
 
-	config.ast_skid_limit = __cpu_to_le32(TARGET_10X_AST_SKID_LIMIT);
 	config.tx_chain_mask = __cpu_to_le32(TARGET_10X_TX_CHAIN_MASK);
+
+	if (test_bit(ATH10K_FW_FEATURE_WMI_10X_CT,
+		     ar->running_fw->fw_file.fw_features)) {
+		if (test_bit(ATH10K_FW_FEATURE_CT_RXSWCRYPT,
+			     ar->running_fw->fw_file.fw_features) &&
+		    ar->request_nohwcrypt) {
+			/* This will disable rx decryption in hardware, enable raw
+			 * rx mode, and native-wifi tx mode.  Requires 'CT' firmware.
+			 */
+			config.rx_decap_mode = __cpu_to_le32(ATH10K_HW_TXRX_RAW |
+							     ATH10k_USE_SW_RX_CRYPT);
+			ar->use_swcrypt = true;
+			ath10k_info(ar, "using rx swcrypt\n");
+		}
+		else if (ar->request_nohwcrypt) {
+			ath10k_err(ar, "module param nohwcrypt enabled, but firmware does not support this feature.  Disabling swcrypt.\n");
+		}
+
+		if (test_bit(ATH10K_FW_FEATURE_TXRATE_CT,
+			     ar->running_fw->fw_file.fw_features))
+			config.rx_decap_mode |= __cpu_to_le32(ATH10k_USE_TXCOMPL_TXRATE | ATH10k_MGT_CHAIN_RSSI_OK);
+
+		/* Disable WoW in firmware, could make this module option perhaps? */
+		config.rx_decap_mode |= __cpu_to_le32(ATH10k_DISABLE_WOW);
+
+		config.roam_offload_max_vdev = 0; /* disable roaming */
+		config.roam_offload_max_ap_profiles = 0; /* disable roaming */
+		config.num_peer_keys = __cpu_to_le32(TARGET_10X_NUM_PEER_KEYS_CT);
+
+		if (ar->num_ratectrl_objs) {
+			ath10k_info(ar, "using %d firmware rate-ctrl objects\n",
+				    ar->num_ratectrl_objs);
+			config.tx_chain_mask |= __cpu_to_le32(ar->num_ratectrl_objs << 24);
+		}
+	}
+	config.num_msdu_desc = __cpu_to_le32(ar->htt.max_num_pending_tx);
+	config.ast_skid_limit = __cpu_to_le32(ar->skid_limit);
+
+	/* Firmware will crash if this is not even multiple of 8 */
+	if (WARN_ON(ar->htt.max_num_pending_tx & 0x7)) {
+		ath10k_err(ar, "tx-descriptors must be multiple of 8: %d\n",
+			   ar->htt.max_num_pending_tx);
+	}
+
 	config.rx_chain_mask = __cpu_to_le32(TARGET_10X_RX_CHAIN_MASK);
 	config.rx_timeout_pri_vo = __cpu_to_le32(TARGET_10X_RX_TIMEOUT_LO_PRI);
 	config.rx_timeout_pri_vi = __cpu_to_le32(TARGET_10X_RX_TIMEOUT_LO_PRI);
 	config.rx_timeout_pri_be = __cpu_to_le32(TARGET_10X_RX_TIMEOUT_LO_PRI);
 	config.rx_timeout_pri_bk = __cpu_to_le32(TARGET_10X_RX_TIMEOUT_HI_PRI);
-	config.rx_decap_mode = __cpu_to_le32(ar->wmi.rx_decap_mode);
 
 	config.scan_max_pending_reqs =
 		__cpu_to_le32(TARGET_10X_SCAN_MAX_PENDING_REQS);
 
-	config.bmiss_offload_max_vdev =
-		__cpu_to_le32(TARGET_10X_BMISS_OFFLOAD_MAX_VDEV);
-
-	config.roam_offload_max_vdev =
-		__cpu_to_le32(TARGET_10X_ROAM_OFFLOAD_MAX_VDEV);
-
-	config.roam_offload_max_ap_profiles =
-		__cpu_to_le32(TARGET_10X_ROAM_OFFLOAD_MAX_AP_PROFILES);
-
 	config.num_mcast_groups = __cpu_to_le32(TARGET_10X_NUM_MCAST_GROUPS);
 	config.num_mcast_table_elems =
 		__cpu_to_le32(TARGET_10X_NUM_MCAST_TABLE_ELEMS);
@@ -6634,7 +7458,6 @@
 
 	config.vow_config = __cpu_to_le32(TARGET_10X_VOW_CONFIG);
 
-	config.num_msdu_desc = __cpu_to_le32(TARGET_10X_NUM_MSDU_DESC);
 	config.max_frag_entries = __cpu_to_le32(TARGET_10X_MAX_FRAG_ENTRIES);
 
 	len = sizeof(*cmd) +
@@ -6674,32 +7497,103 @@
 	struct wmi_resource_config_10_4 config = {};
 	u32 len;
 
+	config.rx_decap_mode = __cpu_to_le32(ar->wmi.rx_decap_mode);
+
 	config.num_vdevs = __cpu_to_le32(ar->max_num_vdevs);
 	config.num_peers = __cpu_to_le32(ar->max_num_peers);
+	ath10k_warn(ar, "10.4 wmi init: vdevs: %d  peers: %d  tid: %d\n",
+		    ar->max_num_vdevs, ar->max_num_peers, ar->num_tids);
+
+	config.tx_chain_mask  = __cpu_to_le32(ar->hw_params.tx_chain_mask);
+	config.rx_chain_mask  = __cpu_to_le32(ar->hw_params.rx_chain_mask);
+
+	config.roam_offload_max_vdev  =
+			__cpu_to_le32(TARGET_10_4_ROAM_OFFLOAD_MAX_VDEV);
+
+	config.roam_offload_max_ap_profiles =
+			__cpu_to_le32(TARGET_10_4_ROAM_OFFLOAD_MAX_PROFILES);
+	config.num_peer_keys  = __cpu_to_le32(TARGET_10_4_NUM_PEER_KEYS);
+	config.bmiss_offload_max_vdev = __cpu_to_le32(ar->bmiss_offload_max_vdev);
+	config.qwrap_config = __cpu_to_le32(TARGET_10_4_QWRAP_CONFIG);
+
+	if (test_bit(ATH10K_FW_FEATURE_WMI_10X_CT,
+		     ar->running_fw->fw_file.fw_features)) {
+#if 0
+		/* Enabling this kills performance, for whatever reason. */
+		skid_limit = TARGET_10X_AST_SKID_LIMIT_CT;
+#endif
+		if (test_bit(ATH10K_FW_FEATURE_CT_STA,
+			     ar->running_fw->fw_file.fw_features) &&
+		    ar->request_ct_sta) {
+			/* TODO-BEN:  Should this be NATIVE_WIFI mode, like we do for 10.1? */
+			config.rx_decap_mode = __cpu_to_le32(ATH10K_HW_TXRX_RAW |
+							     ATH10k_VDEV_CT_STA_MODE);
+			ath10k_info(ar, "using CT-STA mode\n");
+		}
+		else if (test_bit(ATH10K_FW_FEATURE_CT_RXSWCRYPT,
+				  ar->running_fw->fw_file.fw_features) &&
+			 ar->request_nohwcrypt) {
+			/* This will disable rx decryption in hardware, enable raw
+			 * rx mode, and native-wifi tx mode.  Requires 'CT' firmware.
+			 */
+			config.rx_decap_mode = __cpu_to_le32(ATH10K_HW_TXRX_RAW |
+							     ATH10k_USE_SW_RX_CRYPT);
+			ar->use_swcrypt = true;
+			ath10k_info(ar, "using rx swcrypt\n");
+		}
+		else if (ar->request_nohwcrypt) {
+			ath10k_err(ar, "nohwcrypt requested, but firmware does not support this feature.  Disabling swcrypt.\n");
+		}
+
+		if (test_bit(ATH10K_FW_FEATURE_TXRATE_CT,
+			     ar->running_fw->fw_file.fw_features)) {
+			config.rx_decap_mode |= __cpu_to_le32(ATH10k_USE_TXCOMPL_TXRATE | ATH10k_MGT_CHAIN_RSSI_OK);
+			/* Must enable alloc_frag_desc_for_data_pkt for txrate support.  This eats up
+			 * 4 extra bytes per msdu descriptor.
+			 */
+			config.qwrap_config = __cpu_to_le32(1 << 16 | TARGET_10_4_QWRAP_CONFIG);
+		}
+
+		if (test_bit(ATH10K_FW_FEATURE_TXRATE2_CT,
+			     ar->running_fw->fw_file.fw_features))
+			config.rx_decap_mode |= __cpu_to_le32(ATH10k_USE_TXCOMPL_TXRATE2);
+
+		/* Disable WoW in firmware, could make this module option perhaps? */
+		config.rx_decap_mode |= __cpu_to_le32(ATH10k_DISABLE_WOW);
+
+		config.roam_offload_max_vdev = 0; /* disable roaming */
+		config.roam_offload_max_ap_profiles = 0; /* disable roaming */
+		/* 3 per peer is likely enough, but technically, there is room for 4
+		 * The default is 2 per peer, but that is not enough when testing
+		 * lots of station vdevs with encryption since each 'real' peer can
+		 * have 4 keys, and the self-peer has one key.
+		 */
+		config.num_peer_keys = __cpu_to_le32(3);
+
+		if (ar->num_ratectrl_objs) {
+			ath10k_info(ar, "using %d firmware rate-ctrl objects\n",
+				    ar->num_ratectrl_objs);
+			config.tx_chain_mask |= __cpu_to_le32(ar->num_ratectrl_objs << 24);
+		}
+	}
+	config.num_msdu_desc = __cpu_to_le32(ar->htt.max_num_pending_tx);
+	ath10k_warn(ar, "msdu-desc: %d  skid: %d\n",
+		    ar->htt.max_num_pending_tx, ar->skid_limit);
+	config.ast_skid_limit = __cpu_to_le32(ar->skid_limit);
+
 	config.num_active_peers = __cpu_to_le32(ar->num_active_peers);
 	config.num_tids = __cpu_to_le32(ar->num_tids);
 
 	config.num_offload_peers = __cpu_to_le32(TARGET_10_4_NUM_OFFLOAD_PEERS);
 	config.num_offload_reorder_buffs =
 			__cpu_to_le32(TARGET_10_4_NUM_OFFLOAD_REORDER_BUFFS);
-	config.num_peer_keys  = __cpu_to_le32(TARGET_10_4_NUM_PEER_KEYS);
-	config.ast_skid_limit = __cpu_to_le32(TARGET_10_4_AST_SKID_LIMIT);
-	config.tx_chain_mask  = __cpu_to_le32(ar->hw_params.tx_chain_mask);
-	config.rx_chain_mask  = __cpu_to_le32(ar->hw_params.rx_chain_mask);
 
 	config.rx_timeout_pri[0] = __cpu_to_le32(TARGET_10_4_RX_TIMEOUT_LO_PRI);
 	config.rx_timeout_pri[1] = __cpu_to_le32(TARGET_10_4_RX_TIMEOUT_LO_PRI);
 	config.rx_timeout_pri[2] = __cpu_to_le32(TARGET_10_4_RX_TIMEOUT_LO_PRI);
 	config.rx_timeout_pri[3] = __cpu_to_le32(TARGET_10_4_RX_TIMEOUT_HI_PRI);
 
-	config.rx_decap_mode	    = __cpu_to_le32(ar->wmi.rx_decap_mode);
 	config.scan_max_pending_req = __cpu_to_le32(TARGET_10_4_SCAN_MAX_REQS);
-	config.bmiss_offload_max_vdev =
-			__cpu_to_le32(TARGET_10_4_BMISS_OFFLOAD_MAX_VDEV);
-	config.roam_offload_max_vdev  =
-			__cpu_to_le32(TARGET_10_4_ROAM_OFFLOAD_MAX_VDEV);
-	config.roam_offload_max_ap_profiles =
-			__cpu_to_le32(TARGET_10_4_ROAM_OFFLOAD_MAX_PROFILES);
 	config.num_mcast_groups = __cpu_to_le32(TARGET_10_4_NUM_MCAST_GROUPS);
 	config.num_mcast_table_elems =
 			__cpu_to_le32(TARGET_10_4_NUM_MCAST_TABLE_ELEMS);
@@ -6716,7 +7610,6 @@
 	config.vow_config = __cpu_to_le32(TARGET_10_4_VOW_CONFIG);
 	config.gtk_offload_max_vdev =
 			__cpu_to_le32(TARGET_10_4_GTK_OFFLOAD_MAX_VDEV);
-	config.num_msdu_desc = __cpu_to_le32(ar->htt.max_num_pending_tx);
 	config.max_frag_entries = __cpu_to_le32(TARGET_10_4_11AC_TX_MAX_FRAGS);
 	config.max_peer_ext_stats =
 			__cpu_to_le32(TARGET_10_4_MAX_PEER_EXT_STATS);
@@ -6732,7 +7625,6 @@
 			__cpu_to_le32(TARGET_10_4_THERMAL_THROTTLING_CONFIG);
 	config.atf_config = __cpu_to_le32(TARGET_10_4_ATF_CONFIG);
 	config.iphdr_pad_config = __cpu_to_le32(TARGET_10_4_IPHDR_PAD_CONFIG);
-	config.qwrap_config = __cpu_to_le32(TARGET_10_4_QWRAP_CONFIG);
 
 	len = sizeof(*cmd) +
 	      (sizeof(struct host_memory_chunk) * ar->wmi.num_mem_chunks);
@@ -7089,17 +7981,56 @@
 		memcpy(cmd->ssid.ssid, arg->ssid, arg->ssid_len);
 	}
 
-	ath10k_wmi_put_wmi_channel(&cmd->chan, &arg->channel);
+	ath10k_wmi_put_wmi_channel(ar, &cmd->chan, &arg->channel, arg->vdev_id);
 
 	ath10k_dbg(ar, ATH10K_DBG_WMI,
-		   "wmi vdev %s id 0x%x flags: 0x%0X, freq %d, mode %d, ch_flags: 0x%0X, max_power: %d\n",
+		   "wmi vdev %s id 0x%x flags: 0x%0X, freq %d, mode %d, ch_flags: 0x%0X, max_power: %d bcn-intval: %d\n",
 		   cmdname, arg->vdev_id,
 		   flags, arg->channel.freq, arg->channel.mode,
-		   cmd->chan.flags, arg->channel.max_power);
+		   cmd->chan.flags, arg->channel.max_power, arg->bcn_intval);
 
 	return skb;
 }
 
+#ifdef CONFIG_ATH10K_DEBUGFS
+/* TODO:  Should really enable this all the time, not just when DEBUGFS is enabled. --Ben */
+/* CT firmware only:
+ * (re) start wmi keep-alive timer in firmware.  Once we start
+ * sending these, firmware will assert if it does not receive one
+ * after about 10 seconds.
+ */
+
+struct wmi_request_nop_cmd {
+	u32 nop_id; /* for debugging purposes */
+};
+
+int ath10k_wmi_request_nop(struct ath10k *ar)
+{
+	struct wmi_request_nop_cmd *cmd;
+	struct sk_buff *skb;
+
+	if (! test_bit(ATH10K_FW_FEATURE_NOP_CT,
+		       ar->running_fw->fw_file.fw_features))
+		return 0;
+
+	skb = ath10k_wmi_alloc_skb(ar, sizeof(*cmd));
+	if (!skb)
+		return -ENOMEM;
+
+	cmd = (struct wmi_request_nop_cmd *)skb->data;
+	cmd->nop_id = __cpu_to_le32(ar->debug.nop_id++);
+
+	/* This is fairly verbose in the logs when WMI debugging is enabled,
+	 * so only print this out every 100 times. --Ben
+	 */
+	if ((ar->debug.nop_id % 100) == 0)
+		ath10k_dbg(ar, ATH10K_DBG_WMI, "wmi request nop (id %d)\n",
+			   ar->debug.nop_id - 1);
+
+	return ath10k_wmi_cmd_send(ar, skb, WMI_NOP);
+}
+#endif
+
 static struct sk_buff *
 ath10k_wmi_op_gen_vdev_stop(struct ath10k *ar, u32 vdev_id)
 {
@@ -7217,8 +8148,9 @@
 		memcpy(cmd->key_data, arg->key_data, arg->key_len);
 
 	ath10k_dbg(ar, ATH10K_DBG_WMI,
-		   "wmi vdev install key idx %d cipher %d len %d\n",
-		   arg->key_idx, arg->key_cipher, arg->key_len);
+		   "wmi vdev %d install key peer %pM idx %d cipher %d len %d flags 0x%x\n",
+		   arg->vdev_id, arg->macaddr, arg->key_idx, arg->key_cipher, arg->key_len,
+		   arg->key_flags);
 	return skb;
 }
 
@@ -7314,6 +8246,12 @@
 	cmd->vdev_id = __cpu_to_le32(vdev_id);
 	ether_addr_copy(cmd->peer_macaddr.addr, peer_addr);
 
+	/* Steal a high bit.  Stock firmware should ignore it,
+	 * CT 10.1 (at least) firmware built after Nov 29 will
+	 * pay attention and flush if requested.
+	 */
+	cmd->peer_macaddr.word1 |= __cpu_to_le32(0x80000000);
+
 	ath10k_dbg(ar, ATH10K_DBG_WMI,
 		   "wmi peer delete vdev_id %d peer_addr %pM\n",
 		   vdev_id, peer_addr);
@@ -7461,7 +8399,7 @@
 		ch = &arg->channels[i];
 		ci = &cmd->chan_info[i];
 
-		ath10k_wmi_put_wmi_channel(ci, ch);
+		ath10k_wmi_put_wmi_channel(ar, ci, ch, -1);
 	}
 
 	return skb;
@@ -7472,8 +8410,53 @@
 			   const struct wmi_peer_assoc_complete_arg *arg)
 {
 	struct wmi_common_peer_assoc_complete_cmd *cmd = buf;
+	u32 vid = arg->vdev_id;
+	u32 ext_flags = 0;
 
-	cmd->vdev_id            = __cpu_to_le32(arg->vdev_id);
+	if (test_bit(ATH10K_FW_FEATURE_CT_RATEMASK,
+		     ar->running_fw->fw_file.fw_features)) {
+		/* Add some CT firmware specific stuff */
+		vid |= (1<<31); /* ext field exists */
+		if (arg->has_rate_overrides) {
+			int i;
+			int opver = ar->running_fw->fw_file.wmi_op_version;
+			ext_flags |= PEER_ASSOC_EXT_USE_OVERRIDES;
+			if (ar->fwcfg.allow_all_mcs)
+				ext_flags |= PEER_ASSOC_EXT_IGNORE_MCS_4_NSS_MASK;
+			ext_flags |= PEER_ASSOC_EXT_LEN_32;
+
+			ath10k_dbg(ar, ATH10K_DBG_WMI,
+				   "overrides: len %d\n", (int)(sizeof(arg->rate_overrides)));
+			for (i = 0; i<sizeof(arg->rate_overrides); i++) {
+				ath10k_dbg(ar, ATH10K_DBG_WMI, "[%i] 0x%x\n",
+					   i, arg->rate_overrides[i]);
+			}
+			if (opver == ATH10K_FW_WMI_OP_VERSION_10_4) {
+				struct wmi_10_4_peer_assoc_complete_cmd_ct *c = (void*)cmd;
+				memcpy(c->overrides.rate_overrides, arg->rate_overrides,
+				       sizeof(c->overrides.rate_overrides));
+				c->overrides.ext_flags = __cpu_to_le32(ext_flags);
+			}
+			else if ((opver == ATH10K_FW_WMI_OP_VERSION_10_2) ||
+				 (opver == ATH10K_FW_WMI_OP_VERSION_10_2_4)) {
+				struct wmi_10_2_peer_assoc_complete_cmd_ct *c = (void*)cmd;
+				memcpy(c->overrides.rate_overrides, arg->rate_overrides,
+				       sizeof(c->overrides.rate_overrides));
+				c->overrides.ext_flags = __cpu_to_le32(ext_flags);
+			}
+			else if (opver == ATH10K_FW_WMI_OP_VERSION_10_1) {
+				struct wmi_10_1_peer_assoc_complete_cmd_ct *c = (void*)cmd;
+				memcpy(c->overrides.rate_overrides, arg->rate_overrides,
+				       sizeof(c->overrides.rate_overrides));
+				c->overrides.ext_flags = __cpu_to_le32(ext_flags);
+			}
+			else {
+				WARN_ON_ONCE(1);
+			}
+		}
+	}
+
+	cmd->vdev_id            = __cpu_to_le32(vid);
 	cmd->peer_new_assoc     = __cpu_to_le32(arg->peer_reassoc ? 0 : 1);
 	cmd->peer_associd       = __cpu_to_le32(arg->peer_aid);
 	cmd->peer_flags         = __cpu_to_le32(arg->peer_flags);
@@ -7552,12 +8535,8 @@
 	struct wmi_10_4_peer_assoc_complete_cmd *cmd = buf;
 
 	ath10k_wmi_peer_assoc_fill_10_2(ar, buf, arg);
-	if (arg->peer_bw_rxnss_override)
-		cmd->peer_bw_rxnss_override =
-			__cpu_to_le32((arg->peer_bw_rxnss_override - 1) |
-				      BIT(PEER_BW_RXNSS_OVERRIDE_OFFSET));
-	else
-		cmd->peer_bw_rxnss_override = 0;
+
+	cmd->peer_bw_rxnss_override = __cpu_to_le32(arg->peer_bw_rxnss_override);
 }
 
 static int
@@ -7602,7 +8581,7 @@
 ath10k_wmi_10_1_op_gen_peer_assoc(struct ath10k *ar,
 				  const struct wmi_peer_assoc_complete_arg *arg)
 {
-	size_t len = sizeof(struct wmi_10_1_peer_assoc_complete_cmd);
+	size_t len = sizeof(struct wmi_10_1_peer_assoc_complete_cmd_ct);
 	struct sk_buff *skb;
 	int ret;
 
@@ -7617,9 +8596,10 @@
 	ath10k_wmi_peer_assoc_fill_10_1(ar, skb->data, arg);
 
 	ath10k_dbg(ar, ATH10K_DBG_WMI,
-		   "wmi peer assoc vdev %d addr %pM (%s)\n",
+		   "wmi peer assoc vdev %d addr %pM (%s) flags 0x%x\n",
 		   arg->vdev_id, arg->addr,
-		   arg->peer_reassoc ? "reassociate" : "new");
+		   arg->peer_reassoc ? "reassociate" : "new",
+		   arg->peer_flags);
 	return skb;
 }
 
@@ -7627,7 +8607,7 @@
 ath10k_wmi_10_2_op_gen_peer_assoc(struct ath10k *ar,
 				  const struct wmi_peer_assoc_complete_arg *arg)
 {
-	size_t len = sizeof(struct wmi_10_2_peer_assoc_complete_cmd);
+	size_t len = sizeof(struct wmi_10_2_peer_assoc_complete_cmd_ct);
 	struct sk_buff *skb;
 	int ret;
 
@@ -7652,7 +8632,7 @@
 ath10k_wmi_10_4_op_gen_peer_assoc(struct ath10k *ar,
 				  const struct wmi_peer_assoc_complete_arg *arg)
 {
-	size_t len = sizeof(struct wmi_10_4_peer_assoc_complete_cmd);
+	size_t len = sizeof(struct wmi_10_4_peer_assoc_complete_cmd_ct);
 	struct sk_buff *skb;
 	int ret;
 
@@ -7674,6 +8654,29 @@
 }
 
 static struct sk_buff *
+ath10k_wmi_10_1_op_gen_pdev_get_temperature(struct ath10k *ar)
+{
+	struct sk_buff *skb;
+
+	if (!test_bit(ATH10K_FW_FEATURE_HAS_GET_TEMP_CT,
+		      ar->running_fw->fw_file.fw_features)) {
+		return ERR_PTR(-ENOTSUPP);
+	}
+
+	skb = ath10k_wmi_alloc_skb(ar, 0);
+	if (!skb)
+		return ERR_PTR(-ENOMEM);
+
+	/* This can be fairly verbose in the logs when WMI debugging is enabled,
+	 * so only print this out every 100 times. --Ben
+	 */
+	if ((ar->wmi_get_temp_count++ % 100) == 0)
+		ath10k_dbg(ar, ATH10K_DBG_WMI, "wmi pdev get temperature (count: %d)\n",
+			   ar->wmi_get_temp_count);
+	return skb;
+}
+
+static struct sk_buff *
 ath10k_wmi_10_2_op_gen_pdev_get_temperature(struct ath10k *ar)
 {
 	struct sk_buff *skb;
@@ -7682,7 +8685,12 @@
 	if (!skb)
 		return ERR_PTR(-ENOMEM);
 
-	ath10k_dbg(ar, ATH10K_DBG_WMI, "wmi pdev get temperature\n");
+	/* This can be fairly verbose in the logs when WMI debugging is enabled,
+	 * so only print this out every 100 times. --Ben
+	 */
+	if ((ar->wmi_get_temp_count++ % 100) == 0)
+		ath10k_dbg(ar, ATH10K_DBG_WMI, "wmi pdev get temperature (count: %d)\n",
+			   ar->wmi_get_temp_count);
 	return skb;
 }
 
@@ -7715,6 +8723,7 @@
 	struct wmi_bcn_tx_ref_cmd *cmd;
 	struct sk_buff *skb;
 	struct ieee80211_hdr *hdr;
+	u32 ppdu_info = 0;
 	u16 fc;
 
 	skb = ath10k_wmi_alloc_skb(ar, sizeof(*cmd));
@@ -7724,9 +8733,33 @@
 	hdr = (struct ieee80211_hdr *)bcn;
 	fc = le16_to_cpu(hdr->frame_control);
 
+	if (test_bit(ATH10K_FW_FEATURE_HAS_BCN_RC_CT,
+		     ar->running_fw->fw_file.fw_features)) {
+#if 0
+		/* Left as an exercise to the user:  If you want to TX beacons at different
+		 * rates, power, etc.  Then adjust these variables below accordingly.
+		 * --Ben
+		 */
+		u8 tpc = 0xFF; /* ff means don't set */
+		u8 sgi = 0;
+		u8 mcs = 3; // 6Mbps (if ofdm)
+		u8 nss = 0;
+		u8 pream_type = 0; /* ofdm */
+		u8 num_retries = 0; /* no ack */
+		u8 dyn_bw = 0;
+		u8 bw = 0;
+
+		tpc = 1; /* BEN:  Not sure this currently has an effect. */
+		pream_type = 2; /* HT */
+		mcs = 4; /* 54Mbps, if ofdm, 39Mbps if HT, for test purposes */
+
+		ppdu_info = ath10k_convert_hw_rate_to_rate_info(tpc, mcs, sgi, nss, pream_type, num_retries, bw, dyn_bw);
+#endif
+	}
+
 	cmd = (struct wmi_bcn_tx_ref_cmd *)skb->data;
-	cmd->vdev_id = __cpu_to_le32(vdev_id);
-	cmd->data_len = __cpu_to_le32(bcn_len);
+	cmd->vdev_id = __cpu_to_le32(vdev_id | (ppdu_info << 8));
+	cmd->data_len = __cpu_to_le32(bcn_len | (ppdu_info & 0xFF000000));
 	cmd->data_ptr = __cpu_to_le32(bcn_paddr);
 	cmd->msdu_id = 0;
 	cmd->frame_control = __cpu_to_le32(fc);
@@ -7775,7 +8808,7 @@
 }
 
 static struct sk_buff *
-ath10k_wmi_op_gen_request_stats(struct ath10k *ar, u32 stats_mask)
+ath10k_wmi_op_gen_request_stats(struct ath10k *ar, u32 stats_mask, u32 specifier)
 {
 	struct wmi_request_stats_cmd *cmd;
 	struct sk_buff *skb;
@@ -7786,6 +8819,7 @@
 
 	cmd = (struct wmi_request_stats_cmd *)skb->data;
 	cmd->stats_id = __cpu_to_le32(stats_mask);
+	cmd->vdev_id = __cpu_to_le32(specifier);
 
 	ath10k_dbg(ar, ATH10K_DBG_WMI, "wmi request stats 0x%08x\n",
 		   stats_mask);
@@ -8303,6 +9337,9 @@
 				"beacon rssi history", i,
 				vdev->beacon_rssi_history[i]);
 
+	len += scnprintf(buf + len, buf_len - len, "%30s %llu\n",
+			"tsf64", vdev->tsf64);
+
 	len += scnprintf(buf + len, buf_len - len, "\n");
 	*length = len;
 }
@@ -8325,6 +9362,8 @@
 	if (!extended_peer)
 		len += scnprintf(buf + len, buf_len - len, "%30s %llu\n",
 				"Peer RX duration", peer->rx_duration);
+	len += scnprintf(buf + len, buf_len - len, "%30s %llu\n",
+			 "Peer PN", peer->pn);
 
 	len += scnprintf(buf + len, buf_len - len, "\n");
 	*length = len;
@@ -8602,8 +9641,17 @@
 
 	ath10k_wmi_fw_pdev_rx_stats_fill(pdev, buf, &len);
 	len += scnprintf(buf + len, buf_len - len, "%30s %10d\n",
+			"Num Rx Timeout errors", pdev->rx_timeout_errs);
+	len += scnprintf(buf + len, buf_len - len, "%30s %10d\n",
 			"Num Rx Overflow errors", pdev->rx_ovfl_errs);
 
+	len += scnprintf(buf + len, buf_len - len, "%30s %10d\n",
+			 "DRAM Free", pdev->dram_free);
+	len += scnprintf(buf + len, buf_len - len, "%30s %10d\n",
+			 "IRAM Free", pdev->iram_free);
+	len += scnprintf(buf + len, buf_len - len, "%30s %10d\n",
+			 "SRAM Free", pdev->sram_free);
+
 	len += scnprintf(buf + len, buf_len - len, "\n");
 	len += scnprintf(buf + len, buf_len - len, "%30s (%zu)\n",
 			"ath10k VDEV stats", num_vdevs);
@@ -8869,7 +9917,7 @@
 
 	for (i = 0; i < cap->peer_chan_len; i++) {
 		chan = (struct wmi_channel *)&peer_cap->peer_chan_list[i];
-		ath10k_wmi_put_wmi_channel(chan, &chan_arg[i]);
+		ath10k_wmi_put_wmi_channel(ar, chan, &chan_arg[i], arg->vdev_id);
 	}
 
 	ath10k_dbg(ar, ATH10K_DBG_WMI,
@@ -8967,6 +10015,33 @@
 	return skb;
 }
 
+int ath10k_wmi_pdev_set_special(struct ath10k *ar, u32 id, u32 val)
+{
+	struct wmi_pdev_set_special_cmd *cmd;
+	struct sk_buff *skb;
+
+	if (!test_bit(ATH10K_FW_FEATURE_SET_SPECIAL_CT,
+		      ar->running_fw->fw_file.fw_features)) {
+		ath10k_warn(ar, "Only CT firmware supports this method of setting thresh62_ext.\n");
+		return -ENOTSUPP;
+	}
+
+	skb = ath10k_wmi_alloc_skb(ar, sizeof(*cmd));
+	if (!skb)
+		return -ENOMEM;
+
+	cmd = (struct wmi_pdev_set_special_cmd *)skb->data;
+	memset(cmd, 0, sizeof(*cmd));
+
+	cmd->id = __cpu_to_le32(id);
+	cmd->val = __cpu_to_le32(val);
+
+	ath10k_dbg(ar, ATH10K_DBG_WMI,
+		   "wmi pdev set special id:%d val: %d\n",
+		   id, val);
+	return ath10k_wmi_cmd_send(ar, skb, WMI_PDEV_SET_SPECIAL_CMDID);
+}
+
 static const struct wmi_ops wmi_ops = {
 	.rx = ath10k_wmi_op_rx,
 	.map_svc = wmi_main_svc_map,
@@ -9045,7 +10120,7 @@
 	.gen_pdev_set_rd = ath10k_wmi_10x_op_gen_pdev_set_rd,
 	.gen_start_scan = ath10k_wmi_10x_op_gen_start_scan,
 	.gen_peer_assoc = ath10k_wmi_10_1_op_gen_peer_assoc,
-	/* .gen_pdev_get_temperature not implemented */
+	.gen_pdev_get_temperature = ath10k_wmi_10_1_op_gen_pdev_get_temperature,
 
 	/* shared with main branch */
 	.pull_scan = ath10k_wmi_op_pull_scan_ev,
@@ -9103,7 +10178,14 @@
 	/* .gen_prb_tmpl not implemented */
 	/* .gen_p2p_go_bcn_ie not implemented */
 	/* .gen_adaptive_qcs not implemented */
-	/* .gen_pdev_enable_adaptive_cca not implemented */
+
+	/* Some CT 10.1 firmware supports this.  Non-CT 10.1 firmware will not
+	 * advertise WMI_SERVICE_BSS_CHANNEL_INFO_64, so it will never be called
+	 * in the first place.
+	 */
+	.gen_pdev_bss_chan_info_req = ath10k_wmi_10_2_op_gen_pdev_bss_chan_info,
+	.gen_pdev_get_tpc_config = ath10k_wmi_10_2_4_op_gen_pdev_get_tpc_config,
+	.gen_pdev_enable_adaptive_cca = ath10k_wmi_op_gen_pdev_enable_adaptive_cca, /* CT only for wave-1 */
 };
 
 static const struct wmi_ops wmi_10_2_ops = {
@@ -9252,6 +10334,7 @@
 	.rx = ath10k_wmi_10_4_op_rx,
 	.map_svc = wmi_10_4_svc_map,
 
+	.gen_peer_assoc = ath10k_wmi_10_4_op_gen_peer_assoc,
 	.pull_fw_stats = ath10k_wmi_10_4_op_pull_fw_stats,
 	.pull_scan = ath10k_wmi_op_pull_scan_ev,
 	.pull_mgmt_rx = ath10k_wmi_10_4_op_pull_mgmt_rx_ev,
@@ -9272,6 +10355,7 @@
 	.gen_pdev_set_base_macaddr = ath10k_wmi_op_gen_pdev_set_base_macaddr,
 	.gen_pdev_set_rd = ath10k_wmi_10x_op_gen_pdev_set_rd,
 	.gen_pdev_set_param = ath10k_wmi_op_gen_pdev_set_param,
+	.gen_pdev_set_fwtest = ath10k_wmi_op_gen_pdev_set_fwtest,
 	.gen_init = ath10k_wmi_10_4_op_gen_init,
 	.gen_start_scan = ath10k_wmi_op_gen_start_scan,
 	.gen_stop_scan = ath10k_wmi_op_gen_stop_scan,
@@ -9289,7 +10373,6 @@
 	.gen_peer_delete = ath10k_wmi_op_gen_peer_delete,
 	.gen_peer_flush = ath10k_wmi_op_gen_peer_flush,
 	.gen_peer_set_param = ath10k_wmi_op_gen_peer_set_param,
-	.gen_peer_assoc = ath10k_wmi_10_4_op_gen_peer_assoc,
 	.gen_set_psmode = ath10k_wmi_op_gen_set_psmode,
 	.gen_set_sta_ps = ath10k_wmi_op_gen_set_sta_ps,
 	.gen_set_ap_ps = ath10k_wmi_op_gen_set_ap_ps,
diff -Nur linux-5.4.39/drivers/net/wireless/ath/ath10k/wmi.h linux-5.4.39-ct/drivers/net/wireless/ath/ath10k/wmi.h
--- linux-5.4.39/drivers/net/wireless/ath/ath10k/wmi.h	2020-05-06 07:15:17.000000000 +0100
+++ linux-5.4.39-ct/drivers/net/wireless/ath/ath10k/wmi.h	2020-05-12 23:23:34.000000000 +0100
@@ -944,6 +944,7 @@
 	u32 sta_keepalive_cmd;
 	u32 echo_cmdid;
 	u32 pdev_utf_cmdid;
+	u32 pdev_consume_block_ack_cmdid;
 	u32 dbglog_cfg_cmdid;
 	u32 pdev_qvit_cmdid;
 	u32 pdev_ftm_intg_cmdid;
@@ -1334,13 +1335,13 @@
 	WMI_10X_PDEV_PKTLOG_ENABLE_CMDID,
 	WMI_10X_PDEV_PKTLOG_DISABLE_CMDID,
 	WMI_10X_PDEV_SET_WMM_PARAMS_CMDID,
-	WMI_10X_PDEV_SET_HT_CAP_IE_CMDID,
+	WMI_10X_PDEV_SET_HT_CAP_IE_CMDID, /* 10 */
 	WMI_10X_PDEV_SET_VHT_CAP_IE_CMDID,
 	WMI_10X_PDEV_SET_BASE_MACADDR_CMDID,
 	WMI_10X_PDEV_SET_DSCP_TID_MAP_CMDID,
 	WMI_10X_PDEV_SET_QUIET_MODE_CMDID,
 	WMI_10X_PDEV_GREEN_AP_PS_ENABLE_CMDID,
-	WMI_10X_PDEV_GET_TPC_CONFIG_CMDID,
+	WMI_10X_PDEV_GET_TPC_CONFIG_CMDID, /* 16 */
 
 	/* VDEV(virtual device) specific commands */
 	WMI_10X_VDEV_CREATE_CMDID,
@@ -1353,7 +1354,7 @@
 	WMI_10X_VDEV_STANDBY_RESPONSE_CMDID,
 	WMI_10X_VDEV_RESUME_RESPONSE_CMDID,
 	WMI_10X_VDEV_SET_PARAM_CMDID,
-	WMI_10X_VDEV_INSTALL_KEY_CMDID,
+	WMI_10X_VDEV_INSTALL_KEY_CMDID, /* 27 */
 
 	/* peer specific commands */
 	WMI_10X_PEER_CREATE_CMDID,
@@ -1363,7 +1364,7 @@
 	WMI_10X_PEER_ASSOC_CMDID,
 	WMI_10X_PEER_ADD_WDS_ENTRY_CMDID,
 	WMI_10X_PEER_REMOVE_WDS_ENTRY_CMDID,
-	WMI_10X_PEER_MCAST_GROUP_CMDID,
+	WMI_10X_PEER_MCAST_GROUP_CMDID, /* 35 */
 
 	/* beacon/management specific commands */
 
@@ -1371,7 +1372,7 @@
 	WMI_10X_BCN_PRB_TMPL_CMDID,
 	WMI_10X_BCN_FILTER_RX_CMDID,
 	WMI_10X_PRB_REQ_FILTER_RX_CMDID,
-	WMI_10X_MGMT_TX_CMDID,
+	WMI_10X_MGMT_TX_CMDID, /* 40 */
 
 	/* commands to directly control ba negotiation directly from host. */
 	WMI_10X_ADDBA_CLEAR_RESP_CMDID,
@@ -1457,6 +1458,56 @@
 	WMI_10X_GPIO_CONFIG_CMDID,
 	WMI_10X_GPIO_OUTPUT_CMDID,
 
+	/* CT Firmware only, trying to add new WMI features w/out breaking backwards compat. */
+	/* add new CMDIDs here (out-of-order backport from 10.2) */
+	/**update a wds  (4 address ) entry. */
+	WMI_10X_PEER_UPDATE_WDS_ENTRY_CMDID,
+	/** request to start/stop keep-alive frame */
+	WMI_10X_RTT_KEEPALIVE_CMDID,
+	WMI_10X_VDEV_RATEMASK_CMDID,
+
+	/** Enable/Disable Smart Antenna */
+	WMI_10X_PDEV_SMART_ANT_ENABLE_CMDID,
+	/** Set Smart Antenna RX antenna*/
+	WMI_10X_PDEV_SMART_ANT_SET_RX_ANTENNA_CMDID,
+	/** Set Smart Antenna TX antenna*/
+	WMI_10X_PEER_SMART_ANT_SET_TX_ANTENNA_CMDID,
+	/** Set Smart Antenna TX train info */
+	WMI_10X_PEER_SMART_ANT_SET_TRAIN_INFO_CMDID,
+	/** Set SA node config options */
+	WMI_10X_PEER_SMART_ANT_SET_NODE_CONFIG_OPS_CMDID,
+	/* For fw recovery test command */
+	WMI_10X_FORCE_FW_HANG_CMDID,
+
+	/** Override the antenna switch table */
+	WMI_10X_PDEV_SET_ANTENNA_SWITCH_TABLE_CMDID,
+	/** Override the CTL table */
+	WMI_10X_PDEV_SET_CTL_TABLE_CMDID,
+	/** Override the array gain table */
+	WMI_10X_PDEV_SET_MIMOGAIN_TABLE_CMDID,
+	/** Set/Get the rate power table in OTP */
+	WMI_10X_PDEV_RATEPWR_TABLE_CMDID,
+	/** En/disable the rate power and chain mask table in FW*/
+	WMI_10X_PDEV_RATEPWR_CHAINMSK_TABLE_CMDID,
+
+	WMI_10X_PDEV_GET_INFO,
+	WMI_10X_VDEV_GET_INFO,
+	/** ATF VDEV REQUEST commands. */
+	WMI_10X_VDEV_ATF_REQUEST_CMDID,
+	/** ATF PEER REQUEST commands. */
+	WMI_10X_PEER_ATF_REQUEST_CMDID,
+
+	/** Get Thermal management params **/
+	WMI_10X_PDEV_GET_TEMPERATURE_CMDID,
+	WMI_10X_MU_CAL_START_CMDID,
+	WMI_10X_SET_LTEU_CONFIG_CMDID,
+	WMI_10X_SET_CCA_PARAMS_CMDID,
+	WMI_10X_PDEV_BSS_CHAN_INFO_REQUEST,
+
+	WMI_PDEV_CONSUME_BLOCK_ACK_CMDID_CT = WMI_10X_END_CMDID - 102, /* CT Specific Command ID */
+	WMI_PDEV_SET_SPECIAL_CMDID = WMI_10X_END_CMDID - 101, /* CT only:  special hack (cts/slot/cifs/ack timers, etc) */
+	WMI_NOP = WMI_10X_END_CMDID - 100, /* CT only:  wmi transport keep-alive, basically */
+
 	WMI_10X_PDEV_UTF_CMDID = WMI_10X_END_CMDID - 1,
 };
 
@@ -1520,6 +1571,11 @@
 	WMI_10X_PDEV_TPC_CONFIG_EVENTID,
 
 	WMI_10X_GPIO_INPUT_EVENTID,
+
+	WMI_10_1_GENERIC_BUFFER_EVENTID = 36893, /* Newer CT firmware:  April 2, 2019 */
+	WMI_10_1_PDEV_TEMPERATURE_EVENTID = 36898, /* Newer CT firmware */
+	WMI_10_1_PDEV_BSS_CHAN_INFO_EVENTID = 36900, /* Newer CT firmware */
+	WMI_10_1_BEACON_TX_EVENTID = WMI_10X_END_EVENTID - 4, /* CT FW, beacon tx completed */
 	WMI_10X_PDEV_UTF_EVENTID = WMI_10X_END_EVENTID - 1,
 };
 
@@ -1867,6 +1923,7 @@
 	WMI_10_4_PDEV_SET_BRIDGE_MACADDR_CMDID,
 	WMI_10_4_ATF_GROUP_WMM_AC_CONFIG_REQUEST_CMDID,
 	WMI_10_4_RADAR_FOUND_CMDID,
+	WMI_10_4_PDEV_CONSUME_BLOCK_ACK_CMDID_CT = WMI_10_4_END_CMDID - 102, /* CT Specific Command ID */
 	WMI_10_4_PDEV_UTF_CMDID = WMI_10_4_END_CMDID - 1,
 };
 
@@ -1945,6 +2002,11 @@
 	WMI_10_4_HOST_SWFDA_EVENTID,
 	WMI_10_4_ESP_ESTIMATE_EVENTID,
 	WMI_10_4_DFS_STATUS_CHECK_EVENTID,
+
+
+	WMI_10_4_BEACON_TX_EVENTID = WMI_10_4_END_EVENTID - 4, /* CT FW, beacon tx completed */
+	WMI_10_4_TXBF_CV_MESG_EVENTID = WMI_10_4_END_EVENTID - 3, /* CT Specific event ID */
+	WMI_10_4_CSI_MESG_EVENTID = WMI_10_4_END_EVENTID - 2, /* CT Specific event ID */
 	WMI_10_4_PDEV_UTF_EVENTID = WMI_10_4_END_EVENTID - 1,
 };
 
@@ -2045,7 +2107,9 @@
 	union {
 		__le32 reginfo1;
 		struct {
+			/* note: power unit is 1 dBm */
 			u8 antenna_max;
+			/* note: power unit is 0.5 dBm */
 			u8 max_tx_power;
 		} __packed;
 	} __packed;
@@ -2065,6 +2129,7 @@
 	u32 min_power;
 	u32 max_power;
 	u32 max_reg_power;
+	/* note: power unit is 1 dBm */
 	u32 max_antenna_gain;
 	u32 reg_class_id;
 	enum wmi_phy_mode mode;
@@ -2082,6 +2147,13 @@
 #define WMI_CHAN_FLAG_DFS            (1 << 10)
 #define WMI_CHAN_FLAG_ALLOW_HT       (1 << 11)
 #define WMI_CHAN_FLAG_ALLOW_VHT      (1 << 12)
+#define WMI_CHAN_FLAG_HALF           (1 << 13)
+#define WMI_CHAN_FLAG_QUARTER        (1 << 14)
+#define WMI_CHAN_FLAG_NO_RESERVE_CH  (1 << 31) /* CT firmware only, do not reserve channel.
+						* Takes 200+ms to grab reservation when starting
+						* vdev, and I think it is handled elsewhere by the
+						* stack and/or supplicant anyway. --Ben
+						*/
 
 /* Indicate reason for channel switch */
 #define WMI_CHANNEL_CHANGE_CAUSE_CSA (1 << 13)
@@ -2377,7 +2449,12 @@
 	 *   tx with a reduced number of chains if no clients are associated.
 	 *   This configuration parameter specifies the nominal chain-mask that
 	 *   should be used when not operating with a reduced set of tx chains.
+	 *
+	 *  NOTE:  Stored as uint8 internally in firmware, so I am going to
+	 *  steal some high bits to allow configuring the number of RAM
+	 *  rate-ctrl objects for CT firmware. --Ben
 	 */
+	/* mask >> 24:  rate-ctrl-objs-in-RAM */
 	__le32 tx_chain_mask;
 
 	/*
@@ -2413,7 +2490,35 @@
 	 *   MAC can decap to RAW (no decap), native wifi or Ethernet types
 	 *   THis setting also determines the default TX behavior, however TX
 	 *   behavior can be modified on a per VAP basis during VAP init
-	 */
+	 *
+	 *  NOTE:  Stealing some of this field for flags, only usable when
+	 *         running "CT" firmware.
+	 *   first byte: rx_decap_mode
+	 *   second byte:  reserved
+	 */
+	#define ATH10K_RX_DECAP_MODE_MASK 0xff
+	/*  Use software rx crypt.  This disables rx checksumming
+	 *  and may turn off some firmware/hardware optimizations for
+	 *  normal use case.  BUT, it does allow us to run multiple
+	 *  stations connected to the same AP.  This flag causes
+	 *  rx encapsulation to be 'raw', and tx mode to be native-wifi.
+	 *  You should probably not enable this unless you need to
+	 *  connect multiple stations to same AP.
+	 */
+	#define ATH10k_USE_SW_RX_CRYPT    0x10000
+	/* Ask firmware to include tx-rate in completion messages. */
+	#define ATH10k_USE_TXCOMPL_TXRATE 0x20000
+	/* Disable Wake-on-Wireless logic.  Saves some RAM, for those
+	 * that do not need WoW.
+	 */
+	#define ATH10k_DISABLE_WOW        0x40000
+	/* Ask CT firmware to send back per-chain management frame RSSI info */
+	#define ATH10k_MGT_CHAIN_RSSI_OK  0x80000
+	#define ATH10k_VDEV_CT_STATS_OK  0x100000
+        #define ATH10k_VDEV_CT_STA_MODE  0x200000 /* Try to use keys a bit like proxy-sta so we can do hw-crypt
+						   * with many stations to same AP. */
+	#define ATH10k_USE_TXCOMPL_TXRATE2 0x400000 /* Ask firmware for more extended tx-status in completion msgs */
+	/* NOTE:  High 8 bits are spoken for, 'features' */
 	__le32 rx_decap_mode;
 
 	/* what is the maximum number of scan requests that can be queued */
@@ -3273,6 +3378,14 @@
  */
 #define WMI_SCAN_ADD_SPOOFED_MAC_IN_PROBE_REQ   0x1000
 
+/* CT Firmware only, v15 and higher */
+/* Don't advertise any HT support in scan req */
+#define WMI_SCAN_DISABLE_HT    0x40000000
+#define WMI_SCAN_DISABLE_HT_4  0x00400000 /* 10.4 stole the bits I was using in 10.1. --Ben */
+/* Don't advertise any VHT support in scan req */
+#define WMI_SCAN_DISABLE_VHT   0x80000000
+#define WMI_SCAN_DISABLE_VHT_4 0x00800000
+
 /* WMI_SCAN_CLASS_MASK must be the same value as IEEE80211_SCAN_CLASS_MASK */
 #define WMI_SCAN_CLASS_MASK 0xFF000000
 
@@ -3339,6 +3452,7 @@
 	WMI_SCAN_REASON_PREEMPTED,
 	WMI_SCAN_REASON_TIMEDOUT,
 	WMI_SCAN_REASON_INTERNAL_FAILURE,
+	WMI_SCAN_REASON_BUSY = 13, /* A_EBUSY, CT firmware at least. */
 	WMI_SCAN_REASON_MAX,
 };
 
@@ -4524,6 +4638,50 @@
 	__le32 dummy;
 } __packed;
 
+
+#define REG_DUMP_NONE         0
+#define MAC_FILTER_ADDR_L32   1
+#define MAC_FILTER_ADDR_U16   2
+#define DCU_SLOT_TIME         3
+#define PHY_BB_MODE_SELECT    4
+#define PCU_BSSID_L32         5
+#define PCU_BSSID_U16         6
+#define PCU_BSSID2_L32        7
+#define PCU_BSSID2_U16        8
+#define PCU_STA_ADDR_U16      9
+#define MAC_DMA_CFG          10
+#define MAC_DMA_TXCFG        11
+#define PCU_STA_ADDR_L32     12
+#define PCU_RXFILTER         13
+#define PHY_BB_GEN_CONTROLS  14
+#define DMA_IMR              15
+#define DMA_TXRX_IMR         16
+#define SW_POWERMODE         17
+#define SW_CHAINMASK         18 /* tx is high 16 bits, rx is low 16 bits */
+#define SW_OPMODE            19
+#define SW_RXFILTER          20
+#define SW_LONG_RETRIES      21 /* DATA packet retries */
+#define SW_SHORT_RETRIES     22 /* RTS packet retries */
+#define ADC_TEMP             23 /* ADC Temperature readings. */
+#define NF_CHAINS            24 /* noise floor for chains */
+
+
+#define DBG_REG_DUMP_COUNT       25 /* max number of registers we know about. */
+
+struct ath10k_reg_dump_pair {
+	__le32 reg_id;
+	__le32 reg_val;
+};
+
+struct ath10k_reg_dump {
+	__le16 count;
+	__le16 unused;
+	struct ath10k_reg_dump_pair regpair[DBG_REG_DUMP_COUNT + 20];
+};
+
+/* These values are a bitmap, but 10.1.x (at least) firmware will not properly
+ * handle multiple values OR'd together.
+ */
 enum wmi_stats_id {
 	WMI_STAT_PEER = BIT(0),
 	WMI_STAT_AP = BIT(1),
@@ -4531,6 +4689,28 @@
 	WMI_STAT_VDEV = BIT(3),
 	WMI_STAT_BCNFLT = BIT(4),
 	WMI_STAT_VDEV_RATE = BIT(5),
+	WMI_REQUEST_REGISTER_DUMP = BIT(7), /* 0x80, CT Firmware only, request register dump. */
+	WMI_REQUEST_STAT_CUSTOM = 0xF0000000, /* CT Firmware stats hack, in this case,
+					       * vdev-id is 'stats-id' for requests */
+};
+
+#define WMI_STAT_CUSTOM_RX_REORDER_STATS 0
+#define WMI_STAT_CUSTOM_PDEV_EXT_STATS   1
+
+struct ath10k_pdev_ext_stats_ct {
+	u32 count; /* how many u32 data items (after flags) do we have? */
+	u32 flags; /* (1<<0): 160Mhz supported */
+
+	u32 num_chains; /* FW is compiled for this many chains */
+
+	s32 chan_nf_0; /* noise floor for chain 0 */
+	s32 chan_nf_1; /* noise floor for chain 1 */
+	s32 chan_nf_2; /* noise floor for chain 2 */
+	s32 chan_nf_3; /* noise floor for chain 3 */
+	/* Not sure exactly why there are only 3 of these used, see ar6000PeriodicNfSaveNLoadCalExt80 */
+	s32 chan_nf_sec80_1; /* noise floor for chain 1? */
+	s32 chan_nf_sec80_2; /* noise floor for chain 2? */
+	s32 chan_nf_sec80_3; /* noise floor for chain 3? */
 };
 
 enum wmi_10_4_stats_id {
@@ -4549,6 +4729,72 @@
 	WMI_TLV_STAT_PEER_EXTD  = BIT(10),
 };
 
+/*
+ * Rx reorder statistics
+ * NB: all the fields must be defined in 4 octets size.
+ */
+struct ath10k_rx_reorder_stats {
+	/* Non QoS MPDUs received */
+	u32 deliver_non_qos; /* not set in wave-2 currently */
+	/* MPDUs received in-order */
+	u32 deliver_in_order;
+	/* Flush due to reorder timer expired */
+	u32 deliver_flush_timeout;
+	/* Flush due to move out of window */
+	u32 deliver_flush_oow;
+	/* Flush due to DELBA */
+	u32 deliver_flush_delba;
+	/* MPDUs dropped due to FCS error */
+	u32 fcs_error;
+	/* MPDUs dropped due to monitor mode non-data packet */
+	u32 mgmt_ctrl;
+	/* MPDUs dropped due to invalid peer */
+	u32 invalid_peer;
+	/* MPDUs dropped due to duplication (non aggregation) */
+	u32 dup_non_aggr;
+	/* MPDUs dropped due to processed before */
+	u32 dup_past;
+	/* MPDUs dropped due to duplicate in reorder queue */
+	u32 dup_in_reorder;
+	/* Reorder timeout happened */
+	u32 reorder_timeout;
+	/* invalid bar ssn */
+	u32 invalid_bar_ssn;
+	/* reorder reset due to bar ssn */
+	u32 ssn_reset;
+
+	/* Added by Ben */
+	u32 frag_invalid_peer;
+	u32 frag_fcs_error;
+	u32 frag_ok;
+	u32 frag_discards;
+
+	u32 rx_chatter;
+	u32 tkip_mic_error;
+	u32 tkip_decrypt_error;
+	u32 mpdu_length_error;
+	u32 non_frag_unicast_ok;
+
+	u32 rx_flush_ind; // Flushed these due to timeout, etc.
+	u32 rx_flush_ie_add; // Flushed these due to timeout, etc
+
+	/* Wave-2 specific */
+	u32 rx_mesh_wrong_dest;
+	u32 rx_mesh_filter_ra;
+	u32 rx_mesh_filter_fromds;
+	u32 rx_mesh_filter_tods;
+	u32 rx_mesh_filter_nods;
+	u32 rx_radar_fft_war;
+	u32 rx_drop_encrypt_required;
+	u32 rx_mpdu_tid_err;
+	u32 rx_ba_statemachine_err;
+	u32 rx_drop_replay;
+
+	u32 rx_non_data_drop_no_bufs; /* We had no htt buffer space to send non-data
+				       * packet descriptors, so frames were dropped.  Stock
+				       * FW just asserts in this case, btw. */
+};
+
 struct wlan_inst_rssi_args {
 	__le16 cfg_retry_count;
 	__le16 retry_count;
@@ -4557,7 +4803,7 @@
 struct wmi_request_stats_cmd {
 	__le32 stats_id;
 
-	__le32 vdev_id;
+	__le32 vdev_id; /* Or custom-stat identifier if stats_id == WMI_REQUEST_STAT_CUSTOM, CT FW only */
 
 	/* peer MAC address */
 	struct wmi_mac_addr peer_macaddr;
@@ -4586,7 +4832,7 @@
 	 * number of pdev stats event structures
 	 * (wmi_pdev_stats) 0 or 1
 	 */
-	__le32 num_pdev_stats;
+	__le32 num_pdev_stats; /* Or custom-stats-type of stats_id == WMI_REQUEST_STAT_CUSTOM */
 	/*
 	 * number of vdev stats event structures
 	 * (wmi_vdev_stats) 0 or max vdevs
@@ -4663,6 +4909,12 @@
 	__le32 iram_free;
 } __packed;
 
+struct wmi_pdev_stats_mem_10_4 {
+	__le32 iram_free;
+	__le32 dram_free;
+	__le32 sram_free;
+} __packed;
+
 struct wmi_10_2_pdev_stats {
 	struct wmi_pdev_stats_base base;
 	struct wmi_pdev_stats_tx tx;
@@ -4678,9 +4930,9 @@
 	struct wmi_pdev_stats_base base;
 	struct wmi_10_4_pdev_stats_tx tx;
 	struct wmi_pdev_stats_rx rx;
+	__le32 pdev_rx_timeout;
 	__le32 rx_ovfl_errs;
-	struct wmi_pdev_stats_mem mem;
-	__le32 sram_free_size;
+	struct wmi_pdev_stats_mem_10_4 mem;
 	struct wmi_pdev_stats_extra extra;
 } __packed;
 
@@ -4731,6 +4983,12 @@
 	__le32 peer_rx_rate;
 } __packed;
 
+struct wmi_10x_peer_stats_ct_ext {
+	struct wmi_peer_stats old;
+	__le32 peer_rx_rate;
+	__le32 rx_duration;
+} __packed;
+
 struct wmi_10_2_peer_stats {
 	struct wmi_peer_stats old;
 	__le32 peer_rx_rate;
@@ -5002,7 +5260,13 @@
 	__le32 key_idx;
 	__le32 key_flags;
 	__le32 key_cipher; /* %WMI_CIPHER_ */
-	struct wmi_key_seq_counter key_rsc_counter;
+	struct wmi_key_seq_counter key_rsc_counter; /* ignored unless WAPI by (most?) stock FW.  CT
+						     * firmware will set PN to this value if high bit of high
+						     * value is set to 0x1 (PN is 48-bits, so the actual PN set
+						     * will be just the lower 48 bits.
+						     * Wave-2 firmware only at this point, April 8 2019
+						     * build and later.
+						     */
 	struct wmi_key_seq_counter key_global_rsc_counter;
 	struct wmi_key_seq_counter key_tsc_counter;
 	u8 wpi_key_rsc_counter[16];
@@ -5047,6 +5311,8 @@
 	WMI_RATE_PREAMBLE_VHT,
 };
 
+extern const char* cck_speed_by_idx[4];
+
 #define ATH10K_HW_NSS(rate)		(1 + (((rate) >> 4) & 0x3))
 #define ATH10K_HW_PREAMBLE(rate)	(((rate) >> 6) & 0x3)
 #define ATH10K_HW_MCS_RATE(rate)	((rate) & 0xf)
@@ -5390,6 +5656,8 @@
 	WMI_10X_VDEV_PARAM_MCAST2UCAST_SET,
 	/* Enable/Disable RTS-CTS */
 	WMI_10X_VDEV_PARAM_ENABLE_RTSCTS,
+	/** Total number of HW retries */
+	WMI_10X_VDEV_PARAM_RC_NUM_RETRIES,
 
 	WMI_10X_VDEV_PARAM_AP_DETECT_OUT_OF_SYNC_SLEEPING_STA_TIME_SECS,
 
@@ -5945,6 +6213,69 @@
 	WMI_STA_PS_PARAM_UAPSD = 4,
 };
 
+
+enum {
+    WMI_BUFFER_TYPE_RATEPWR_TABLE,
+    WMI_BUFFER_TYPE_CTL_TABLE,
+};
+
+struct wmi_generic_buffer_event {
+	__le32 buf_type; /* See enum above */
+	__le32 frag_id;
+	__le32 more_frag;
+	__le32 buf_len;
+	__le32 buf_info[0];
+};
+
+/* This is returned when reading the CTL table */
+struct qca9880_power_ctrl {
+	/* Not sure this can be made public knowledge, so leaving opaque
+	 * for now. --Ben
+	 */
+	u8 data[72 + 72 + 144 + 144];
+};
+
+/* Used by: WMI_PDEV_SET_CTL_TABLE_CMDID */
+struct qca9880_set_ctl_table_cmd {
+	/** len of CTL info */
+	__le32 ctl_len; /* in bytes.  This may be ignored in firmware,
+			 * make sure ctl_info data is sizeof(qca9880_power_ctl) */
+	/** ctl array (len adjusted to  number of words) */
+	__le32 ctl_info[1]; /* data would be the qca9880_power_ctl table above */
+};
+
+/* Used by:   WMI_PDEV_SET_MIMOGAIN_TABLE_CMDID */
+struct qca9880_mimo_gain_table {
+	/******************************************************************************
+	 *Bit 7:0 len of array gain table
+	 *Bit 8   bypass multi chain gain or not
+	 ******************************************************************************/
+	__le32 mimogain_info;
+	/** array gain table(s) (len adjusted to  number of words) */
+	__le32 arraygain_tbl[0]; /* real length is based on 'len' above */
+};
+
+struct qc988xxEepromRateTbl {
+	/* Keep opaque, not sure this can be made public. */
+	__le32 data[99];
+};
+
+#define RATEPWR_TABLE_OPS_SET 0
+#define RATEPWR_TABLE_OPS_GET 1
+#define RATEPWR_TABLE_OPS_GET_CTL 2
+/* For 'get', only the 'op' is paid attention to.  The result comes
+ * back as a WMI message (qc98xxEepromRateTbl, or qca9880_power_ctrl for 'GET_CTL')
+ * For set, send the qc98xxEepromRateTbl in binary form.
+ */
+struct qca9880_pdev_ratepwr_table_cmd {
+	/** operation */
+	__le32 op; /* see GET/SET defines above */
+	/** len of ratepwr table */
+	__le32 ratepwr_len;
+	/** rate power table (len adjusted to number of words) */
+	__le32 ratepwr_tbl[1];
+};
+
 struct wmi_sta_powersave_param_cmd {
 	__le32 vdev_id;
 	__le32 param_id; /* %WMI_STA_PS_PARAM_ */
@@ -6078,6 +6409,19 @@
 	struct wmi_p2p_noa_info p2p_noa_info;
 } __packed;
 
+/* CT FW only */
+struct wmi_beacon_tx_event {
+	__le32 vdev_id;
+	__le32 tx_status;
+	u8 mpdus_tried;
+	u8 mpdus_failed;
+	u8 tx_rate_code;
+	u8 tx_rate_flags;
+	u8 tsFlags; /* WHAL_TXS_FLAG_TSF_TIME_FILTERED, etc */
+	u8 future8[3];
+	__le32 future[2];
+};
+
 struct wmi_host_swba_event {
 	__le32 vdev_map;
 	struct wmi_bcn_info bcn_info[0];
@@ -6267,10 +6611,22 @@
 	WMI_PEER_CHAN_WIDTH = 0x4,
 	WMI_PEER_NSS        = 0x5,
 	WMI_PEER_USE_4ADDR  = 0x6,
+	/** Enable extended peer stats */
+	WMI_PEER_EXT_STATS_ENABLE = 0x7,
+	/*Use FIXED Pwr */
 	WMI_PEER_USE_FIXED_PWR = 0x8,
+	/* Set peer fixed rate */
 	WMI_PEER_PARAM_FIXED_RATE = 0x9,
 	WMI_PEER_DEBUG      = 0xa,
+	/* peer NSS for VHT160 - Extended NSS support */
+	WMI_PEER_NSS_VHT160 = 0xb,
+	/* peer NSS for VHT160 - Extended NSS support */
+	WMI_PEER_NSS_VHT80_80 = 0xc,
 	WMI_PEER_PHYMODE    = 0xd,
+
+	/* Whitelist peer TIDs */
+	WMI_PEER_SET_MU_WHITELIST =0x10,
+
 	WMI_PEER_DUMMY_VAR  = 0xff, /* dummy parameter for STA PS workaround */
 };
 
@@ -6390,6 +6746,7 @@
 	WMI_10X_PEER_SPATIAL_MUX = 0x00200000,
 	WMI_10X_PEER_VHT = 0x02000000,
 	WMI_10X_PEER_80MHZ = 0x04000000,
+	WMI_10X_PEER_PMF    = 0x10000000,
 	WMI_10X_PEER_160MHZ = 0x20000000
 };
 
@@ -6437,6 +6794,8 @@
 
 struct wmi_common_peer_assoc_complete_cmd {
 	struct wmi_mac_addr peer_macaddr;
+#define WMI_ASSOC_FLG_EXT (1<<31) /* Extended info is defined, CT firmware ver 15+ only,
+				   * packed into vdev_id */
 	__le32 vdev_id;
 	__le32 peer_new_assoc; /* 1=assoc, 0=reassoc */
 	__le32 peer_associd; /* 16 LSBs */
@@ -6468,6 +6827,46 @@
 	struct wmi_common_peer_assoc_complete_cmd cmd;
 } __packed;
 
+struct wmi_ct_assoc_overrides {
+	/* CT firmware ver 15+ only */
+#define PEER_ASSOC_EXT_USE_OVERRIDES (1<<0)
+	/* wave-1 ath10k-ct firmware, at least, has logic to ignore certain rates.
+	 * setting this flag below will disable that logic and give host full control
+	 * of the rate-set to use.
+	 * Rates disabled in firmware are:
+	 * 2x2 11ac rate table does not include:
+	 *   MCS 1x1: 5, 6, 7, 8, 9
+	 *       2x2: 0, 1, 2
+         * 3x3 11ac rate table does not include:
+	 *   MCS 1x1: 3, 4, 5, 6, 7, 8, 9
+	 *       2x2: 0, 1, 5, 6, 7, 8, 9
+	 *       3x3: 0, 1, 2, 3
+	 * As of Jan 29, 2020, this flag is ignored on wave-2 ath10k-ct firmware
+	 */
+#define PEER_ASSOC_EXT_IGNORE_MCS_4_NSS_MASK (1<<1)
+#define PEER_ASSOC_EXT_LEN_32        (1<<2) /* Has 32-override bytes */
+	__le32 ext_flags;
+
+#define RATE_OVERRIDES_COUNT 32
+	/* Space for 256 rates.  If rate_overrides_set is 1,
+	 * any rate NOT specified in rate_overrides will be
+	 * disabled.
+	 */
+	u8 rate_overrides[RATE_OVERRIDES_COUNT];
+} __packed;
+
+struct wmi_10_1_peer_assoc_complete_cmd_ct {
+	struct wmi_10_1_peer_assoc_complete_cmd cmd;
+	struct wmi_ct_assoc_overrides overrides;
+} __packed;
+
+struct wmi_pdev_consume_block_ack {
+	__le32 vdev_id;
+	__le16 flags; /* currently unused, must be set to zero */
+	__le16 skb_len;
+	unsigned char skb_data[0]; /* skb contents are copied here, 200 bytes or less */
+};
+
 #define WMI_PEER_ASSOC_INFO0_MAX_MCS_IDX_LSB 0
 #define WMI_PEER_ASSOC_INFO0_MAX_MCS_IDX_MASK 0x0f
 #define WMI_PEER_ASSOC_INFO0_MAX_NSS_LSB 4
@@ -6480,11 +6879,28 @@
 
 #define PEER_BW_RXNSS_OVERRIDE_OFFSET  31
 
+struct wmi_10_2_peer_assoc_complete_cmd_ct {
+	struct wmi_10_2_peer_assoc_complete_cmd cmd;
+	struct wmi_ct_assoc_overrides overrides;
+} __packed;
+
 struct wmi_10_4_peer_assoc_complete_cmd {
 	struct wmi_10_2_peer_assoc_complete_cmd cmd;
 	__le32 peer_bw_rxnss_override;
 } __packed;
 
+struct wmi_10_4_peer_assoc_complete_cmd_ct {
+	struct wmi_10_4_peer_assoc_complete_cmd cmd;
+	struct wmi_ct_assoc_overrides overrides;
+} __packed;
+
+struct wmi_vdev_stats_ct {
+    u32 vdev_id;
+    u32 size; /* size in bytes of this struct */
+    u32 tsf_lo;
+    u32 tsf_hi;
+};
+
 struct wmi_peer_assoc_complete_arg {
 	u8 addr[ETH_ALEN];
 	u32 vdev_id;
@@ -6504,6 +6920,10 @@
 	enum wmi_phy_mode peer_phymode;
 	struct wmi_vht_rate_set_arg peer_vht_rates;
 	u32 peer_bw_rxnss_override;
+
+	/* CT firmware only (beta-15 and higher ) */
+	bool has_rate_overrides;
+	u8 rate_overrides[RATE_OVERRIDES_COUNT];
 };
 
 struct wmi_peer_add_wds_entry_cmd {
@@ -6551,6 +6971,22 @@
 	struct wmi_mac_addr peer_macaddr;
 } __packed;
 
+struct wmi_txbf_cv_event {
+	struct wmi_mac_addr peer_macaddr;
+	u16 vdev_id;
+	u16 cv_size;
+	u16 cv_record_idx;
+	u16 cv_record_size;
+	u8 pool_idx;
+	u8 cv_type;
+	u8 mu_mimo;
+	u8 Nc;
+	u8 BW;
+	u8 Nr;
+	u8 state;
+	u8 unused;
+} __packed;
+
 #define WMI_CHAN_INFO_FLAG_COMPLETE BIT(0)
 #define WMI_CHAN_INFO_FLAG_PRE_COMPLETE BIT(1)
 
@@ -6766,6 +7202,7 @@
 struct wmi_mgmt_rx_ev_arg {
 	__le32 channel;
 	__le32 snr;
+	u8 rssi_ctl[4];
 	__le32 rate;
 	__le32 phy_mode;
 	__le32 buf_len;
@@ -6804,6 +7241,7 @@
 
 struct wmi_peer_kick_ev_arg {
 	const u8 *mac_addr;
+	u16 unused_hi; /* top 16 bits of 47-32, used to pass info back to host by CT firmware */
 };
 
 struct wmi_swba_ev_arg {
@@ -6861,6 +7299,12 @@
 	const __le32 *service_map_ext;
 };
 
+struct ath10k_fw_dbglog_report {
+	__le32 dropped_count;
+	__le32 messages[];
+} __packed;
+
+
 struct wmi_rdy_ev_arg {
 	__le32 sw_version;
 	__le32 abi_version;
@@ -6894,6 +7338,95 @@
 	__le32 reserved;
 } __packed;
 
+/* CT firmware only, and only builds after June 26, 2015 */
+struct wmi_pdev_set_special_cmd {
+#define SET_SPECIAL_ID_ACK_CTS 0 /* set ack-cts-timeout register */
+#define SET_SPECIAL_ID_SLOT    1 /* set slot-duration register */
+#define SET_SPECIAL_ID_SIFS    2 /* set sifs-duration register */
+#define SET_SPECIAL_ID_THRESH62_EXT 3 /* set PHY_BB_EXT_CHAN_PWR_THR_1_THRESH62_EXT register field...
+				       * increasing this to 42 helps at least
+				       * one customer pass regulatory testing, for instance.  This is
+				       * same register/field as: PHY_BB_EXT_CHAN_PWR_THR_1_THR_CCA_EXT40
+				       * this is an 8-bit value.
+				       */
+#define SET_SPECIAL_ID_NOISE_FLR_THRESH 4 /* Set some CCA related values in the eeprom struct.  Over-rides existing values.
+					   * BE CAREFUL!  This could put your system out of spec.  It can also put it in
+					   * spec when the eeprom values are dodgy.
+                                           * See debug.c, ath10k_read_ct_special for details.
+                                           */
+#define SET_SPECIAL_ID_IBSS_AMSDU_OK    5 /* As far as I can tell, AR988X hardware is incapable of properly doing
+					   * IBSS  AMSDU frames.  It zeros out the BSSID, which causes the receiving
+					   * stack (Linux, at least) to drop the frame because of bssid-mismatch.
+					   * But, maybe someone has a received that can handle this one way or another
+					   * and wants the additional speed given by AMSDU.  So, use this setting to
+					   * allow AMSDU with IBSS:  val of 1 enables, val of 0 disables.
+					   */
+#define SET_SPECIAL_ID_MAX_TXPOWER      6 /* Set the maximum allowed tx-power.  This over-rules any other
+                                           * power settings.
+                                           */
+#define SET_SPECIAL_ID_RC_MAX_PER_THR   7 /* Set the 'g_rc_rate_max_per_thr' value.  Default is 50.  Higher may make
+                                           * the rate-ctrl logic work better in crouded RF environments.  Tune with
+                                           * care.  I'm not sure than anything above 100 is meaningful.
+                                           */
+#define SET_SPECIAL_ID_STA_TXBW_MASK    8 /* Set the bandwidths that station vdevs can transmit on:
+					   * 0:  all, 0x1: 20Mhz, 0x2 40Mhz, 0x4 80Mhz
+                                           */
+#define SET_SPECIAL_ID_PDEV_XRETRY_TH   9 /* Set the threshold for resetting phy due to failed retries, U16 */
+#define SET_SPECIAL_ID_RIFS_ENABLE    0xA /* Enable(1)/disable(0) RIFS.  Disabled by default. */
+#define SET_SPECIAL_ID_WMI_WD         0xB /* Set the watchdog trigger count, 0 means disable */
+#define SET_SPECIAL_ID_PSHACK         0xC /* flag 0x1:  ignore PS sleep message from STA
+                                           * flag 0x2:  mark mcast as 'data-is-buffered' regardless.
+                                           */
+#define SET_SPECIAL_ID_CSI            0xD /* 0 == disable, else enable reporting CSI data.  10.4 FW only at this time. */
+#define SET_SPECIAL_ID_BW_DISABLE_MASK 0xE /* 0x1 == disable 20Mhz, 0x2 == 40Mhz, 0x4 == 80Mhz, 0x8 == 160Mhz.  0x0 == default */
+#define SET_SPECIAL_ID_TXBF_CV_MSG     0xF /* 0x1 == enable, 0x0 == disable (default). */
+#define SET_SPECIAL_ID_RX_ALL_MGT     0x10 /* Pass all possible mgt frames up to the host
+                                            * 0x1 == enable, 0x0 == disable (default)
+                                            */
+#define SET_SPECIAL_ID_TX_HANG_COLD_RESET     0x11 /* Allow cold-reset in tx-hang recover code. */
+#define SET_SPECIAL_ID_DISABLE_IBSS_CCA       0x12 /* Disable special HWSCH CCA settings for IBSS. */
+#define SET_SPECIAL_ID_PEER_CT_ANTMASK        0x13 /* Set the 'ct' peer antenna mask. Value encodes the peer-id
+						    * (see 'peers' debugfs for peer id listing)
+						    * val = peer_id << 16 | ant-mask-value
+						    */
+#define SET_SPECIAL_ID_EEPROM_CFG_ADDR_A      0x14 /* Append an address to the configAddr in the eeprom.
+						    * The mode should normally be OR'd in to the address.
+						    */
+#define SET_SPECIAL_ID_EEPROM_CFG_ADDR_V      0x15 /* Append an value to the configAddr in the eeprom.  Multiple values may
+						    * be appended if the mode supports it.
+						    */
+#define SET_SPECIAL_ID_PEER_STATS_PN          0x16 /* Report PN in peer-stats object */
+
+/* Requires specially compiled firmware (-T option) to have any useful effect. */
+#define SET_SPECIAL_ID_RC_DBG         0x98 /* 0x1 == enable, 0x0 == disable (default). */
+
+/* Requires specially compiled firmware (-T option) to have any useful effect. */
+#define SET_SPECIAL_ID_TX_DBG         0x99 /* 0x1 == enable, 0x2 == pkt-dbg, 0x0 == disable (default). */
+
+#define CT_CCA_TYPE_MIN0 0
+#define CT_CCA_TYPE_MIN1 1
+#define CT_CCA_TYPE_MIN2 2
+#define CT_CCA_TYPE_NOISE_FLOOR 3
+#define CT_CCA_TYPE_EN_MINCCAPWR 4
+#define CT_CCA_TYPE_MAX 4 /* change as more types are added */
+
+    __le32 id;
+    __le32 val;
+    __le32 extra1;
+    __le32 extra2;
+};
+int ath10k_wmi_pdev_set_special(struct ath10k *ar, u32 id, u32 val);
+
+/* Back door pdev hack API for 10.4 firmware.
+ * Similar to CT firmware's set-special API it seems.
+ */
+struct wmi_fwtest_set_param_cmd {
+    /** parameter id   */
+    __le32 param_id;
+    /** parameter value */
+    __le32 param_value;
+};
+
 /* WOW structures */
 enum wmi_wow_wakeup_event {
 	WOW_BMISS_EVENT = 0,
@@ -7312,8 +7845,10 @@
 				      const struct wmi_start_scan_arg *arg);
 void ath10k_wmi_set_wmm_param(struct wmi_wmm_params *params,
 			      const struct wmi_wmm_params_arg *arg);
-void ath10k_wmi_put_wmi_channel(struct wmi_channel *ch,
-				const struct wmi_channel_arg *arg);
+void ath10k_wmi_put_wmi_channel(struct ath10k *ar,
+				struct wmi_channel *ch,
+				const struct wmi_channel_arg *arg,
+				u32 vdev_id);
 int ath10k_wmi_start_scan_verify(const struct wmi_start_scan_arg *arg);
 
 int ath10k_wmi_event_scan(struct ath10k *ar, struct sk_buff *skb);
@@ -7323,6 +7858,7 @@
 void ath10k_wmi_event_chan_info(struct ath10k *ar, struct sk_buff *skb);
 void ath10k_wmi_event_echo(struct ath10k *ar, struct sk_buff *skb);
 int ath10k_wmi_event_debug_mesg(struct ath10k *ar, struct sk_buff *skb);
+int ath10k_wmi_event_csi_mesg(struct ath10k *ar, struct sk_buff *skb);
 void ath10k_wmi_event_update_stats(struct ath10k *ar, struct sk_buff *skb);
 void ath10k_wmi_event_vdev_start_resp(struct ath10k *ar, struct sk_buff *skb);
 void ath10k_wmi_event_vdev_stopped(struct ath10k *ar, struct sk_buff *skb);
@@ -7381,5 +7917,19 @@
 void ath10k_wmi_tpc_config_get_rate_code(u8 *rate_code, u16 *pream_table,
 					 u32 num_tx_chain);
 void ath10k_wmi_event_tpc_final_table(struct ath10k *ar, struct sk_buff *skb);
+void ath10k_wmi_stop_scan_work(struct work_struct *work);
+int ath10k_wmi_consume_block_ack(struct ath10k *ar, struct ath10k_vif *arvif, struct sk_buff *skb);
+int ath10k_wmi_request_ratepwr_tbl(struct ath10k *ar);
+int ath10k_wmi_request_powerctl_tbl(struct ath10k *ar);
+int ath10k_wmi_set_power_ctrl_tbl(struct ath10k *ar, int len, u8 *data);
+int ath10k_wmi_check_apply_board_power_ctl_table(struct ath10k *ar);
+
+#ifdef CONFIG_ATH10K_DEBUGFS
+/* TODO:  Should really enable this all the time, not just when DEBUGFS is enabled. --Ben */
+/* CT Firmware only */
+int ath10k_wmi_request_nop(struct ath10k *ar);
+#else
+#warning Please enable ATH10K-DEBUGFS kernel option for optimal support for CT firmware.
+#endif
 
 #endif /* _WMI_H_ */
diff -Nur linux-5.4.39/net/wireless/core.c linux-5.4.39-ct/net/wireless/core.c
--- linux-5.4.39/net/wireless/core.c	2020-05-06 07:15:17.000000000 +0100
+++ linux-5.4.39-ct/net/wireless/core.c	2020-05-12 23:24:35.000000000 +0100
@@ -616,10 +616,11 @@
 			 * some drivers support that, possibly only with fixed
 			 * beacon intervals for IBSS.
 			 */
-			if (WARN_ON(types & BIT(NL80211_IFTYPE_ADHOC) &&
-				    c->beacon_int_min_gcd)) {
-				return -EINVAL;
-			}
+			// Give users more rope. -Ben
+			//if (WARN_ON(types & BIT(NL80211_IFTYPE_ADHOC) &&
+			//	    c->beacon_int_min_gcd)) {
+			//	return -EINVAL;
+			//}
 
 			cnt += c->limits[j].max;
 			/*
diff -Nur linux-5.4.39/net/wireless/core.c.orig linux-5.4.39-ct/net/wireless/core.c.orig
--- linux-5.4.39/net/wireless/core.c.orig	1970-01-01 01:00:00.000000000 +0100
+++ linux-5.4.39-ct/net/wireless/core.c.orig	2020-05-06 07:15:17.000000000 +0100
@@ -0,0 +1,1506 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * This is the linux wireless configuration interface.
+ *
+ * Copyright 2006-2010		Johannes Berg <johannes@sipsolutions.net>
+ * Copyright 2013-2014  Intel Mobile Communications GmbH
+ * Copyright 2015-2017	Intel Deutschland GmbH
+ * Copyright (C) 2018-2019 Intel Corporation
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+#include <linux/if.h>
+#include <linux/module.h>
+#include <linux/err.h>
+#include <linux/list.h>
+#include <linux/slab.h>
+#include <linux/nl80211.h>
+#include <linux/debugfs.h>
+#include <linux/notifier.h>
+#include <linux/device.h>
+#include <linux/etherdevice.h>
+#include <linux/rtnetlink.h>
+#include <linux/sched.h>
+#include <net/genetlink.h>
+#include <net/cfg80211.h>
+#include "nl80211.h"
+#include "core.h"
+#include "sysfs.h"
+#include "debugfs.h"
+#include "wext-compat.h"
+#include "rdev-ops.h"
+
+/* name for sysfs, %d is appended */
+#define PHY_NAME "phy"
+
+MODULE_AUTHOR("Johannes Berg");
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("wireless configuration support");
+MODULE_ALIAS_GENL_FAMILY(NL80211_GENL_NAME);
+
+/* RCU-protected (and RTNL for writers) */
+LIST_HEAD(cfg80211_rdev_list);
+int cfg80211_rdev_list_generation;
+
+/* for debugfs */
+static struct dentry *ieee80211_debugfs_dir;
+
+/* for the cleanup, scan and event works */
+struct workqueue_struct *cfg80211_wq;
+
+static bool cfg80211_disable_40mhz_24ghz;
+module_param(cfg80211_disable_40mhz_24ghz, bool, 0644);
+MODULE_PARM_DESC(cfg80211_disable_40mhz_24ghz,
+		 "Disable 40MHz support in the 2.4GHz band");
+
+struct cfg80211_registered_device *cfg80211_rdev_by_wiphy_idx(int wiphy_idx)
+{
+	struct cfg80211_registered_device *result = NULL, *rdev;
+
+	ASSERT_RTNL();
+
+	list_for_each_entry(rdev, &cfg80211_rdev_list, list) {
+		if (rdev->wiphy_idx == wiphy_idx) {
+			result = rdev;
+			break;
+		}
+	}
+
+	return result;
+}
+
+int get_wiphy_idx(struct wiphy *wiphy)
+{
+	struct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);
+
+	return rdev->wiphy_idx;
+}
+
+struct wiphy *wiphy_idx_to_wiphy(int wiphy_idx)
+{
+	struct cfg80211_registered_device *rdev;
+
+	ASSERT_RTNL();
+
+	rdev = cfg80211_rdev_by_wiphy_idx(wiphy_idx);
+	if (!rdev)
+		return NULL;
+	return &rdev->wiphy;
+}
+
+static int cfg80211_dev_check_name(struct cfg80211_registered_device *rdev,
+				   const char *newname)
+{
+	struct cfg80211_registered_device *rdev2;
+	int wiphy_idx, taken = -1, digits;
+
+	ASSERT_RTNL();
+
+	if (strlen(newname) > NL80211_WIPHY_NAME_MAXLEN)
+		return -EINVAL;
+
+	/* prohibit calling the thing phy%d when %d is not its number */
+	sscanf(newname, PHY_NAME "%d%n", &wiphy_idx, &taken);
+	if (taken == strlen(newname) && wiphy_idx != rdev->wiphy_idx) {
+		/* count number of places needed to print wiphy_idx */
+		digits = 1;
+		while (wiphy_idx /= 10)
+			digits++;
+		/*
+		 * deny the name if it is phy<idx> where <idx> is printed
+		 * without leading zeroes. taken == strlen(newname) here
+		 */
+		if (taken == strlen(PHY_NAME) + digits)
+			return -EINVAL;
+	}
+
+	/* Ensure another device does not already have this name. */
+	list_for_each_entry(rdev2, &cfg80211_rdev_list, list)
+		if (strcmp(newname, wiphy_name(&rdev2->wiphy)) == 0)
+			return -EINVAL;
+
+	return 0;
+}
+
+int cfg80211_dev_rename(struct cfg80211_registered_device *rdev,
+			char *newname)
+{
+	int result;
+
+	ASSERT_RTNL();
+
+	/* Ignore nop renames */
+	if (strcmp(newname, wiphy_name(&rdev->wiphy)) == 0)
+		return 0;
+
+	result = cfg80211_dev_check_name(rdev, newname);
+	if (result < 0)
+		return result;
+
+	result = device_rename(&rdev->wiphy.dev, newname);
+	if (result)
+		return result;
+
+	if (rdev->wiphy.debugfsdir)
+		debugfs_rename(rdev->wiphy.debugfsdir->d_parent,
+			       rdev->wiphy.debugfsdir,
+			       rdev->wiphy.debugfsdir->d_parent, newname);
+
+	nl80211_notify_wiphy(rdev, NL80211_CMD_NEW_WIPHY);
+
+	return 0;
+}
+
+int cfg80211_switch_netns(struct cfg80211_registered_device *rdev,
+			  struct net *net)
+{
+	struct wireless_dev *wdev;
+	int err = 0;
+
+	if (!(rdev->wiphy.flags & WIPHY_FLAG_NETNS_OK))
+		return -EOPNOTSUPP;
+
+	list_for_each_entry(wdev, &rdev->wiphy.wdev_list, list) {
+		if (!wdev->netdev)
+			continue;
+		wdev->netdev->features &= ~NETIF_F_NETNS_LOCAL;
+		err = dev_change_net_namespace(wdev->netdev, net, "wlan%d");
+		if (err)
+			break;
+		wdev->netdev->features |= NETIF_F_NETNS_LOCAL;
+	}
+
+	if (err) {
+		/* failed -- clean up to old netns */
+		net = wiphy_net(&rdev->wiphy);
+
+		list_for_each_entry_continue_reverse(wdev,
+						     &rdev->wiphy.wdev_list,
+						     list) {
+			if (!wdev->netdev)
+				continue;
+			wdev->netdev->features &= ~NETIF_F_NETNS_LOCAL;
+			err = dev_change_net_namespace(wdev->netdev, net,
+							"wlan%d");
+			WARN_ON(err);
+			wdev->netdev->features |= NETIF_F_NETNS_LOCAL;
+		}
+
+		return err;
+	}
+
+	list_for_each_entry(wdev, &rdev->wiphy.wdev_list, list) {
+		if (!wdev->netdev)
+			continue;
+		nl80211_notify_iface(rdev, wdev, NL80211_CMD_DEL_INTERFACE);
+	}
+	nl80211_notify_wiphy(rdev, NL80211_CMD_DEL_WIPHY);
+
+	wiphy_net_set(&rdev->wiphy, net);
+
+	err = device_rename(&rdev->wiphy.dev, dev_name(&rdev->wiphy.dev));
+	WARN_ON(err);
+
+	nl80211_notify_wiphy(rdev, NL80211_CMD_NEW_WIPHY);
+	list_for_each_entry(wdev, &rdev->wiphy.wdev_list, list) {
+		if (!wdev->netdev)
+			continue;
+		nl80211_notify_iface(rdev, wdev, NL80211_CMD_NEW_INTERFACE);
+	}
+
+	return 0;
+}
+
+static void cfg80211_rfkill_poll(struct rfkill *rfkill, void *data)
+{
+	struct cfg80211_registered_device *rdev = data;
+
+	rdev_rfkill_poll(rdev);
+}
+
+void cfg80211_stop_p2p_device(struct cfg80211_registered_device *rdev,
+			      struct wireless_dev *wdev)
+{
+	ASSERT_RTNL();
+
+	if (WARN_ON(wdev->iftype != NL80211_IFTYPE_P2P_DEVICE))
+		return;
+
+	if (!wdev_running(wdev))
+		return;
+
+	rdev_stop_p2p_device(rdev, wdev);
+	wdev->is_running = false;
+
+	rdev->opencount--;
+
+	if (rdev->scan_req && rdev->scan_req->wdev == wdev) {
+		if (WARN_ON(!rdev->scan_req->notified))
+			rdev->scan_req->info.aborted = true;
+		___cfg80211_scan_done(rdev, false);
+	}
+}
+
+void cfg80211_stop_nan(struct cfg80211_registered_device *rdev,
+		       struct wireless_dev *wdev)
+{
+	ASSERT_RTNL();
+
+	if (WARN_ON(wdev->iftype != NL80211_IFTYPE_NAN))
+		return;
+
+	if (!wdev_running(wdev))
+		return;
+
+	rdev_stop_nan(rdev, wdev);
+	wdev->is_running = false;
+
+	rdev->opencount--;
+}
+
+void cfg80211_shutdown_all_interfaces(struct wiphy *wiphy)
+{
+	struct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);
+	struct wireless_dev *wdev;
+
+	ASSERT_RTNL();
+
+	list_for_each_entry(wdev, &rdev->wiphy.wdev_list, list) {
+		if (wdev->netdev) {
+			dev_close(wdev->netdev);
+			continue;
+		}
+		/* otherwise, check iftype */
+		switch (wdev->iftype) {
+		case NL80211_IFTYPE_P2P_DEVICE:
+			cfg80211_stop_p2p_device(rdev, wdev);
+			break;
+		case NL80211_IFTYPE_NAN:
+			cfg80211_stop_nan(rdev, wdev);
+			break;
+		default:
+			break;
+		}
+	}
+}
+EXPORT_SYMBOL_GPL(cfg80211_shutdown_all_interfaces);
+
+static int cfg80211_rfkill_set_block(void *data, bool blocked)
+{
+	struct cfg80211_registered_device *rdev = data;
+
+	if (!blocked)
+		return 0;
+
+	rtnl_lock();
+	cfg80211_shutdown_all_interfaces(&rdev->wiphy);
+	rtnl_unlock();
+
+	return 0;
+}
+
+static void cfg80211_rfkill_block_work(struct work_struct *work)
+{
+	struct cfg80211_registered_device *rdev;
+
+	rdev = container_of(work, struct cfg80211_registered_device,
+			    rfkill_block);
+	cfg80211_rfkill_set_block(rdev, true);
+}
+
+static void cfg80211_event_work(struct work_struct *work)
+{
+	struct cfg80211_registered_device *rdev;
+
+	rdev = container_of(work, struct cfg80211_registered_device,
+			    event_work);
+
+	rtnl_lock();
+	cfg80211_process_rdev_events(rdev);
+	rtnl_unlock();
+}
+
+void cfg80211_destroy_ifaces(struct cfg80211_registered_device *rdev)
+{
+	struct wireless_dev *wdev, *tmp;
+
+	ASSERT_RTNL();
+
+	list_for_each_entry_safe(wdev, tmp, &rdev->wiphy.wdev_list, list) {
+		if (wdev->nl_owner_dead)
+			rdev_del_virtual_intf(rdev, wdev);
+	}
+}
+
+static void cfg80211_destroy_iface_wk(struct work_struct *work)
+{
+	struct cfg80211_registered_device *rdev;
+
+	rdev = container_of(work, struct cfg80211_registered_device,
+			    destroy_work);
+
+	rtnl_lock();
+	cfg80211_destroy_ifaces(rdev);
+	rtnl_unlock();
+}
+
+static void cfg80211_sched_scan_stop_wk(struct work_struct *work)
+{
+	struct cfg80211_registered_device *rdev;
+	struct cfg80211_sched_scan_request *req, *tmp;
+
+	rdev = container_of(work, struct cfg80211_registered_device,
+			   sched_scan_stop_wk);
+
+	rtnl_lock();
+	list_for_each_entry_safe(req, tmp, &rdev->sched_scan_req_list, list) {
+		if (req->nl_owner_dead)
+			cfg80211_stop_sched_scan_req(rdev, req, false);
+	}
+	rtnl_unlock();
+}
+
+static void cfg80211_propagate_radar_detect_wk(struct work_struct *work)
+{
+	struct cfg80211_registered_device *rdev;
+
+	rdev = container_of(work, struct cfg80211_registered_device,
+			    propagate_radar_detect_wk);
+
+	rtnl_lock();
+
+	regulatory_propagate_dfs_state(&rdev->wiphy, &rdev->radar_chandef,
+				       NL80211_DFS_UNAVAILABLE,
+				       NL80211_RADAR_DETECTED);
+
+	rtnl_unlock();
+}
+
+static void cfg80211_propagate_cac_done_wk(struct work_struct *work)
+{
+	struct cfg80211_registered_device *rdev;
+
+	rdev = container_of(work, struct cfg80211_registered_device,
+			    propagate_cac_done_wk);
+
+	rtnl_lock();
+
+	regulatory_propagate_dfs_state(&rdev->wiphy, &rdev->cac_done_chandef,
+				       NL80211_DFS_AVAILABLE,
+				       NL80211_RADAR_CAC_FINISHED);
+
+	rtnl_unlock();
+}
+
+/* exported functions */
+
+struct wiphy *wiphy_new_nm(const struct cfg80211_ops *ops, int sizeof_priv,
+			   const char *requested_name)
+{
+	static atomic_t wiphy_counter = ATOMIC_INIT(0);
+
+	struct cfg80211_registered_device *rdev;
+	int alloc_size;
+
+	WARN_ON(ops->add_key && (!ops->del_key || !ops->set_default_key));
+	WARN_ON(ops->auth && (!ops->assoc || !ops->deauth || !ops->disassoc));
+	WARN_ON(ops->connect && !ops->disconnect);
+	WARN_ON(ops->join_ibss && !ops->leave_ibss);
+	WARN_ON(ops->add_virtual_intf && !ops->del_virtual_intf);
+	WARN_ON(ops->add_station && !ops->del_station);
+	WARN_ON(ops->add_mpath && !ops->del_mpath);
+	WARN_ON(ops->join_mesh && !ops->leave_mesh);
+	WARN_ON(ops->start_p2p_device && !ops->stop_p2p_device);
+	WARN_ON(ops->start_ap && !ops->stop_ap);
+	WARN_ON(ops->join_ocb && !ops->leave_ocb);
+	WARN_ON(ops->suspend && !ops->resume);
+	WARN_ON(ops->sched_scan_start && !ops->sched_scan_stop);
+	WARN_ON(ops->remain_on_channel && !ops->cancel_remain_on_channel);
+	WARN_ON(ops->tdls_channel_switch && !ops->tdls_cancel_channel_switch);
+	WARN_ON(ops->add_tx_ts && !ops->del_tx_ts);
+
+	alloc_size = sizeof(*rdev) + sizeof_priv;
+
+	rdev = kzalloc(alloc_size, GFP_KERNEL);
+	if (!rdev)
+		return NULL;
+
+	rdev->ops = ops;
+
+	rdev->wiphy_idx = atomic_inc_return(&wiphy_counter);
+
+	if (unlikely(rdev->wiphy_idx < 0)) {
+		/* ugh, wrapped! */
+		atomic_dec(&wiphy_counter);
+		kfree(rdev);
+		return NULL;
+	}
+
+	/* atomic_inc_return makes it start at 1, make it start at 0 */
+	rdev->wiphy_idx--;
+
+	/* give it a proper name */
+	if (requested_name && requested_name[0]) {
+		int rv;
+
+		rtnl_lock();
+		rv = cfg80211_dev_check_name(rdev, requested_name);
+
+		if (rv < 0) {
+			rtnl_unlock();
+			goto use_default_name;
+		}
+
+		rv = dev_set_name(&rdev->wiphy.dev, "%s", requested_name);
+		rtnl_unlock();
+		if (rv)
+			goto use_default_name;
+	} else {
+		int rv;
+
+use_default_name:
+		/* NOTE:  This is *probably* safe w/out holding rtnl because of
+		 * the restrictions on phy names.  Probably this call could
+		 * fail if some other part of the kernel (re)named a device
+		 * phyX.  But, might should add some locking and check return
+		 * value, and use a different name if this one exists?
+		 */
+		rv = dev_set_name(&rdev->wiphy.dev, PHY_NAME "%d", rdev->wiphy_idx);
+		if (rv < 0) {
+			kfree(rdev);
+			return NULL;
+		}
+	}
+
+	INIT_LIST_HEAD(&rdev->wiphy.wdev_list);
+	INIT_LIST_HEAD(&rdev->beacon_registrations);
+	spin_lock_init(&rdev->beacon_registrations_lock);
+	spin_lock_init(&rdev->bss_lock);
+	INIT_LIST_HEAD(&rdev->bss_list);
+	INIT_LIST_HEAD(&rdev->sched_scan_req_list);
+	INIT_WORK(&rdev->scan_done_wk, __cfg80211_scan_done);
+	INIT_LIST_HEAD(&rdev->mlme_unreg);
+	spin_lock_init(&rdev->mlme_unreg_lock);
+	INIT_WORK(&rdev->mlme_unreg_wk, cfg80211_mlme_unreg_wk);
+	INIT_DELAYED_WORK(&rdev->dfs_update_channels_wk,
+			  cfg80211_dfs_channels_update_work);
+#ifdef CONFIG_CFG80211_WEXT
+	rdev->wiphy.wext = &cfg80211_wext_handler;
+#endif
+
+	device_initialize(&rdev->wiphy.dev);
+	rdev->wiphy.dev.class = &ieee80211_class;
+	rdev->wiphy.dev.platform_data = rdev;
+	device_enable_async_suspend(&rdev->wiphy.dev);
+
+	INIT_WORK(&rdev->destroy_work, cfg80211_destroy_iface_wk);
+	INIT_WORK(&rdev->sched_scan_stop_wk, cfg80211_sched_scan_stop_wk);
+	INIT_WORK(&rdev->sched_scan_res_wk, cfg80211_sched_scan_results_wk);
+	INIT_WORK(&rdev->propagate_radar_detect_wk,
+		  cfg80211_propagate_radar_detect_wk);
+	INIT_WORK(&rdev->propagate_cac_done_wk, cfg80211_propagate_cac_done_wk);
+
+#ifdef CONFIG_CFG80211_DEFAULT_PS
+	rdev->wiphy.flags |= WIPHY_FLAG_PS_ON_BY_DEFAULT;
+#endif
+
+	wiphy_net_set(&rdev->wiphy, &init_net);
+
+	rdev->rfkill_ops.set_block = cfg80211_rfkill_set_block;
+	rdev->rfkill = rfkill_alloc(dev_name(&rdev->wiphy.dev),
+				   &rdev->wiphy.dev, RFKILL_TYPE_WLAN,
+				   &rdev->rfkill_ops, rdev);
+
+	if (!rdev->rfkill) {
+		wiphy_free(&rdev->wiphy);
+		return NULL;
+	}
+
+	INIT_WORK(&rdev->rfkill_block, cfg80211_rfkill_block_work);
+	INIT_WORK(&rdev->conn_work, cfg80211_conn_work);
+	INIT_WORK(&rdev->event_work, cfg80211_event_work);
+
+	init_waitqueue_head(&rdev->dev_wait);
+
+	/*
+	 * Initialize wiphy parameters to IEEE 802.11 MIB default values.
+	 * Fragmentation and RTS threshold are disabled by default with the
+	 * special -1 value.
+	 */
+	rdev->wiphy.retry_short = 7;
+	rdev->wiphy.retry_long = 4;
+	rdev->wiphy.frag_threshold = (u32) -1;
+	rdev->wiphy.rts_threshold = (u32) -1;
+	rdev->wiphy.coverage_class = 0;
+
+	rdev->wiphy.max_num_csa_counters = 1;
+
+	rdev->wiphy.max_sched_scan_plans = 1;
+	rdev->wiphy.max_sched_scan_plan_interval = U32_MAX;
+
+	return &rdev->wiphy;
+}
+EXPORT_SYMBOL(wiphy_new_nm);
+
+static int wiphy_verify_combinations(struct wiphy *wiphy)
+{
+	const struct ieee80211_iface_combination *c;
+	int i, j;
+
+	for (i = 0; i < wiphy->n_iface_combinations; i++) {
+		u32 cnt = 0;
+		u16 all_iftypes = 0;
+
+		c = &wiphy->iface_combinations[i];
+
+		/*
+		 * Combinations with just one interface aren't real,
+		 * however we make an exception for DFS.
+		 */
+		if (WARN_ON((c->max_interfaces < 2) && !c->radar_detect_widths))
+			return -EINVAL;
+
+		/* Need at least one channel */
+		if (WARN_ON(!c->num_different_channels))
+			return -EINVAL;
+
+		/*
+		 * Put a sane limit on maximum number of different
+		 * channels to simplify channel accounting code.
+		 */
+		if (WARN_ON(c->num_different_channels >
+				CFG80211_MAX_NUM_DIFFERENT_CHANNELS))
+			return -EINVAL;
+
+		/* DFS only works on one channel. */
+		if (WARN_ON(c->radar_detect_widths &&
+			    (c->num_different_channels > 1)))
+			return -EINVAL;
+
+		if (WARN_ON(!c->n_limits))
+			return -EINVAL;
+
+		for (j = 0; j < c->n_limits; j++) {
+			u16 types = c->limits[j].types;
+
+			/* interface types shouldn't overlap */
+			if (WARN_ON(types & all_iftypes))
+				return -EINVAL;
+			all_iftypes |= types;
+
+			if (WARN_ON(!c->limits[j].max))
+				return -EINVAL;
+
+			/* Shouldn't list software iftypes in combinations! */
+			if (WARN_ON(wiphy->software_iftypes & types))
+				return -EINVAL;
+
+			/* Only a single P2P_DEVICE can be allowed */
+			if (WARN_ON(types & BIT(NL80211_IFTYPE_P2P_DEVICE) &&
+				    c->limits[j].max > 1))
+				return -EINVAL;
+
+			/* Only a single NAN can be allowed */
+			if (WARN_ON(types & BIT(NL80211_IFTYPE_NAN) &&
+				    c->limits[j].max > 1))
+				return -EINVAL;
+
+			/*
+			 * This isn't well-defined right now. If you have an
+			 * IBSS interface, then its beacon interval may change
+			 * by joining other networks, and nothing prevents it
+			 * from doing that.
+			 * So technically we probably shouldn't even allow AP
+			 * and IBSS in the same interface, but it seems that
+			 * some drivers support that, possibly only with fixed
+			 * beacon intervals for IBSS.
+			 */
+			if (WARN_ON(types & BIT(NL80211_IFTYPE_ADHOC) &&
+				    c->beacon_int_min_gcd)) {
+				return -EINVAL;
+			}
+
+			cnt += c->limits[j].max;
+			/*
+			 * Don't advertise an unsupported type
+			 * in a combination.
+			 */
+			if (WARN_ON((wiphy->interface_modes & types) != types))
+				return -EINVAL;
+		}
+
+#ifndef CONFIG_WIRELESS_WDS
+		if (WARN_ON(all_iftypes & BIT(NL80211_IFTYPE_WDS)))
+			return -EINVAL;
+#endif
+
+		/* You can't even choose that many! */
+		if (WARN_ON(cnt < c->max_interfaces))
+			return -EINVAL;
+	}
+
+	return 0;
+}
+
+int wiphy_register(struct wiphy *wiphy)
+{
+	struct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);
+	int res;
+	enum nl80211_band band;
+	struct ieee80211_supported_band *sband;
+	bool have_band = false;
+	int i;
+	u16 ifmodes = wiphy->interface_modes;
+
+#ifdef CONFIG_PM
+	if (WARN_ON(wiphy->wowlan &&
+		    (wiphy->wowlan->flags & WIPHY_WOWLAN_GTK_REKEY_FAILURE) &&
+		    !(wiphy->wowlan->flags & WIPHY_WOWLAN_SUPPORTS_GTK_REKEY)))
+		return -EINVAL;
+	if (WARN_ON(wiphy->wowlan &&
+		    !wiphy->wowlan->flags && !wiphy->wowlan->n_patterns &&
+		    !wiphy->wowlan->tcp))
+		return -EINVAL;
+#endif
+	if (WARN_ON((wiphy->features & NL80211_FEATURE_TDLS_CHANNEL_SWITCH) &&
+		    (!rdev->ops->tdls_channel_switch ||
+		     !rdev->ops->tdls_cancel_channel_switch)))
+		return -EINVAL;
+
+	if (WARN_ON((wiphy->interface_modes & BIT(NL80211_IFTYPE_NAN)) &&
+		    (!rdev->ops->start_nan || !rdev->ops->stop_nan ||
+		     !rdev->ops->add_nan_func || !rdev->ops->del_nan_func ||
+		     !(wiphy->nan_supported_bands & BIT(NL80211_BAND_2GHZ)))))
+		return -EINVAL;
+
+#ifndef CONFIG_WIRELESS_WDS
+	if (WARN_ON(wiphy->interface_modes & BIT(NL80211_IFTYPE_WDS)))
+		return -EINVAL;
+#endif
+
+	if (WARN_ON(wiphy->pmsr_capa && !wiphy->pmsr_capa->ftm.supported))
+		return -EINVAL;
+
+	if (wiphy->pmsr_capa && wiphy->pmsr_capa->ftm.supported) {
+		if (WARN_ON(!wiphy->pmsr_capa->ftm.asap &&
+			    !wiphy->pmsr_capa->ftm.non_asap))
+			return -EINVAL;
+		if (WARN_ON(!wiphy->pmsr_capa->ftm.preambles ||
+			    !wiphy->pmsr_capa->ftm.bandwidths))
+			return -EINVAL;
+		if (WARN_ON(wiphy->pmsr_capa->ftm.preambles &
+				~(BIT(NL80211_PREAMBLE_LEGACY) |
+				  BIT(NL80211_PREAMBLE_HT) |
+				  BIT(NL80211_PREAMBLE_VHT) |
+				  BIT(NL80211_PREAMBLE_DMG))))
+			return -EINVAL;
+		if (WARN_ON(wiphy->pmsr_capa->ftm.bandwidths &
+				~(BIT(NL80211_CHAN_WIDTH_20_NOHT) |
+				  BIT(NL80211_CHAN_WIDTH_20) |
+				  BIT(NL80211_CHAN_WIDTH_40) |
+				  BIT(NL80211_CHAN_WIDTH_80) |
+				  BIT(NL80211_CHAN_WIDTH_80P80) |
+				  BIT(NL80211_CHAN_WIDTH_160) |
+				  BIT(NL80211_CHAN_WIDTH_5) |
+				  BIT(NL80211_CHAN_WIDTH_10))))
+			return -EINVAL;
+	}
+
+	/*
+	 * if a wiphy has unsupported modes for regulatory channel enforcement,
+	 * opt-out of enforcement checking
+	 */
+	if (wiphy->interface_modes & ~(BIT(NL80211_IFTYPE_STATION) |
+				       BIT(NL80211_IFTYPE_P2P_CLIENT) |
+				       BIT(NL80211_IFTYPE_AP) |
+				       BIT(NL80211_IFTYPE_P2P_GO) |
+				       BIT(NL80211_IFTYPE_ADHOC) |
+				       BIT(NL80211_IFTYPE_P2P_DEVICE) |
+				       BIT(NL80211_IFTYPE_NAN) |
+				       BIT(NL80211_IFTYPE_AP_VLAN) |
+				       BIT(NL80211_IFTYPE_MONITOR)))
+		wiphy->regulatory_flags |= REGULATORY_IGNORE_STALE_KICKOFF;
+
+	if (WARN_ON((wiphy->regulatory_flags & REGULATORY_WIPHY_SELF_MANAGED) &&
+		    (wiphy->regulatory_flags &
+					(REGULATORY_CUSTOM_REG |
+					 REGULATORY_STRICT_REG |
+					 REGULATORY_COUNTRY_IE_FOLLOW_POWER |
+					 REGULATORY_COUNTRY_IE_IGNORE))))
+		return -EINVAL;
+
+	if (WARN_ON(wiphy->coalesce &&
+		    (!wiphy->coalesce->n_rules ||
+		     !wiphy->coalesce->n_patterns) &&
+		    (!wiphy->coalesce->pattern_min_len ||
+		     wiphy->coalesce->pattern_min_len >
+			wiphy->coalesce->pattern_max_len)))
+		return -EINVAL;
+
+	if (WARN_ON(wiphy->ap_sme_capa &&
+		    !(wiphy->flags & WIPHY_FLAG_HAVE_AP_SME)))
+		return -EINVAL;
+
+	if (WARN_ON(wiphy->addresses && !wiphy->n_addresses))
+		return -EINVAL;
+
+	if (WARN_ON(wiphy->addresses &&
+		    !is_zero_ether_addr(wiphy->perm_addr) &&
+		    memcmp(wiphy->perm_addr, wiphy->addresses[0].addr,
+			   ETH_ALEN)))
+		return -EINVAL;
+
+	if (WARN_ON(wiphy->max_acl_mac_addrs &&
+		    (!(wiphy->flags & WIPHY_FLAG_HAVE_AP_SME) ||
+		     !rdev->ops->set_mac_acl)))
+		return -EINVAL;
+
+	/* assure only valid behaviours are flagged by driver
+	 * hence subtract 2 as bit 0 is invalid.
+	 */
+	if (WARN_ON(wiphy->bss_select_support &&
+		    (wiphy->bss_select_support & ~(BIT(__NL80211_BSS_SELECT_ATTR_AFTER_LAST) - 2))))
+		return -EINVAL;
+
+	if (WARN_ON(wiphy_ext_feature_isset(&rdev->wiphy,
+					    NL80211_EXT_FEATURE_4WAY_HANDSHAKE_STA_1X) &&
+		    (!rdev->ops->set_pmk || !rdev->ops->del_pmk)))
+		return -EINVAL;
+
+	if (WARN_ON(!(rdev->wiphy.flags & WIPHY_FLAG_SUPPORTS_FW_ROAM) &&
+		    rdev->ops->update_connect_params))
+		return -EINVAL;
+
+	if (wiphy->addresses)
+		memcpy(wiphy->perm_addr, wiphy->addresses[0].addr, ETH_ALEN);
+
+	/* sanity check ifmodes */
+	WARN_ON(!ifmodes);
+	ifmodes &= ((1 << NUM_NL80211_IFTYPES) - 1) & ~1;
+	if (WARN_ON(ifmodes != wiphy->interface_modes))
+		wiphy->interface_modes = ifmodes;
+
+	res = wiphy_verify_combinations(wiphy);
+	if (res)
+		return res;
+
+	/* sanity check supported bands/channels */
+	for (band = 0; band < NUM_NL80211_BANDS; band++) {
+		u16 types = 0;
+
+		sband = wiphy->bands[band];
+		if (!sband)
+			continue;
+
+		sband->band = band;
+		if (WARN_ON(!sband->n_channels))
+			return -EINVAL;
+		/*
+		 * on 60GHz band, there are no legacy rates, so
+		 * n_bitrates is 0
+		 */
+		if (WARN_ON(band != NL80211_BAND_60GHZ &&
+			    !sband->n_bitrates))
+			return -EINVAL;
+
+		/*
+		 * Since cfg80211_disable_40mhz_24ghz is global, we can
+		 * modify the sband's ht data even if the driver uses a
+		 * global structure for that.
+		 */
+		if (cfg80211_disable_40mhz_24ghz &&
+		    band == NL80211_BAND_2GHZ &&
+		    sband->ht_cap.ht_supported) {
+			sband->ht_cap.cap &= ~IEEE80211_HT_CAP_SUP_WIDTH_20_40;
+			sband->ht_cap.cap &= ~IEEE80211_HT_CAP_SGI_40;
+		}
+
+		/*
+		 * Since we use a u32 for rate bitmaps in
+		 * ieee80211_get_response_rate, we cannot
+		 * have more than 32 legacy rates.
+		 */
+		if (WARN_ON(sband->n_bitrates > 32))
+			return -EINVAL;
+
+		for (i = 0; i < sband->n_channels; i++) {
+			sband->channels[i].orig_flags =
+				sband->channels[i].flags;
+			sband->channels[i].orig_mag = INT_MAX;
+			sband->channels[i].orig_mpwr =
+				sband->channels[i].max_power;
+			sband->channels[i].band = band;
+		}
+
+		for (i = 0; i < sband->n_iftype_data; i++) {
+			const struct ieee80211_sband_iftype_data *iftd;
+
+			iftd = &sband->iftype_data[i];
+
+			if (WARN_ON(!iftd->types_mask))
+				return -EINVAL;
+			if (WARN_ON(types & iftd->types_mask))
+				return -EINVAL;
+
+			/* at least one piece of information must be present */
+			if (WARN_ON(!iftd->he_cap.has_he))
+				return -EINVAL;
+
+			types |= iftd->types_mask;
+		}
+
+		have_band = true;
+	}
+
+	if (!have_band) {
+		WARN_ON(1);
+		return -EINVAL;
+	}
+
+	for (i = 0; i < rdev->wiphy.n_vendor_commands; i++) {
+		/*
+		 * Validate we have a policy (can be explicitly set to
+		 * VENDOR_CMD_RAW_DATA which is non-NULL) and also that
+		 * we have at least one of doit/dumpit.
+		 */
+		if (WARN_ON(!rdev->wiphy.vendor_commands[i].policy))
+			return -EINVAL;
+		if (WARN_ON(!rdev->wiphy.vendor_commands[i].doit &&
+			    !rdev->wiphy.vendor_commands[i].dumpit))
+			return -EINVAL;
+	}
+
+#ifdef CONFIG_PM
+	if (WARN_ON(rdev->wiphy.wowlan && rdev->wiphy.wowlan->n_patterns &&
+		    (!rdev->wiphy.wowlan->pattern_min_len ||
+		     rdev->wiphy.wowlan->pattern_min_len >
+				rdev->wiphy.wowlan->pattern_max_len)))
+		return -EINVAL;
+#endif
+
+	/* check and set up bitrates */
+	ieee80211_set_bitrate_flags(wiphy);
+
+	rdev->wiphy.features |= NL80211_FEATURE_SCAN_FLUSH;
+
+	rtnl_lock();
+	res = device_add(&rdev->wiphy.dev);
+	if (res) {
+		rtnl_unlock();
+		return res;
+	}
+
+	/* set up regulatory info */
+	wiphy_regulatory_register(wiphy);
+
+	list_add_rcu(&rdev->list, &cfg80211_rdev_list);
+	cfg80211_rdev_list_generation++;
+
+	/* add to debugfs */
+	rdev->wiphy.debugfsdir = debugfs_create_dir(wiphy_name(&rdev->wiphy),
+						    ieee80211_debugfs_dir);
+
+	cfg80211_debugfs_rdev_add(rdev);
+	nl80211_notify_wiphy(rdev, NL80211_CMD_NEW_WIPHY);
+
+	if (wiphy->regulatory_flags & REGULATORY_CUSTOM_REG) {
+		struct regulatory_request request;
+
+		request.wiphy_idx = get_wiphy_idx(wiphy);
+		request.initiator = NL80211_REGDOM_SET_BY_DRIVER;
+		request.alpha2[0] = '9';
+		request.alpha2[1] = '9';
+
+		nl80211_send_reg_change_event(&request);
+	}
+
+	/* Check that nobody globally advertises any capabilities they do not
+	 * advertise on all possible interface types.
+	 */
+	if (wiphy->extended_capabilities_len &&
+	    wiphy->num_iftype_ext_capab &&
+	    wiphy->iftype_ext_capab) {
+		u8 supported_on_all, j;
+		const struct wiphy_iftype_ext_capab *capab;
+
+		capab = wiphy->iftype_ext_capab;
+		for (j = 0; j < wiphy->extended_capabilities_len; j++) {
+			if (capab[0].extended_capabilities_len > j)
+				supported_on_all =
+					capab[0].extended_capabilities[j];
+			else
+				supported_on_all = 0x00;
+			for (i = 1; i < wiphy->num_iftype_ext_capab; i++) {
+				if (j >= capab[i].extended_capabilities_len) {
+					supported_on_all = 0x00;
+					break;
+				}
+				supported_on_all &=
+					capab[i].extended_capabilities[j];
+			}
+			if (WARN_ON(wiphy->extended_capabilities[j] &
+				    ~supported_on_all))
+				break;
+		}
+	}
+
+	rdev->wiphy.registered = true;
+	rtnl_unlock();
+
+	res = rfkill_register(rdev->rfkill);
+	if (res) {
+		rfkill_destroy(rdev->rfkill);
+		rdev->rfkill = NULL;
+		wiphy_unregister(&rdev->wiphy);
+		return res;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(wiphy_register);
+
+void wiphy_rfkill_start_polling(struct wiphy *wiphy)
+{
+	struct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);
+
+	if (!rdev->ops->rfkill_poll)
+		return;
+	rdev->rfkill_ops.poll = cfg80211_rfkill_poll;
+	rfkill_resume_polling(rdev->rfkill);
+}
+EXPORT_SYMBOL(wiphy_rfkill_start_polling);
+
+void wiphy_rfkill_stop_polling(struct wiphy *wiphy)
+{
+	struct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);
+
+	rfkill_pause_polling(rdev->rfkill);
+}
+EXPORT_SYMBOL(wiphy_rfkill_stop_polling);
+
+void wiphy_unregister(struct wiphy *wiphy)
+{
+	struct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);
+
+	wait_event(rdev->dev_wait, ({
+		int __count;
+		rtnl_lock();
+		__count = rdev->opencount;
+		rtnl_unlock();
+		__count == 0; }));
+
+	if (rdev->rfkill)
+		rfkill_unregister(rdev->rfkill);
+
+	rtnl_lock();
+	nl80211_notify_wiphy(rdev, NL80211_CMD_DEL_WIPHY);
+	rdev->wiphy.registered = false;
+
+	WARN_ON(!list_empty(&rdev->wiphy.wdev_list));
+
+	/*
+	 * First remove the hardware from everywhere, this makes
+	 * it impossible to find from userspace.
+	 */
+	debugfs_remove_recursive(rdev->wiphy.debugfsdir);
+	list_del_rcu(&rdev->list);
+	synchronize_rcu();
+
+	/*
+	 * If this device got a regulatory hint tell core its
+	 * free to listen now to a new shiny device regulatory hint
+	 */
+	wiphy_regulatory_deregister(wiphy);
+
+	cfg80211_rdev_list_generation++;
+	device_del(&rdev->wiphy.dev);
+
+	rtnl_unlock();
+
+	flush_work(&rdev->scan_done_wk);
+	cancel_work_sync(&rdev->conn_work);
+	flush_work(&rdev->event_work);
+	cancel_delayed_work_sync(&rdev->dfs_update_channels_wk);
+	flush_work(&rdev->destroy_work);
+	flush_work(&rdev->sched_scan_stop_wk);
+	flush_work(&rdev->mlme_unreg_wk);
+	flush_work(&rdev->propagate_radar_detect_wk);
+	flush_work(&rdev->propagate_cac_done_wk);
+
+#ifdef CONFIG_PM
+	if (rdev->wiphy.wowlan_config && rdev->ops->set_wakeup)
+		rdev_set_wakeup(rdev, false);
+#endif
+	cfg80211_rdev_free_wowlan(rdev);
+	cfg80211_rdev_free_coalesce(rdev);
+}
+EXPORT_SYMBOL(wiphy_unregister);
+
+void cfg80211_dev_free(struct cfg80211_registered_device *rdev)
+{
+	struct cfg80211_internal_bss *scan, *tmp;
+	struct cfg80211_beacon_registration *reg, *treg;
+	rfkill_destroy(rdev->rfkill);
+	list_for_each_entry_safe(reg, treg, &rdev->beacon_registrations, list) {
+		list_del(&reg->list);
+		kfree(reg);
+	}
+	list_for_each_entry_safe(scan, tmp, &rdev->bss_list, list)
+		cfg80211_put_bss(&rdev->wiphy, &scan->pub);
+	kfree(rdev);
+}
+
+void wiphy_free(struct wiphy *wiphy)
+{
+	put_device(&wiphy->dev);
+}
+EXPORT_SYMBOL(wiphy_free);
+
+void wiphy_rfkill_set_hw_state(struct wiphy *wiphy, bool blocked)
+{
+	struct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);
+
+	if (rfkill_set_hw_state(rdev->rfkill, blocked))
+		schedule_work(&rdev->rfkill_block);
+}
+EXPORT_SYMBOL(wiphy_rfkill_set_hw_state);
+
+void cfg80211_cqm_config_free(struct wireless_dev *wdev)
+{
+	kfree(wdev->cqm_config);
+	wdev->cqm_config = NULL;
+}
+
+static void __cfg80211_unregister_wdev(struct wireless_dev *wdev, bool sync)
+{
+	struct cfg80211_registered_device *rdev = wiphy_to_rdev(wdev->wiphy);
+
+	ASSERT_RTNL();
+
+	flush_work(&wdev->pmsr_free_wk);
+
+	nl80211_notify_iface(rdev, wdev, NL80211_CMD_DEL_INTERFACE);
+
+	list_del_rcu(&wdev->list);
+	if (sync)
+		synchronize_rcu();
+	rdev->devlist_generation++;
+
+	cfg80211_mlme_purge_registrations(wdev);
+
+	switch (wdev->iftype) {
+	case NL80211_IFTYPE_P2P_DEVICE:
+		cfg80211_stop_p2p_device(rdev, wdev);
+		break;
+	case NL80211_IFTYPE_NAN:
+		cfg80211_stop_nan(rdev, wdev);
+		break;
+	default:
+		break;
+	}
+
+#ifdef CONFIG_CFG80211_WEXT
+	kzfree(wdev->wext.keys);
+	wdev->wext.keys = NULL;
+#endif
+	/* only initialized if we have a netdev */
+	if (wdev->netdev)
+		flush_work(&wdev->disconnect_wk);
+
+	cfg80211_cqm_config_free(wdev);
+}
+
+void cfg80211_unregister_wdev(struct wireless_dev *wdev)
+{
+	if (WARN_ON(wdev->netdev))
+		return;
+
+	__cfg80211_unregister_wdev(wdev, true);
+}
+EXPORT_SYMBOL(cfg80211_unregister_wdev);
+
+static const struct device_type wiphy_type = {
+	.name	= "wlan",
+};
+
+void cfg80211_update_iface_num(struct cfg80211_registered_device *rdev,
+			       enum nl80211_iftype iftype, int num)
+{
+	ASSERT_RTNL();
+
+	rdev->num_running_ifaces += num;
+	if (iftype == NL80211_IFTYPE_MONITOR)
+		rdev->num_running_monitor_ifaces += num;
+}
+
+void __cfg80211_leave(struct cfg80211_registered_device *rdev,
+		      struct wireless_dev *wdev)
+{
+	struct net_device *dev = wdev->netdev;
+	struct cfg80211_sched_scan_request *pos, *tmp;
+
+	ASSERT_RTNL();
+	ASSERT_WDEV_LOCK(wdev);
+
+	cfg80211_pmsr_wdev_down(wdev);
+
+	switch (wdev->iftype) {
+	case NL80211_IFTYPE_ADHOC:
+		__cfg80211_leave_ibss(rdev, dev, true);
+		break;
+	case NL80211_IFTYPE_P2P_CLIENT:
+	case NL80211_IFTYPE_STATION:
+		list_for_each_entry_safe(pos, tmp, &rdev->sched_scan_req_list,
+					 list) {
+			if (dev == pos->dev)
+				cfg80211_stop_sched_scan_req(rdev, pos, false);
+		}
+
+#ifdef CONFIG_CFG80211_WEXT
+		kfree(wdev->wext.ie);
+		wdev->wext.ie = NULL;
+		wdev->wext.ie_len = 0;
+		wdev->wext.connect.auth_type = NL80211_AUTHTYPE_AUTOMATIC;
+#endif
+		cfg80211_disconnect(rdev, dev,
+				    WLAN_REASON_DEAUTH_LEAVING, true);
+		break;
+	case NL80211_IFTYPE_MESH_POINT:
+		__cfg80211_leave_mesh(rdev, dev);
+		break;
+	case NL80211_IFTYPE_AP:
+	case NL80211_IFTYPE_P2P_GO:
+		__cfg80211_stop_ap(rdev, dev, true);
+		break;
+	case NL80211_IFTYPE_OCB:
+		__cfg80211_leave_ocb(rdev, dev);
+		break;
+	case NL80211_IFTYPE_WDS:
+		/* must be handled by mac80211/driver, has no APIs */
+		break;
+	case NL80211_IFTYPE_P2P_DEVICE:
+	case NL80211_IFTYPE_NAN:
+		/* cannot happen, has no netdev */
+		break;
+	case NL80211_IFTYPE_AP_VLAN:
+	case NL80211_IFTYPE_MONITOR:
+		/* nothing to do */
+		break;
+	case NL80211_IFTYPE_UNSPECIFIED:
+	case NUM_NL80211_IFTYPES:
+		/* invalid */
+		break;
+	}
+}
+
+void cfg80211_leave(struct cfg80211_registered_device *rdev,
+		    struct wireless_dev *wdev)
+{
+	wdev_lock(wdev);
+	__cfg80211_leave(rdev, wdev);
+	wdev_unlock(wdev);
+}
+
+void cfg80211_stop_iface(struct wiphy *wiphy, struct wireless_dev *wdev,
+			 gfp_t gfp)
+{
+	struct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);
+	struct cfg80211_event *ev;
+	unsigned long flags;
+
+	trace_cfg80211_stop_iface(wiphy, wdev);
+
+	ev = kzalloc(sizeof(*ev), gfp);
+	if (!ev)
+		return;
+
+	ev->type = EVENT_STOPPED;
+
+	spin_lock_irqsave(&wdev->event_lock, flags);
+	list_add_tail(&ev->list, &wdev->event_list);
+	spin_unlock_irqrestore(&wdev->event_lock, flags);
+	queue_work(cfg80211_wq, &rdev->event_work);
+}
+EXPORT_SYMBOL(cfg80211_stop_iface);
+
+void cfg80211_init_wdev(struct cfg80211_registered_device *rdev,
+			struct wireless_dev *wdev)
+{
+	mutex_init(&wdev->mtx);
+	INIT_LIST_HEAD(&wdev->event_list);
+	spin_lock_init(&wdev->event_lock);
+	INIT_LIST_HEAD(&wdev->mgmt_registrations);
+	spin_lock_init(&wdev->mgmt_registrations_lock);
+	INIT_LIST_HEAD(&wdev->pmsr_list);
+	spin_lock_init(&wdev->pmsr_lock);
+	INIT_WORK(&wdev->pmsr_free_wk, cfg80211_pmsr_free_wk);
+
+	/*
+	 * We get here also when the interface changes network namespaces,
+	 * as it's registered into the new one, but we don't want it to
+	 * change ID in that case. Checking if the ID is already assigned
+	 * works, because 0 isn't considered a valid ID and the memory is
+	 * 0-initialized.
+	 */
+	if (!wdev->identifier)
+		wdev->identifier = ++rdev->wdev_id;
+	list_add_rcu(&wdev->list, &rdev->wiphy.wdev_list);
+	rdev->devlist_generation++;
+
+	nl80211_notify_iface(rdev, wdev, NL80211_CMD_NEW_INTERFACE);
+}
+
+static int cfg80211_netdev_notifier_call(struct notifier_block *nb,
+					 unsigned long state, void *ptr)
+{
+	struct net_device *dev = netdev_notifier_info_to_dev(ptr);
+	struct wireless_dev *wdev = dev->ieee80211_ptr;
+	struct cfg80211_registered_device *rdev;
+	struct cfg80211_sched_scan_request *pos, *tmp;
+
+	if (!wdev)
+		return NOTIFY_DONE;
+
+	rdev = wiphy_to_rdev(wdev->wiphy);
+
+	WARN_ON(wdev->iftype == NL80211_IFTYPE_UNSPECIFIED);
+
+	switch (state) {
+	case NETDEV_POST_INIT:
+		SET_NETDEV_DEVTYPE(dev, &wiphy_type);
+		break;
+	case NETDEV_REGISTER:
+		/*
+		 * NB: cannot take rdev->mtx here because this may be
+		 * called within code protected by it when interfaces
+		 * are added with nl80211.
+		 */
+		/* can only change netns with wiphy */
+		dev->features |= NETIF_F_NETNS_LOCAL;
+
+		if (sysfs_create_link(&dev->dev.kobj, &rdev->wiphy.dev.kobj,
+				      "phy80211")) {
+			pr_err("failed to add phy80211 symlink to netdev!\n");
+		}
+		wdev->netdev = dev;
+#ifdef CONFIG_CFG80211_WEXT
+		wdev->wext.default_key = -1;
+		wdev->wext.default_mgmt_key = -1;
+		wdev->wext.connect.auth_type = NL80211_AUTHTYPE_AUTOMATIC;
+#endif
+
+		if (wdev->wiphy->flags & WIPHY_FLAG_PS_ON_BY_DEFAULT)
+			wdev->ps = true;
+		else
+			wdev->ps = false;
+		/* allow mac80211 to determine the timeout */
+		wdev->ps_timeout = -1;
+
+		if ((wdev->iftype == NL80211_IFTYPE_STATION ||
+		     wdev->iftype == NL80211_IFTYPE_P2P_CLIENT ||
+		     wdev->iftype == NL80211_IFTYPE_ADHOC) && !wdev->use_4addr)
+			dev->priv_flags |= IFF_DONT_BRIDGE;
+
+		INIT_WORK(&wdev->disconnect_wk, cfg80211_autodisconnect_wk);
+
+		cfg80211_init_wdev(rdev, wdev);
+		break;
+	case NETDEV_GOING_DOWN:
+		cfg80211_leave(rdev, wdev);
+		break;
+	case NETDEV_DOWN:
+		cfg80211_update_iface_num(rdev, wdev->iftype, -1);
+		if (rdev->scan_req && rdev->scan_req->wdev == wdev) {
+			if (WARN_ON(!rdev->scan_req->notified))
+				rdev->scan_req->info.aborted = true;
+			___cfg80211_scan_done(rdev, false);
+		}
+
+		list_for_each_entry_safe(pos, tmp,
+					 &rdev->sched_scan_req_list, list) {
+			if (WARN_ON(pos->dev == wdev->netdev))
+				cfg80211_stop_sched_scan_req(rdev, pos, false);
+		}
+
+		rdev->opencount--;
+		wake_up(&rdev->dev_wait);
+		break;
+	case NETDEV_UP:
+		cfg80211_update_iface_num(rdev, wdev->iftype, 1);
+		wdev_lock(wdev);
+		switch (wdev->iftype) {
+#ifdef CONFIG_CFG80211_WEXT
+		case NL80211_IFTYPE_ADHOC:
+			cfg80211_ibss_wext_join(rdev, wdev);
+			break;
+		case NL80211_IFTYPE_STATION:
+			cfg80211_mgd_wext_connect(rdev, wdev);
+			break;
+#endif
+#ifdef CONFIG_MAC80211_MESH
+		case NL80211_IFTYPE_MESH_POINT:
+			{
+				/* backward compat code... */
+				struct mesh_setup setup;
+				memcpy(&setup, &default_mesh_setup,
+						sizeof(setup));
+				 /* back compat only needed for mesh_id */
+				setup.mesh_id = wdev->ssid;
+				setup.mesh_id_len = wdev->mesh_id_up_len;
+				if (wdev->mesh_id_up_len)
+					__cfg80211_join_mesh(rdev, dev,
+							&setup,
+							&default_mesh_config);
+				break;
+			}
+#endif
+		default:
+			break;
+		}
+		wdev_unlock(wdev);
+		rdev->opencount++;
+
+		/*
+		 * Configure power management to the driver here so that its
+		 * correctly set also after interface type changes etc.
+		 */
+		if ((wdev->iftype == NL80211_IFTYPE_STATION ||
+		     wdev->iftype == NL80211_IFTYPE_P2P_CLIENT) &&
+		    rdev->ops->set_power_mgmt &&
+		    rdev_set_power_mgmt(rdev, dev, wdev->ps,
+					wdev->ps_timeout)) {
+			/* assume this means it's off */
+			wdev->ps = false;
+		}
+		break;
+	case NETDEV_UNREGISTER:
+		/*
+		 * It is possible to get NETDEV_UNREGISTER
+		 * multiple times. To detect that, check
+		 * that the interface is still on the list
+		 * of registered interfaces, and only then
+		 * remove and clean it up.
+		 */
+		if (!list_empty(&wdev->list)) {
+			__cfg80211_unregister_wdev(wdev, false);
+			sysfs_remove_link(&dev->dev.kobj, "phy80211");
+		}
+		/*
+		 * synchronise (so that we won't find this netdev
+		 * from other code any more) and then clear the list
+		 * head so that the above code can safely check for
+		 * !list_empty() to avoid double-cleanup.
+		 */
+		synchronize_rcu();
+		INIT_LIST_HEAD(&wdev->list);
+		/*
+		 * Ensure that all events have been processed and
+		 * freed.
+		 */
+		cfg80211_process_wdev_events(wdev);
+
+		if (WARN_ON(wdev->current_bss)) {
+			cfg80211_unhold_bss(wdev->current_bss);
+			cfg80211_put_bss(wdev->wiphy, &wdev->current_bss->pub);
+			wdev->current_bss = NULL;
+		}
+		break;
+	case NETDEV_PRE_UP:
+		if (!cfg80211_iftype_allowed(wdev->wiphy, wdev->iftype,
+					     wdev->use_4addr, 0))
+			return notifier_from_errno(-EOPNOTSUPP);
+
+		if (rfkill_blocked(rdev->rfkill))
+			return notifier_from_errno(-ERFKILL);
+		break;
+	default:
+		return NOTIFY_DONE;
+	}
+
+	wireless_nlevent_flush();
+
+	return NOTIFY_OK;
+}
+
+static struct notifier_block cfg80211_netdev_notifier = {
+	.notifier_call = cfg80211_netdev_notifier_call,
+};
+
+static void __net_exit cfg80211_pernet_exit(struct net *net)
+{
+	struct cfg80211_registered_device *rdev;
+
+	rtnl_lock();
+	list_for_each_entry(rdev, &cfg80211_rdev_list, list) {
+		if (net_eq(wiphy_net(&rdev->wiphy), net))
+			WARN_ON(cfg80211_switch_netns(rdev, &init_net));
+	}
+	rtnl_unlock();
+}
+
+static struct pernet_operations cfg80211_pernet_ops = {
+	.exit = cfg80211_pernet_exit,
+};
+
+static int __init cfg80211_init(void)
+{
+	int err;
+
+	err = register_pernet_device(&cfg80211_pernet_ops);
+	if (err)
+		goto out_fail_pernet;
+
+	err = wiphy_sysfs_init();
+	if (err)
+		goto out_fail_sysfs;
+
+	err = register_netdevice_notifier(&cfg80211_netdev_notifier);
+	if (err)
+		goto out_fail_notifier;
+
+	err = nl80211_init();
+	if (err)
+		goto out_fail_nl80211;
+
+	ieee80211_debugfs_dir = debugfs_create_dir("ieee80211", NULL);
+
+	err = regulatory_init();
+	if (err)
+		goto out_fail_reg;
+
+	cfg80211_wq = alloc_ordered_workqueue("cfg80211", WQ_MEM_RECLAIM);
+	if (!cfg80211_wq) {
+		err = -ENOMEM;
+		goto out_fail_wq;
+	}
+
+	return 0;
+
+out_fail_wq:
+	regulatory_exit();
+out_fail_reg:
+	debugfs_remove(ieee80211_debugfs_dir);
+	nl80211_exit();
+out_fail_nl80211:
+	unregister_netdevice_notifier(&cfg80211_netdev_notifier);
+out_fail_notifier:
+	wiphy_sysfs_exit();
+out_fail_sysfs:
+	unregister_pernet_device(&cfg80211_pernet_ops);
+out_fail_pernet:
+	return err;
+}
+fs_initcall(cfg80211_init);
+
+static void __exit cfg80211_exit(void)
+{
+	debugfs_remove(ieee80211_debugfs_dir);
+	nl80211_exit();
+	unregister_netdevice_notifier(&cfg80211_netdev_notifier);
+	wiphy_sysfs_exit();
+	regulatory_exit();
+	unregister_pernet_device(&cfg80211_pernet_ops);
+	destroy_workqueue(cfg80211_wq);
+}
+module_exit(cfg80211_exit);
